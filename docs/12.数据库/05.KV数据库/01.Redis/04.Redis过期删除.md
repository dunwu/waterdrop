---
title: Redis 过期删除
categories:
  - 数据库
  - KV数据库
  - Redis
tags:
  - 数据库
  - KV数据库
  - Redis
date: 2023-08-23 15:14:13
permalink: /pages/ce0453/
---

# Redis 过期删除

## Redis 过期删除

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

### 设置键的生存时间或过期时间

Redis 中，和键的生存时间相关的命令如下所示：

| 命令        | 描述                                        |
| ----------- | ------------------------------------------- |
| `TTL`       | `TTL key-name`—查看给定键距离过期还有多少秒 |
| `EXPIRE`    | 设置 key 的过期时间，单位为秒               |
| `PEXPIRE`   | 设置 key 的过期时间，单位为毫秒             |
| `EXPIREAT`  | 设置 key 的过期时间为指定的秒级时间戳       |
| `PEXPIREAT` | 设置 key 的过期时间为指定的毫秒级时间戳     |
| `TTL`       | 返回 key 的剩余生存时间，单位为秒           |
| `PTTL`      | 返回 key 的剩余生存时间，单位为毫秒         |
| `PERSIST`   | 移除 key 的过期时间，key 将持久保持         |

【示例】EXPIRE、TTL 操作

```shell
> set key value
OK
# 设置 key 的生存时间为 60s
> expire key 60
(integer) 1
# 查看 key 的剩余生存时间
> ttl key
(integer) 58
# 60s 之内
> get key
"value"
# 60s 之外
> get key
(nil)
```

【示例】EXPIREAT、TTL 操作

```shell
> set key value
OK
# 设置 key 的生存时间为 1692419299
> expireat key 1692419299
(integer) 1
# 查看 key 的剩余生存时间
> ttl key
(integer) 9948
# 1692419299 之前
> get key
"value"
# 1692419299 之后
> get key
(nil)
```

### 如何判定 key 已过期了？

在 Redis 中，redisDb 结构的 `expires` 字典保存了数据库中所有键的过期时间，这个字典称为过期字典：

- 过期字典的键是一个指针，这个指针指向某个键对象
- 过期字典的值是一个 long long 类型的整数，这个整数保存了键的过期时间。

```c
typedef struct redisDb {

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;

    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳
    dict *expires;

    // ...
} redisDb;
```

过期字典的数据结构如下图所示：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。

过期键判断流程如下：

- 检查指定 key 是否存在于过期字典；如果存在，取得 key 的过期时间
- 检查当前时间戳是否大于 key 的过期时间：如果是，key 已过期；反之，key 未过期。

### 过期删除策略

- **定时删除** - 在设置 key 的过期时间的同时，创建一个定时器，让定时器在 key 的过期时间来临时，立即执行 key 的删除操作。
  - 优点 - 保证过期 key 被尽可能快的删除，释放内存。
  - 缺点 - 如果过期 key 较多，会占用很多的 CPU，从而影响服务器的吞吐量和响应时延。

- **惰性删除** - 放任 key 过期不管，但是每次从 key 空间中获取 key 时，都检查取得的 key 是否过期，如果过期的话，就删除该 key ；如果没有过期，就返回该 key。
  - 优点 - 占用 CPU 最少。
  - 缺点 - 过期的 key 可能因为没有被访问，而一直无法释放，造成浪费太多的内存。

- **定期删除** - 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期 key 。至于要删除多少过期 key ，以及要检查多少个数据库，则由算法决定。定期删除是前两种策略的一种折中方案。

## Redis 内存淘汰

### 内存淘汰要点

- **最大缓存** - Redis 允许通过 `maxmemory` 参数来设置内存最大值。

- **失效时间** - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，`EXPIRE`、`EXPIREAT`、`PEXPIRE`、`PEXPIREAT` 以及 `SETEX` 和 `PSETEX` 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。

- **淘汰策略** - 随着不断的向 Redis 中保存数据，当内存剩余空间无法满足添加的数据时，Redis 内就会施行数据淘汰策略，清除一部分内容然后保证新的数据可以保存到内存中。内存淘汰机制是为了更好的使用内存，用一定得 miss 来换取内存的利用率，保证 Redis 缓存中保存的都是热点数据。

- **非精准的 LRU** - 实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。

### 主键过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

可以使用 `EXPIRE` 或 `EXPIREAT` 来为 key 设置过期时间。

> 🔔 注意：当 `EXPIRE` 的时间如果设置的是负数，`EXPIREAT` 设置的时间戳是过期时间，将直接删除 key。

示例：

```shell
redis> SET mykey "Hello"
"OK"
redis> EXPIRE mykey 10
(integer) 1
redis> TTL mykey
(integer) 10
redis> SET mykey "Hello World"
"OK"
redis> TTL mykey
(integer) -1
redis>
```

### 淘汰策略

内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？

Redis 提供了下面几种内存淘汰策略供用户选：

- **`noeviction`** - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。
- **`allkeys-lru`** - 在主键空间中，优先移除最近未使用的 key。
- **`allkeys-random`** - 在主键空间中，随机移除某个 key。
- **`volatile-lru`** - 在设置了过期时间的键空间中，优先移除最近未使用的 key。
- **`volatile-random`** - 在设置了过期时间的键空间中，随机移除某个 key。
- **`volatile-ttl`** - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。

### 如何选择淘汰策略

- 如果**数据呈现幂等分布（存在热点数据，部分数据访问频率高，部分数据访问频率低），则使用 `allkeys-lru`**。
- 如果**数据呈现平等分布（数据访问频率大致相同），则使用 `allkeys-random`**。
- 如果希望**使用不同的 TTL 值向 Redis 提示哪些 key 更适合被淘汰，请使用 `volatile-ttl`**。
- **`volatile-lru` 和 `volatile-random` 适合既应用于缓存和又应用于持久化存储的场景**，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。
- **将 key 设置过期时间实际上会消耗更多的内存，因此建议使用 `allkeys-lru` 策略从而更有效率的使用内存**。

### 内部实现

Redis 删除失效主键的方法主要有两种：

- 消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。
- 主动方法（active way），周期性地从设置了失效时间的主键中选择一部分失效的主键删除。
- 主动删除：当前已用内存超过 `maxmemory` 限定时，触发主动清理策略，该策略由启动参数的配置决定主键具体的失效时间全部都维护在 `expires` 这个字典表中。

## 参考资料

- **官网**
  - [Redis 官网](https://redis.io/)
  - [Redis Github](https://github.com/antirez/redis)
  - [Redis 官方文档中文版](http://redis.cn/)
- **书籍**
  - [《Redis 实战》](https://item.jd.com/11791607.html)
  - [《Redis 设计与实现》](https://item.jd.com/11486101.html)
