---
icon: logos:redis
title: Redis 面试
cover: https://raw.githubusercontent.com/dunwu/images/master/snap/202309231131433.png
date: 2020-07-13 17:03:42
categories:
  - 数据库
  - KV数据库
  - redis
tags:
  - 数据库
  - KV 数据库
  - redis
  - 面试
permalink: /pages/4431bbfc/
---

# Redis 面试

## Redis 简介

### 【基础】什么是 Redis？

::: details 要点

> 什么是 Redis？

**Redis 是一个开源的、数据存于内存中的 K-V 数据库**。由于，Redis 的读写操作都是在内存中完成，因此其**读写速度非常快**。

- **高性能** - 由于，Redis 的读写操作都是在内存中完成，因此性能极高。
- **高并发** - Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。

Redis 常被用于**缓存，消息队列、分布式锁等场景**。

> Redis 有什么功能和特性？

Redis 的功能和特性：

- **Redis 支持多种数据类型**。如：String（字符串）、Hash（哈希）、 List （列表）、Set（集合）、Zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理空间）、Stream（流）。
- **Redis 的读写采用“单线程”模型**，因此，其操作天然就具有**原子性**。需要注意的是，Redis 6.0 后在其网络模块中引入了多线程 I/O 机制。
- Redis 支持两种持久化策略：RDB 和 AOF。
- Redis 有多种高可用方案：**主从复制**模式、**哨兵**模式、**集群**模式。
- Redis 支持很多丰富的特性，如：**事务** 、**Lua 脚本**、**发布订阅**、**过期删除**、**内存淘汰**等等。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202411231010326.png)

_图来自 [Redis Explained](https://architecturenotes.co/p/redis)_

:::

### 【基础】Redis 有哪些应用场景？

::: details 要点

Redis 常见应用场景如下：

- **缓存** - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。
- **计数器** - Redis 这种内存数据库能支持计数器频繁的读写操作。
- **应用限流** - 限制一个网站访问流量。
- **消息队列** - 使用 List 数据类型，它是双向链表。
- **查找表** - 使用 HASH 数据类型。
- **聚合运算** - 使用 SET 类型，例如求两个用户的共同好友。
- **排行榜** - 使用 ZSET 数据类型。
- **分布式 Session** - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。
- **分布式锁** - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。

:::

### 【基础】Redis 有哪些里程碑版本？

::: details 要点

Redis 里程碑版本如下：

- Redis 1.0（2010 年） - Redis 1.0 发布，采用单机架构，一般作为业务应用的缓存。但是 Redis 的数据是存在内存中的，重启 Redis 时，数据会全部丢失，流量直接打到数据库。
- Redis 2.8（2013 年）
  - 持久化 - Redis 引入了 RDB 内存快照来持久化数据。它还支持 AOF（仅追加文件），其中每个写入命令都写入 AOF 文件。
  - 复制 - 添加了复制功能以提高可用性。主实例处理实时读写请求，而副本同步主实例的数据。
  - 哨兵 - 引入了 Sentinel 来实时监控 Redis 实例。Sentinel 是一个旨在帮助管理 Redis 实例的系统。它执行以下四个任务：监控、通知、自动故障转移和共享配置。
- Redis 3.0（2015 年） - 官方提供了 redis-cluster。redis-cluster 是一种分布式数据库解决方案，通过分片管理数据。数据被分成 16384 个槽，每个节点负责槽的一部分。
- Redis 5.0（2017 年） - 新增 Stream 数据类型。
- Redis 6.0（2020 年） - 在网络模块中引入了多线程 I/O。Redis 模型分为网络模块和主处理模块。特别注意：Redis 不再完全是单线程架构。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202503270820508.gif)

:::

### 【基础】对比一下 Redis 和 Memcached？

::: details 要点

> - Redis 和 Memcached 有什么相同点？
> - Redis 和 Memcached 有什么差异？
> - 分布式缓存技术选型，选 Redis 还是 Memcached，为什么？

Redis 与 Memcached 的**共性**：

- 都是内存数据库，因此性能都很高。
- 都有过期策略。

因为以上两点，所以常被作为缓存使用。

Redis 与 Memcached 的**差异**：

|          | Redis                                                             | Memcached                                                                                                                                        |
| -------- | ----------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| 数据类型 | 支持多种数据类型：String、Hash、List、Set、ZSet 等                | 只支持 String 类型                                                                                                                               |
| 持久化   | 支持两种持久化策略：RDB 和 AOF                                    | 不支持持久化，一旦重启或宕机就会丢失数据                                                                                                         |
| 分布式   | 支持分布式                                                        | 本身不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点 |
| 线程模型 | 读写采用单线程+IO 多路复用。因此存储小数据时比 Memcached 性能更高 | 采用多线程+IO 多路复用。在 100k 以上的数据中，Memcached 性能要高于 Redis                                                                         |
| 其他功能 | 支持发布订阅模型、Lua 脚本、事务等功能                            | 不支持                                                                                                                                           |

通过以上分析，可以看出，Redis 在很多方面都占有优势。因此，绝大多数情况下，优先选择 Redis 作为分布式缓存。

> **扩展**：[《脚踏两只船的困惑 - Memcached 与 Redis》](https://www.imooc.com/article/23549)

:::

### 【基础】Redis 有哪些 Java 客户端？各有什么优劣？

::: details 要点

Redis 的主流 Java 客户端有三种，对比如下：

| 客户端       | 线程安全 | 自动重连 | 编程模型         | 适用场景                 |
| :----------- | :------- | :------- | :--------------- | :----------------------- |
| **Jedis**    | ❌       | ❌       | 同步             | 简单应用、快速开发       |
| **Lettuce**  | ✅       | ✅       | 同步/异步/响应式 | 高并发、Spring Boot 项目 |
| **Redisson** | ✅       | ✅       | 同步/异步        | 分布式系统、高级功能需求 |

**推荐选择**：

- **基础需求** → Jedis（简单直接）。
- **高并发/Spring 项目** → Lettuce（默认选择）。
- **分布式锁/队列等** → Redisson（功能强大）。

:::

::: details 细节

#### Jedis

**✅ 优点**

- **简单易用**：API 直观，适合快速上手。
- **广泛使用**：社区支持丰富，文档齐全。
- **性能良好**：常规操作高效。
- **功能全面**：支持字符串、哈希、列表等基础数据结构。

**❌ 缺点**

- **非线程安全**：需为每个线程创建独立实例。
- **无自动重连**：网络异常需手动处理。
- **同步阻塞**：高并发时可能成为性能瓶颈。

#### Lettuce

**✅ 优点**

- **线程安全**：多线程共享同一连接。
- **高性能**：基于 Netty 实现，支持高并发。
- **自动重连**：网络中断后自动恢复。
- **多编程模型**：支持同步、异步、响应式（如 Reactive API）。

**❌ 缺点**

- **API 较复杂**：学习成本高于 Jedis。
- **资源消耗**：异步模式可能占用更多内存/CPU。

#### Redisson

**✅ 优点**

- **分布式支持**：内置分布式锁、队列、缓存等高级功能。
- **线程安全**：天然适配多线程场景。
- **集群友好**：完善支持 Redis 集群模式。
- **稳定性高**：企业级应用验证。

**❌ 缺点**

- **学习曲线陡峭**：需掌握分布式概念。
- **依赖兼容性**：可能与其他库冲突需调优。

:::

## Redis 内存管理

### 【中级】Redis 支持哪些过期删除策略？

::: details 要点

> - Redis 支持哪些过期删除策略？
> - 常见的过期策略有哪些，Redis 的选择考量是什么？

Redis 采用的过期策略是：**定期删除+惰性删除**。

- **定时删除** - 在设置 key 的过期时间的同时，创建一个定时器，让定时器在 key 的过期时间来临时，立即执行 key 的删除操作。
  - **优点** - 保证过期 key 被尽可能快的删除，释放内存。
  - **缺点** - **如果过期 key 较多，可能会占用相当一部分的 CPU，从而影响服务器的吞吐量和响应时延**。
- **惰性删除** - 放任 key 过期不管，但是每次访问 key 时，都检查 key 是否过期，如果过期的话，就删除该 key ；如果没有过期，就返回该 key。
  - **优点** - 占用 CPU 最少。程序只会在读写键时，对当前键进行过期检查，因此不会有额外的 CPU 开销。
  - **缺点** - **过期的 key 可能因为没有被访问，而一直无法释放，造成内存的浪费，有内存泄漏的风险**。
- **定期删除** - 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期 key。至于要删除多少过期 key ，以及要检查多少个数据库，则由算法决定。定期删除是前两种策略的一种折中方案。定期删除策略的难点是删除操作执行的时长和频率。
  - 执行太频或执行时间过长，就会出现和定时删除相同的问题；
  - 执行太少或执行时间过短，就会出现和惰性删除相同的问题；

:::

### 【中级】Redis 持久化时，对过期键会如何处理？

::: details 要点

**RDB 持久化**

- **RDB 文件生成阶段** - 从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，**过期的键“不会”被保存到新的 RDB 文件中**，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。
- **RDB 加载阶段** - RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：
  - **如果 Redis 是“主服务器”运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键“不会”被载入到数据库中**。所以过期键不会对载入 RDB 文件的主服务器造成影响；
  - **如果 Redis 是“从服务器”运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中**。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。

**AOF 持久化**

- **AOF 文件写入阶段** - 当 Redis 以 AOF 模式持久化时，**如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值**。
- **AOF 重写阶段** - 执行 AOF 重写时，会对 Redis 中的键值对进行检查，**已过期的键不会被保存到重写后的 AOF 文件中**，因此不会对 AOF 重写造成任何影响。

:::

### 【中级】Redis 主从复制时，对过期键会如何处理？

::: details 要点

当 Redis 运行在主从模式下时，**从库不会进行过期扫描，从库对过期的处理是被动的**。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。

从库的过期键处理依靠主服务器控制，**主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库**，从库通过执行这条 del 指令来删除过期的 key。

:::

### 【中级】Redis 有哪些内存淘汰策略？

::: details 要点

> - Redis 内存不足时，怎么办？
> - Redis 有哪些内存淘汰策略？
> - 如何选择内存淘汰策略？

> **Redis 内存淘汰要点**

- **失效时间** - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，`EXPIRE`、`EXPIREAT`、`PEXPIRE`、`PEXPIREAT` 以及 `SETEX` 和 `PSETEX` 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。
- **最大缓存** - Redis 允许通过 `maxmemory` 参数来设置内存最大值。当内存达设定的阀值，就会触发**内存淘汰**。
- **内存淘汰** - 内存淘汰是为了更好的利用内存——清理部分缓存，以此换取内存的利用率，即尽量保证 Redis 缓存中存储的是热点数据。

> **Redis 内存淘汰策略**

- **不淘汰**
  - **`noeviction`** - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。
- **在过期键中进行淘汰**
  - **`volatile-random`** - 在设置了过期时间的键空间中，随机移除某个 key。
  - **`volatile-ttl`** - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。
  - **`volatile-lru`** - 在设置了过期时间的键空间中，优先移除最近未使用的 key。
  - **`volatile-lfu`** （Redis 4.0 新增）- 淘汰所有设置了过期时间的键值中，最少使用的键值。
- **在所有键中进行淘汰**
  - **`allkeys-random`** - 在主键空间中，随机移除某个 key。
  - **`allkeys-lru`** - 在主键空间中，优先移除最近未使用的 key。
  - **`allkeys-lfu`** (Redis 4.0 新增） - 淘汰整个键值中最少使用的键值。

> 如何选择内存淘汰策略

- 如果数据呈现正态分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 `allkeys-lru` 或 `allkeys-lfu`。
- 如果数据呈现平均分布，也就是所有的数据访问频率都相同，则使用 `allkeys-random`。
- 若 Redis 既用于缓存，也用于持久化存储时，适用 `volatile-lru` 、`volatile-lfu`、`volatile-random`。但是，这种情况下，也可以部署两个 Redis 集群来达到同样目的。
- 为 key 设置过期时间实际上会消耗更多的内存。因此，如果条件允许，建议使用 `allkeys-lru` 或 `allkeys-lfu`，从而更高效的使用内存。

:::

## Redis 持久化

### 【中级】Redis 如何保证数据不丢失？

::: details 要点

> - Redis 如何保证数据不丢失？
> - Redis 有几种持久化方式？

为了追求性能，Redis 的读写都是在内存中完成的。一旦重启，内存中的数据就会清空，为了保证数据不丢失，Redis 支持持久化机制。

Redis 有三种持久化方式

- RDB 快照
- AOF 日志
- 混合持久化

#### RDB

> - RDB 的实现原理是什么？
> - 生成 RDB 快照时，Redis 可以响应请求吗？

有两个 Redis 命令可以用于生成 RDB 文件：[**`SAVE`**](https://redis.io/commands/save) 和 [**`BGSAVE`**](https://redis.io/commands/bgsave)。

[**`SAVE`**](https://redis.io/commands/save) 命令由服务器进程直接执行保存操作，直到 RDB 创建完成为止。所以**该命令“会阻塞”服务器**，在阻塞期间，服务器不能响应任何命令请求。

[**`BGSAVE`**](https://redis.io/commands/bgsave) 命令会**“派生”**（fork）一个子进程，由子进程负责创建 RDB 文件，服务器进程继续处理命令请求，所以**该命令“不会阻塞”服务器**。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202503272238061.png)

> 🔔 **【注意】**
>
> `BGSAVE` 命令的实现采用的是写时复制技术（Copy-On-Write，缩写为 CoW）。
>
> `BGSAVE` 命令执行期间，`SAVE`、`BGSAVE`、`BGREWRITEAOF` 三个命令会被拒绝，以免与当前的 `BGSAVE` 操作产生竞态条件，降低性能。

#### AOF

> - AOF 的实现原理是什么？
> - 为什么先执行命令，再把数据写入日志呢？

**Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件**。

AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

- **命令追加** - 当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。
- **文件写入**和**文件同步**
  - Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行想 `serverCron` 这样的定时运行的函数。
  - 因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 `appendfsync` 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。

先执行命令，再把数据写入 AOF 日志有两个好处：

- **避免额外的检查开销**
- **不会阻塞当前写操作命令的执行**

当然，这样做也会有弊端：

- **数据可能会丢失：**
- **可能阻塞其他操作：**

#### 混合持久化

Redis 4.0 提出了**混合使用 AOF 日志和内存快照**，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。

**混合持久化的工作机制**

- **触发时机**：在 AOF 重写过程中启用。
- **执行流程**：
  1. **子进程**将共享内存数据以 **RDB 格式**写入 AOF 文件（全量数据）。
  2. **主线程**将操作命令记录到重写缓冲区，再以 **AOF 格式**追加到 AOF 文件（增量数据）。
  3. 替换旧 AOF 文件，新文件包含 **RDB（前半部分） + AOF（后半部分）**。

**混合持久化的优点**

- **重启速度快**：优先加载 RDB 部分（全量数据恢复快）。
- **数据丢失少**：后续加载 AOF 部分（增量数据补充）。

**混合持久化的缺点**

- **可读性差**：AOF 文件包含二进制 RDB 数据，不易阅读。
- **兼容性差**：仅支持 Redis 4.0+ 版本，旧版本无法识别。

:::

### 【中级】AOF 的回写策略有几种？

::: details 要点

**Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件**。

`appendfsync` 不同选项决定了不同的持久化行为：

- **`always`** - 将 AOF 缓冲区中所有内容写入并同步到 AOF 文件。这种方式是最数据最安全的，但也是性能最差的。
- **`no`** - 将 AOF 缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。这种方式是数据最不安全的，一旦出现故障，未来得及同步的所有数据都会丢失。
- **`everysec`** - `appendfsync` 默认选项。将 AOF 缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。这张方式是前面两种的这种方案——性能足够好，且即使出现故障，仅丢失一秒钟内的数据。

`appendfsync` 选项的不同值对 AOF 持久化功能的安全性、以及 Redis 服务器的性能有很大的影响。

:::

### 【中级】AOF 的重写机制是怎样的？

::: details 要点

- AOF 日志过大时，怎么办？
- AOF 重写流程是怎样的？
- AOF 重写时，可以处理请求吗？

**知识点**

当 AOF 日志过大时，恢复过程就会很久。为了避免此问题，Redis 提供了 AOF 重写机制，即 AOF 日志大小超过所设阈值后，启动 AOF 重写，压缩 AOF 文件。

AOF 重写机制是，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 日志中，等到全部记录完成后，就使用新的 AOF 日志替换现有的 AOF 日志。

作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 `BGREWRITEAOF` 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 `BGSAVE` 原理类似。

- 在执行 `BGREWRITEAOF` 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。
- 由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。
- 最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202503272248959.png)

:::

## Redis 高可用

### 【中级】Redis 如何实现主从复制？

::: details 要点

- Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？
- Redis 主从节点间如何复制数据？
- Redis 的数据一致性是强一致性吗？

**知识点**

（1）旧版复制基于 `SYNC` 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。

（2）新版复制基于 `PSYNC` 命令实现。同步操作分为了两块：

- **`完整重同步（full resychronization）`** 用于初次复制；
- **`部分重同步（partial resychronization）`** 用于断线后重复制。
  - 主从服务器的**复制偏移量（replication offset）**
  - 主服务器的**复制积压缓冲区（replication backlog）**
  - **服务器的运行 ID**

（3）Redis 集群主从节点复制的工作流程：

- 步骤 1. 设置主从服务器
- 步骤 2. 主从服务器建立 TCP 连接。
- 步骤 3. 发送 PING 检查通信状态。
- 步骤 4. 身份验证。
- 步骤 5. 发送端口信息。
- 步骤 6. 同步。
- 步骤 7. 命令传播。

（4）由于主从复制是**异步**的，具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。

:::

### 【中级】Redis 哨兵是如何工作的？

::: details 要点

- Redis 哨兵的功能？
- Redis 哨兵的原理？
- Redis 哨兵如何选举 Leader？
- Redis 如何实现故障转移？

**知识点**

（1）Redis 主从复制模式无法自动故障转移，也就是说，一旦主服务器宕机，需要手动恢复。为了解决此问题，Redis 增加了哨兵模式（Sentinel）。

（2）由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200131135847.png)

:::

### 【中级】Redis 集群是如何工作的？

::: details 要点

当 Redis 数据量超出单机的极限，就需要通过分区技术来分而治之。

Redis 采用的分区策略是：使用虚拟哈希槽来映射节点和数据。在 Redis Cluster 中，为整个集群分配 16384 个哈希槽。每个节点都会被分配一定的哈希槽，这个过程可以是自动分配，也可以是手动分配。任何一个槽没有被分配，那么集群处于下线状态。

当客户端向服务端发起读写请求时，先要根据 key 计算其所属的哈希槽（计算公式：CRC16(KEY) mod 16384），然后获取该哈希槽所属的节点。这样，就完成了寻址过程。

:::

### 【中级】什么是脑裂？

::: details 要点

分布式系统的脑裂问题（Split-Brain Problem）是一个严重的一致性问题，通常发生在分布式系统中的节点之间失去通信或部分通信时。这个问题的名称源自脑裂的比喻，就像一个分布式系统被分成多个部分的"脑"，每个部分独立运行，而没有协调一致的方式。

脑裂问题通常发生在以下情况下：

1. **网络分区**：当分布式系统中的网络发生问题，导致节点之间无法互相通信或只能部分通信时。这可能是由于网络故障、硬件故障、防火墙配置问题等原因引起的。
2. **节点故障**：当分布式系统的某个节点崩溃或出现故障，但其他节点无法确定该节点的状态，可能导致脑裂问题。

脑裂问题的典型情况是，在网络分区或节点故障后，分布式系统的一部分节点认为另一部分节点已经不可用，因此开始采取某种措施，比如选举新的领袖或切换到备份模式。然而，在某些情况下，网络分区可能会解除，或者节点故障可能会自行修复，导致系统中存在多个独立运行的子系统，每个子系统都认为自己是正确的。

这种情况下，脑裂问题可能导致以下问题：

1. **数据不一致性**：不同子系统可能具有不同的数据状态，这可能会导致数据不一致性和冲突。
2. **资源冲突**：如果不同的子系统尝试访问相同的资源，可能会发生资源冲突和竞争条件。
3. **性能问题**：系统中的资源可能被多次分配，从而浪费了资源并降低了性能。

为了解决脑裂问题，分布式系统通常需要采用一些机制，如投票算法、选举协议、心跳检测等，以确保在出现网络分区或节点故障时，系统能够正确地识别和处理问题，并维护一致性。这些机制可以帮助系统中的节点协同工作，避免脑裂问题的发生。然而，脑裂问题是分布式系统设计和管理中的复杂挑战之一，需要细致的规划和测试来确保系统的可靠性和稳定性。

:::

### 【高级】Redis 中的脑裂问题是如何产生的？

::: details 要点

在 Redis 主从架构中，部署方式一般是“一主多从”，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程 A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。

这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在“从节点”中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— **脑裂出现了**。

然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，**因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题**。

总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。

:::

### 【高级】如何解决 Redis 中的脑裂问题？

::: details 要点

当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。

在 Redis 的配置文件中有两个参数我们可以设置：

- `min-slaves-to-write x`，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。
- `min-slaves-max-lag x`，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。

我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。

这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。

即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，**原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了**。

**等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。**

再来举个例子。

假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。

同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。

这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。

:::

## Redis 事务

### 【中级】Redis 支持事务吗？

::: details 要点

- Redis 支持事务吗？
- Redis 事务如何工作？

**知识点**

Redis 支持事务。[`MULTI`](https://redis.io/commands/multi)、[`EXEC`](https://redis.io/commands/exec)、[`DISCARD`](https://redis.io/commands/discard) 和 [`WATCH`](https://redis.io/commands/watch) 是 Redis 事务相关的命令。

**[`MULTI`](https://redis.io/commands/multi) 命令用于开启一个事务，它总是返回 OK。**`MULTI` 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。

**[`EXEC`](https://redis.io/commands/exec) 命令负责触发并执行事务中的所有命令。**

- 如果客户端在使用 `MULTI` 开启了一个事务之后，却因为断线而没有成功执行 `EXEC` ，那么事务中的所有命令都不会被执行。
- 另一方面，如果客户端成功在开启事务之后执行 `EXEC` ，那么事务中的所有命令都会被执行。

**当执行 [`DISCARD`](https://redis.io/commands/discard) 命令时，事务会被放弃，事务队列会被清空，并且客户端会从事务状态中退出。**

**[`WATCH`](https://redis.io/commands/watch) 命令可以为 Redis 事务提供 check-and-set （CAS）行为。**被 `WATCH` 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 `EXEC` 执行之前被修改了，那么整个事务都会被取消，`EXEC` 返回 `nil-reply` 来表示事务已经失败。

`WATCH` 可以用于创建 Redis 没有内置的原子操作。

举个例子，以下代码实现了原创的 `ZPOP` 命令，它可以原子地弹出有序集合中分值（`score`）最小的元素：

```shell
WATCH zset
element = ZRANGE zset 0 0
MULTI
ZREM zset element
EXEC
```

:::

### 【中级】Redis 事务是严格意义的事务吗？

::: details 要点

Redis 事务是严格意义的事务吗？

Redis 事务为什么不支持回滚？

**知识点**

ACID 是数据库事务正确执行的四个基本要素。

- **原子性（Atomicity）**
  - 事务被视为不可分割的最小单元，事务中的所有操作**要么全部提交成功，要么全部失败回滚**。
  - 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
- **一致性（Consistency）**
  - 数据库在事务执行前后都保持一致性状态。
  - 在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- **隔离性（Isolation）**
  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- **持久性（Durability）**
  - 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  - 可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

**一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。**

![ACID](`https://raw.githubusercontent.com/dunwu/images/master/cs/database/RDB/数据库 ACID.png`)

**Redis 仅支持“非严格”的事务**。所谓“非严格”是指：

- **Redis 事务保证全部执行命令** - Redis 事务中的多个命令会被打包到事务队列中，然后按先进先出（FIFO）的顺序执行。事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。
- **Redis 事务不支持回滚** - 如果命令执行失败不会回滚，而是会继续执行下去。

Redis 官方的 [事务特性文档](https://redis.io/docs/interact/transactions/) 给出的不支持回滚的理由是：

- Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。
- 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

:::

### 【中级】Redis 中有没有替代事务的方案？

::: details 要点

Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。

一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。

不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此，**严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。**

如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。

另外，Redis 7.0 新增了 [Redis functions](https://redis.io/docs/manual/programmability/functions-intro/) 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。

:::

### 【中级】除了事务，还有其他批量执行 Redis 命令的方式吗？

::: details 要点

Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。

:::

## Redis 架构

### 【中级】Redis 为什么快？

::: details 要点

根据 [Redis 官方 Benchmark](https://redis.io/docs/management/optimization/benchmarks/) 文档的描述，Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。

![Redis 官方 Benchmark QPS 图](https://raw.githubusercontent.com/dunwu/images/master/snap/202503270821660.png)

Redis 是单线程模型（Redis 6.0 已经支持多线程模型），为什么还能有这么高的并发？

- **Redis 读写基于内存**
- **IO 多路复用** + **读写单线程模型**
  - IO 多路复用是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
  - 单线程模型避免了由于并发而产生的线程切换、锁竞争等开销。
  - 由于，Redis 读写基于内存，性能很高，所以 CPU 并不是制约 Redis 性能表现的瓶颈所在。更多情况下是受到内存大小和网络 I/O 的限制，所以 Redis 核心网络模型使用单线程并没有什么问题。
- **高效的数据结构**

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202503272229177.jpg)

图来自 [Why is redis so fast?](https://blog.bytebytego.com/p/why-is-redis-so-fast)

> **扩展**：[【视频】Why is Redis so FAST](https://www.youtube.com/shorts/x8lcdDbKZto)

:::

### 【中级】Redis 真的只有单线程吗？

::: details 要点
Redis 并非真的只有单线程。

- Redis 的主要工作包括接收客户端请求、解析请求和进行数据读写等操作，是由单线程来执行的，这也是常说 Redis 是单线程程序的原因。
- Redis 还启动了 3 个线程来执行**文件关闭**、**AOF 同步写**和**惰性删除**等操作。
- 此外，Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。

:::

### Redis 单线程模式是怎样的？

::: details 要点

Redis 单线程模式指的是其核心网络模型为单线程模式。这个模式为 IO 多路复用+单线程读写请求，其中，IO 多路复用使得 Redis 可以同时处理多个客户端连接。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202309241133046.png)

:::

### Redis 6.0 之后为什么引入了多线程？

::: details 要点

随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，**单个主线程处理网络请求的速度跟不上底层网络硬件的速度。**

为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是，对于命令的执行，Redis 仍然使用单线程来处理。

Redis 官方表示，**Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上**。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202309241148273.png)

:::

### 为什么会有慢查询命令？

::: details 要点

我们知道一个 Redis 命令的执行可以简化为以下 4 步：

1. 发送命令
2. 命令排队
3. 命令执行
4. 返回结果

Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。

Redis 为什么会有慢查询命令呢？

Redis 中的大部分命令都是 O(1) 时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：

- `KEYS *`：会返回所有符合规则的 key。
- `HGETALL`：会返回一个 Hash 中所有的键值对。
- `LRANGE`：会返回 List 中指定范围内的元素。
- `SMEMBERS`：返回 Set 中的所有元素。
- `SINTER`/`SUNION`/`SDIFF`：计算多个 Set 的交集/并集/差集。
- ……

由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过，这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 `HSCAN`、`SSCAN`、`ZSCAN` 代替。

除了这些 O(n) 时间复杂度的命令可能会导致慢查询之外，还有一些时间复杂度可能在 O(N) 以上的命令，例如：

- `ZRANGE`/`ZREVRANGE`：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量，m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
- `ZREMRANGEBYRANK`/`ZREMRANGEBYSCORE`：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量，m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
- ……

:::

### 如何找到慢查询命令？

::: details 要点

在 `redis.conf` 文件中，我们可以使用 `slowlog-log-slower-than` 参数设置耗时命令的阈值，并使用 `slowlog-max-len` 参数设置耗时命令的最大记录条数。

当 Redis 服务器检测到执行时间超过 `slowlog-log-slower-than`阈值的命令时，就会将该命令记录在慢查询日志 (slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。

⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。

`slowlog-log-slower-than`和`slowlog-max-len`的默认配置如下（可以自行修改）：

```
# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128
```

除了修改配置文件之外，你也可以直接通过 `CONFIG` 命令直接设置：

```
# 命令执行耗时超过 10000 微妙（即 10 毫秒）就会被记录
CONFIG SET slowlog-log-slower-than 10000
# 只保留最近 128 条耗时命令
CONFIG SET slowlog-max-len 128
```

获取慢查询日志的内容很简单，直接使用`SLOWLOG GET` 命令即可。

```
127.0.0.1:6379> SLOWLOG GET #慢日志查询
 1) 1) (integer) 5
   2) (integer) 1684326682
   3) (integer) 12000
   4) 1) "KEYS"
      2) "*"
   5) "172.17.0.1:61152"
   6) ""
  // ...
```

慢查询日志中的每个条目都由以下六个值组成：

1. 唯一渐进的日志标识符。
2. 处理记录命令的 Unix 时间戳。
3. 执行所需的时间量，以微秒为单位。
4. 组成命令参数的数组。
5. 客户端 IP 地址和端口。
6. 客户端名称。

`SLOWLOG GET` 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 `SLOWLOG GET N`。

下面是其他比较常用的慢查询相关的命令：

```
# 返回慢查询命令的数量
127.0.0.1:6379> SLOWLOG LEN
(integer) 128
# 清空慢查询命令
127.0.0.1:6379> SLOWLOG RESET
OK
```

:::

### 什么是 Redis 模块？有什么用？

::: details 要点

Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，值得借鉴学习！

我们每个人都可以基于 Redis 去定制化开发自己的 Module，比如实现搜索引擎功能、自定义分布式锁和分布式限流。

目前，被 Redis 官方推荐的 Module 有：

- [RediSearch](https://github.com/RediSearch/RediSearch)：用于实现搜索引擎的模块。
- [RedisJSON](https://github.com/RedisJSON/RedisJSON)：用于处理 JSON 数据的模块。
- [RedisGraph](https://github.com/RedisGraph/RedisGraph)：用于实现图形数据库的模块。
- [RedisTimeSeries](https://github.com/RedisTimeSeries/RedisTimeSeries)：用于处理时间序列数据的模块。
- [RedisBloom](https://github.com/RedisBloom/RedisBloom)：用于实现布隆过滤器的模块。
- [RedisAI](https://github.com/RedisAI/RedisAI)：用于执行深度学习/机器学习模型并管理其数据的模块。
- [RedisCell](https://github.com/brandur/redis-cell)：用于实现分布式限流的模块。

关于 Redis 模块的详细介绍，可以查看官方文档：https://redis.io/modules。

:::

## TODO

【事务】

- 【中级】Redis 支持事务吗？如何实现？
- 【中级】Redis 的 Lua 脚本功能是什么？如何使用？
- 【中级】Redis 的 Pipeline 功能是什么？
- 【中级】Redis 中原生批处理命令（MSET、MGET）与 Pipeline 的区别是什么？
- 【中级】Redis 事务与关系型数据库事务的主要区别是什么？
  【内存管理】

- 【中级】Redis 数据过期后的删除策略是什么？
- 【中级】Redis 中有哪些内存淘汰策略？
- 【中级】Redis 中的内存碎片化是什么？如何进行优化？
- 【高级】Redis 的虚拟内存（VM）机制是什么？

【高可用】

- 【中级】Redis 主从复制的实现原理是什么？
- 【中级】Redis 集群的实现原理是什么？
- 【中级】Redis 的哨兵机制是什么？
- 【中级】Redis 集群会出现脑裂问题吗？
- 【中级】Redis 主从复制的常见拓扑结构有哪些？
- 【中级】Redis 复制延迟的常见原因有哪些？
- 【中级】在 Redis 集群中，如何根据键定位到对应的节点？
- 【中级】Redis Cluster 模式与 Sentinel 模式的区别是什么？

【架构】

- 【中级】Redis 为什么这么快？
- 【中级】为什么 Redis 设计为单线程？6.0 版本为何引入多线程？
- 【中级】Redis 中的 Big Key 问题是什么？如何解决？
- 【中级】如何解决 Redis 中的热点 key 问题？
- 【中级】Redis 性能瓶颈时如何处理？
- 【高级】Redis 源码中有哪些巧妙的设计，举几个典型的例子？

【应用】

- 【中级】Redis 中如何实现分布式锁？
- 【高级】分布式锁在未完成逻辑前过期怎么办？
- 【中级】Redis 的 Red Lock 是什么？你了解吗？
- 【中级】Redis 实现分布式锁时可能遇到的问题有哪些？
- 【中级】Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？
- 【中级】Redis 中如何保证缓存与数据库的数据一致性？
- 【中级】说说 Redisson 分布式锁的原理？
- 【中级】Redisson 看门狗（watch dog）机制了解吗？
- 【中级】Redis 的订阅发布功能是什么？你了解吗？

## 参考资料

- [面试中关于 Redis 的问题看这篇就够了](https://juejin.im/post/5ad6e4066fb9a028d82c4b66)
- [advanced-java](https://github.com/doocs/advanced-java#缓存)
- [Redis 常见面试题](https://xiaolincoding.com/redis/base/redis_interview.html)