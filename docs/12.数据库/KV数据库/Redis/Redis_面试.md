---
icon: logos:redis
title: Redis 面试
cover: https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/020ab2bf4af8401590e0291a34f873f8.jpg
date: 2020-07-13 17:03:42
categories:
  - 数据库
  - KV 数据库
  - Redis
tags:
  - 数据库
  - KV 数据库
  - Redis
  - 面试
permalink: /pages/7bf27e8c/
---

# Redis 面试

::: tip 扩展

- [面试中关于 Redis 的问题看这篇就够了](https://juejin.im/post/5ad6e4066fb9a028d82c4b66)
- [advanced-java](https://github.com/doocs/advanced-java#缓存)
- [Redis 常见面试题](https://xiaolincoding.com/redis/base/redis_interview.html)

:::

## Redis 简介

### 【简单】什么是 Redis？

::: info 什么是 Redis？
:::

**Redis 是一个开源的、数据存于内存中的 K-V 数据库**。由于，Redis 的读写操作都是在内存中完成，因此其**读写速度非常快**。

- **高性能**：由于，Redis 的读写操作都是在内存中完成，因此性能极高。
- **高并发**：Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。

Redis 常被用于**缓存，消息队列、分布式锁等场景**。

::: info Redis 有什么功能和特性？
:::

Redis 的功能和特性：

- **Redis 支持多种数据类型**。如：String（字符串）、Hash（哈希）、 List （列表）、Set（集合）、Zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理空间）、Stream（流）。
- **Redis 的读写采用“单线程”模型**，因此，其操作天然就具有**原子性**。需要注意的是，Redis 6.0 后在其网络模块中引入了多线程 I/O 机制。
- Redis 支持两种**持久化策略**：**RDB** 和 **AOF**。
- Redis 有多种**高可用方案**：**主从复制**模式、**哨兵**模式、**集群**模式。
- Redis 支持很多丰富的特性，如：**事务** 、**Lua 脚本**、**发布订阅**、**过期删除**、**内存淘汰**等等。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2024/11/1a422c1e990a4499873ba2f9e73ad0a5.png)

### 【简单】Redis 有哪些应用场景？

Redis 常见应用场景如下：

- **缓存**：将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。
- **计数器**：Redis 这种内存数据库能支持计数器频繁的读写操作。
- **应用限流**：限制一个网站访问流量。
- **消息队列**：使用 List 数据类型，它是双向链表。
- **查找表**：使用 HASH 数据类型。
- **聚合运算**：使用 SET 类型，例如求两个用户的共同好友。
- **排行榜**：使用 ZSET 数据类型。
- **分布式 Session**：多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。
- **分布式锁**：除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 【简单】Redis 有哪些里程碑版本？

Redis 里程碑版本如下：

- **Redis 1.0（2010 年）**：Redis 1.0 发布，采用单机架构，一般作为业务应用的缓存。但是 Redis 的数据是存在内存中的，重启 Redis 时，数据会全部丢失，流量直接打到数据库。
- **Redis 2.8（2013 年）**
  - **持久化**：Redis 引入了 RDB 内存快照来持久化数据。它还支持 AOF（仅追加文件），其中每个写入命令都写入 AOF 文件。
  - **复制**：添加了复制功能以提高可用性。主实例处理实时读写请求，而副本同步主实例的数据。
  - **哨兵**：引入了 Sentinel 来实时监控 Redis 实例。Sentinel 是一个旨在帮助管理 Redis 实例的系统。它执行以下四个任务：监控、通知、自动故障转移和共享配置。
- **Redis 3.0（2015 年）**：官方提供了 **redis-cluster**。redis-cluster 是一种分布式数据库解决方案，通过分片管理数据。数据被分成 16384 个槽，每个节点负责槽的一部分。
- **Redis 5.0（2017 年）**：新增 **Stream** 数据类型。
- **Redis 6.0（2020 年）**：在网络模块中引入了**多线程 I/O**。Redis 模型分为网络模块和主处理模块。特别注意：Redis 不再完全是单线程架构。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/9530695aeeed4ad5b10e0058b1315755.gif)

### 【简单】对比一下 Redis 和 Memcached？

> - Redis 和 Memcached 有什么相同点？
> - Redis 和 Memcached 有什么差异？
> - 分布式缓存技术选型，选 Redis 还是 Memcached，为什么？

Redis 与 Memcached 的**共性**：

- 都是内存数据库，因此性能都很高。
- 都有过期策略。

因为以上两点，所以常被作为缓存使用。

Redis 与 Memcached 的**差异**：

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/04/ce410bcd988c434995177b86effafdb1.jpg)

核心差异对比：

|          | Memcached                                                                                                                                        | Redis                                                             |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------- |
| 数据类型 | 只支持 String 类型                                                                                                                               | 支持多种数据类型：String、Hash、List、Set、ZSet 等                |
| 持久化   | 不支持持久化，一旦重启或宕机就会丢失数据                                                                                                         | 支持两种持久化策略：RDB 和 AOF                                    |
| 分布式   | 本身不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点 | 支持分布式                                                        |
| 线程模型 | 采用多线程+IO 多路复用。在 100k 以上的数据中，Memcached 性能要高于 Redis                                                                         | 读写采用单线程+IO 多路复用。因此存储小数据时比 Memcached 性能更高 |
| 其他功能 | 不支持                                                                                                                                           | 支持发布订阅模型、Lua 脚本、事务等功能                            |

通过以上分析，可以看出，Redis 在很多方面都占有优势。因此，绝大多数情况下，优先选择 Redis 作为分布式缓存。

::: tip 扩展

[《脚踏两只船的困惑 - Memcached 与 Redis》](https://www.imooc.com/article/23549)

:::

### 【简单】Redis 有哪些 Java 客户端？各有什么优劣？

Redis 的主流 Java 客户端有三种，对比如下：

| 客户端       | 线程安全 | 自动重连 | 编程模型         | 适用场景                 |
| :----------- | :------- | :------- | :--------------- | :----------------------- |
| **Jedis**    | ❌       | ❌       | 同步             | 简单应用、快速开发       |
| **Lettuce**  | ✔️       | ✔️       | 同步/异步/响应式 | 高并发、Spring Boot 项目 |
| **Redisson** | ✔️       | ✔️       | 同步/异步        | 分布式系统、高级功能需求 |

**推荐选择**：

- **基础需求** → Jedis（简单直接）。
- **高并发/Spring 项目** → Lettuce（默认选择）。
- **分布式锁/队列等** → Redisson（功能强大）。

::: info Jedis
:::

**✔️ 优点**

- **简单易用**：API 直观，适合快速上手。
- **广泛使用**：社区支持丰富，文档齐全。
- **性能良好**：常规操作高效。
- **功能全面**：支持字符串、哈希、列表等基础数据结构。

**❌ 缺点**

- **非线程安全**：需为每个线程创建独立实例。
- **无自动重连**：网络异常需手动处理。
- **同步阻塞**：高并发时可能成为性能瓶颈。

::: info Lettuce
:::

**✔️ 优点**

- **线程安全**：多线程共享同一连接。
- **高性能**：基于 Netty 实现，支持高并发。
- **自动重连**：网络中断后自动恢复。
- **多编程模型**：支持同步、异步、响应式（如 Reactive API）。

**❌ 缺点**

- **API 较复杂**：学习成本高于 Jedis。
- **资源消耗**：异步模式可能占用更多内存/CPU。

::: info Redisson
:::

**✔️ 优点**

- **分布式支持**：内置分布式锁、队列、缓存等高级功能。
- **线程安全**：天然适配多线程场景。
- **集群友好**：完善支持 Redis 集群模式。
- **稳定性高**：企业级应用验证。

**❌ 缺点**

- **学习曲线陡峭**：需掌握分布式概念。
- **依赖兼容性**：可能与其他库冲突需调优。

## Redis 内存管理

### 【中等】Redis 支持哪些过期删除策略？⭐⭐

> - Redis 支持哪些过期删除策略？
> - 常见的过期策略有哪些，Redis 的选择考量是什么？

Redis 采用的过期策略是：**定期删除+惰性删除**。

- **定时删除**：在设置 key 的过期时间的同时，创建一个定时器，让定时器在 key 的过期时间来临时，立即执行 key 的删除操作。
  - **优点**：保证过期 key 被尽可能快的删除，释放内存。
  - **缺点**：**如果过期 key 较多，可能会占用相当一部分的 CPU，从而影响服务器的吞吐量和响应时延**。
- **惰性删除**：放任 key 过期不管，但是每次访问 key 时，都检查 key 是否过期，如果过期的话，就删除该 key ；如果没有过期，就返回该 key。
  - **优点**：占用 CPU 最少。程序只会在读写键时，对当前键进行过期检查，因此不会有额外的 CPU 开销。
  - **缺点**：**过期的 key 可能因为没有被访问，而一直无法释放，造成内存的浪费，有内存泄漏的风险**。
- **定期删除**：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期 key。至于要删除多少过期 key ，以及要检查多少个数据库，则由算法决定。定期删除是前两种策略的一种折中方案。定期删除策略的难点是删除操作执行的时长和频率。
  - 执行太频或执行时间过长，就会出现和定时删除相同的问题；
  - 执行太少或执行时间过短，就会出现和惰性删除相同的问题；

### 【中等】Redis 有哪些内存淘汰策略？⭐⭐⭐

> - Redis 内存不足时，怎么办？
> - Redis 有哪些内存淘汰策略？
> - 如何选择内存淘汰策略？

::: info Redis 内存淘汰要点
:::

- **失效时间**：作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，`EXPIRE`、`EXPIREAT`、`PEXPIRE`、`PEXPIREAT` 以及 `SETEX` 和 `PSETEX` 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。
- **最大缓存**：Redis 允许通过 `maxmemory` 参数来设置内存最大值。当内存达设定的阀值，就会触发**内存淘汰**。
- **内存淘汰**：内存淘汰是为了更好的利用内存——清理部分缓存，以此换取内存的利用率，即尽量保证 Redis 缓存中存储的是热点数据。

::: info Redis 内存淘汰策略
:::

- **不淘汰**
  - **`noeviction`**：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。
- **在过期键中进行淘汰**
  - **`volatile-random`**：在设置了过期时间的键空间中，随机移除某个 key。
  - **`volatile-ttl`**：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。
  - **`volatile-lru`**：在设置了过期时间的键空间中，优先移除最近未使用的 key。
  - **`volatile-lfu`** （Redis 4.0 新增）- 淘汰所有设置了过期时间的键值中，最少使用的键值。
- **在所有键中进行淘汰**
  - **`allkeys-random`**：在主键空间中，随机移除某个 key。
  - **`allkeys-lru`**：在主键空间中，优先移除最近未使用的 key。
  - **`allkeys-lfu`** (Redis 4.0 新增） - 淘汰整个键值中最少使用的键值。

::: info 如何选择内存淘汰策略
:::

- 如果数据呈现正态分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 `allkeys-lru` 或 `allkeys-lfu`。
- 如果数据呈现平均分布，也就是所有的数据访问频率都相同，则使用 `allkeys-random`。
- 若 Redis 既用于缓存，也用于持久化存储时，适用 `volatile-lru` 、`volatile-lfu`、`volatile-random`。但是，这种情况下，也可以部署两个 Redis 集群来达到同样目的。
- 为 key 设置过期时间实际上会消耗更多的内存。因此，如果条件允许，建议使用 `allkeys-lru` 或 `allkeys-lfu`，从而更高效的使用内存。

### 【中等】Redis 持久化时，对过期键会如何处理？

**RDB 持久化**

- **RDB 文件生成阶段**：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，**过期的键“不会”被保存到新的 RDB 文件中**，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。
- **RDB 加载阶段**：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：
  - **如果 Redis 是“主服务器”运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键“不会”被载入到数据库中**。所以过期键不会对载入 RDB 文件的主服务器造成影响；
  - **如果 Redis 是“从服务器”运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中**。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。

**AOF 持久化**

- **AOF 文件写入阶段**：当 Redis 以 AOF 模式持久化时，**如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值**。
- **AOF 重写阶段**：执行 AOF 重写时，会对 Redis 中的键值对进行检查，**已过期的键不会被保存到重写后的 AOF 文件中**，因此不会对 AOF 重写造成任何影响。

### 【中等】Redis 主从复制时，对过期键会如何处理？

当 Redis 运行在主从模式下时，**从库不会进行过期扫描，从库对过期的处理是被动的**。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。

从库的过期键处理依靠主服务器控制，**主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库**，从库通过执行这条 del 指令来删除过期的 key。

### 【中等】Redis 中的内存碎片化是什么？如何进行优化？

Redis 内存碎片化是指已分配的内存无法被有效利用，导致内存浪费的现象。

可以通过 Redis 的 `INFO memory` 命令查看：

```shell
mem_fragmentation_ratio: 1.86  # 大于 1.5 表示碎片较多
```

**内存碎片的原因**：

- **内存分配器机制**：Redis 使用 Jemalloc 或 glibc 的 malloc 等内存分配器，这些分配器为了性能不会总是精确分配请求的大小，可能分配稍大的块。
- **键值对频繁修改**：当键值对被频繁修改（特别是大小变化时），旧的内存空间可能无法重用。例如：字符串值从 128B 改为 256B，原空间不够需要新分配。
- **键过期/删除**：删除键释放的内存块可能无法与相邻空闲块合并，这些碎片空间可能无法满足新的大内存请求。
- **不同大小的数据混合存储**：Redis 存储各种大小的键值对，导致内存中出现大小不一的空闲块。

**内存碎片的影响**：

- **内存分配策略**：不同的分配器 (Jemalloc/libc 等）碎片率不同
- **工作负载模式**：频繁修改和删除操作会增加碎片
- **数据大小分布**：大小差异大的数据混合存储更容易产生碎片

**内存碎片的解决**：

- 重启 Redis（会丢失数据）
- 使用 `MEMORY PURGE` 命令（需要特定分配器支持）
- 配置合理的 maxmemory 和淘汰策略
- 对于高碎片环境，可考虑使用 Redis 4.0+ 的主动碎片整理功能

## Redis 持久化

### 【中等】Redis 支持哪些持久化方式？⭐⭐⭐

为了追求性能，Redis 的读写都是在内存中完成的。一旦重启，内存中的数据就会清空，为了保证数据不丢失，Redis 支持持久化机制。

Redis 有三种持久化方式

- RDB 快照
- AOF 日志
- 混合持久化

::: info RDB
:::

> - RDB 的实现原理是什么？
> - 生成 RDB 快照时，Redis 可以响应请求吗？

有两个 Redis 命令可以用于生成 RDB 文件：[**`SAVE`**](https://redis.io/commands/save) 和 [**`BGSAVE`**](https://redis.io/commands/bgsave)。

[**`SAVE`**](https://redis.io/commands/save) 命令由服务器进程直接执行保存操作，直到 RDB 创建完成为止。所以**该命令“会阻塞”服务器**，在阻塞期间，服务器不能响应任何命令请求。

[**`BGSAVE`**](https://redis.io/commands/bgsave) 命令会**派生**（fork）一个子进程，由子进程负责创建 RDB 文件，服务器进程继续处理命令请求，所以**该命令“不会阻塞”服务器**。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/34973284a5354682b0dfd111d68d312d.png)

> 🔔 **【注意】**
>
> `BGSAVE` 命令的实现采用的是写时复制技术（Copy-On-Write，缩写为 CoW）。
>
> `BGSAVE` 命令执行期间，`SAVE`、`BGSAVE`、`BGREWRITEAOF` 三个命令会被拒绝，以免与当前的 `BGSAVE` 操作产生竞态条件，降低性能。

::: info AOF
:::

> - AOF 的实现原理是什么？
> - 为什么先执行命令，再把数据写入日志呢？

**Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件**。

AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

- **命令追加**：当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。
- **文件写入**和**文件同步**
  - Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行想 `serverCron` 这样的定时运行的函数。
  - 因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 `appendfsync` 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。

先执行命令，再把数据写入 AOF 日志有两个好处：

- **避免额外的检查开销**
- **不会阻塞当前写操作命令的执行**

当然，这样做也会有弊端：

- **数据可能会丢失：**
- **可能阻塞其他操作：**

**Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件**。

`appendfsync` 不同选项决定了不同的持久化行为：

- **`always`**：将 AOF 缓冲区中所有内容写入并同步到 AOF 文件。这种方式是最数据最安全的，但也是性能最差的。
- **`no`**：将 AOF 缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。这种方式是数据最不安全的，一旦出现故障，未来得及同步的所有数据都会丢失。
- **`everysec`**：`appendfsync` 默认选项。将 AOF 缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。这张方式是前面两种的这种方案——性能足够好，且即使出现故障，仅丢失一秒钟内的数据。

`appendfsync` 选项的不同值对 AOF 持久化功能的安全性、以及 Redis 服务器的性能有很大的影响。

::: info 混合持久化
:::

Redis 4.0 提出了**混合使用 AOF 日志和内存快照**，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。

**混合持久化的工作机制**

- **触发时机**：在 AOF 重写过程中启用。
- **执行流程**：
  1. **子进程**将共享内存数据以 **RDB 格式**写入 AOF 文件（全量数据）。
  2. **主线程**将操作命令记录到重写缓冲区，再以 **AOF 格式**追加到 AOF 文件（增量数据）。
  3. 替换旧 AOF 文件，新文件包含 **RDB（前半部分） + AOF（后半部分）**。

**混合持久化的优点**

- **重启速度快**：优先加载 RDB 部分（全量数据恢复快）。
- **数据丢失少**：后续加载 AOF 部分（增量数据补充）。

**混合持久化的缺点**

- **可读性差**：AOF 文件包含二进制 RDB 数据，不易阅读。
- **兼容性差**：仅支持 Redis 4.0+ 版本，旧版本无法识别。

### 【中等】AOF 的重写机制是怎样的？⭐⭐⭐

- AOF 日志过大时，怎么办？
- AOF 重写流程是怎样的？
- AOF 重写时，可以处理请求吗？

**知识点**

当 AOF 日志过大时，恢复过程就会很久。为了避免此问题，Redis 提供了 AOF 重写机制，即 AOF 日志大小超过所设阈值后，启动 AOF 重写，压缩 AOF 文件。

AOF 重写机制是，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 日志中，等到全部记录完成后，就使用新的 AOF 日志替换现有的 AOF 日志。

作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 `BGREWRITEAOF` 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 `BGSAVE` 原理类似。

- 在执行 `BGREWRITEAOF` 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。
- 由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。
- 最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/ed34ce20d3224b588a0eb93e67379ffa.png)

## Redis 批处理

### 【中等】Redis 支持事务吗？⭐⭐

::: info Redis 支持事务吗？

:::

Redis 支持非严格的事务，其事务不支持回滚。[`MULTI`](https://redis.io/commands/multi)、[`EXEC`](https://redis.io/commands/exec)、[`DISCARD`](https://redis.io/commands/discard) 和 [`WATCH`](https://redis.io/commands/watch) 是 Redis 事务相关的命令。

**[`MULTI`](https://redis.io/commands/multi) 命令用于开启一个事务，它总是返回 OK。**`MULTI` 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。

**[`EXEC`](https://redis.io/commands/exec) 命令负责触发并执行事务中的所有命令。**

- 如果客户端在使用 `MULTI` 开启了一个事务之后，却因为断线而没有成功执行 `EXEC` ，那么事务中的所有命令都不会被执行。
- 另一方面，如果客户端成功在开启事务之后执行 `EXEC` ，那么事务中的所有命令都会被执行。

**当执行 [`DISCARD`](https://redis.io/commands/discard) 命令时，事务会被放弃，事务队列会被清空，并且客户端会从事务状态中退出。**

**[`WATCH`](https://redis.io/commands/watch) 命令可以为 Redis 事务提供 check-and-set （CAS）行为**。被 `WATCH` 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 `EXEC` 执行之前被修改了，那么整个事务都会被取消，`EXEC` 返回 `nil-reply` 来表示事务已经失败。

`WATCH` 可以用于创建 Redis 没有内置的原子操作。

举个例子，以下代码实现了原创的 `ZPOP` 命令，它可以原子地弹出有序集合中分值（`score`）最小的元素：

```shell
WATCH zset
element = ZRANGE zset 0 0
MULTI
ZREM zset element
EXEC
```

::: info Redis 事务是严格意义的事务吗？

:::

ACID 是数据库事务正确执行的四个基本要素。

- **原子性（Atomicity）**
  - 事务被视为不可分割的最小单元，事务中的所有操作**要么全部提交成功，要么全部失败回滚**。
  - 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
- **一致性（Consistency）**
  - 数据库在事务执行前后都保持一致性状态。
  - 在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- **隔离性（Isolation）**
  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- **持久性（Durability）**
  - 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  - 可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

**一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。**

**Redis 仅支持“非严格”的事务**。所谓“非严格”是指：

- **Redis 事务保证全部执行命令**：Redis 事务中的多个命令会被打包到事务队列中，然后按先进先出（FIFO）的顺序执行。事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。
- **Redis 事务不支持回滚**：如果命令执行失败不会回滚，而是会继续执行下去。

Redis 官方的 [事务特性文档](https://redis.io/docs/interact/transactions/) 给出的不支持回滚的理由是：

- Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。
- 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

### 【中等】Redis Pipeline 能保证原子性吗？⭐⭐

先说结论：**Redis Pipeline 不保证原子性**。

Redis Pipeline（管道）是一种**客户端技术**，用于将多个 Redis 命令批量发送到服务器，减少网络往返时间（RTT），提高吞吐量。

- **传统模式**：客户端发送一条命令 → 等待响应 → 再发送下一条（高延迟）。
- **Pipeline 模式**：客户端一次性发送多条命令 → 服务器按顺序执行 → 一次性返回所有结果（低延迟）。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/ae9bd14ebd1b495991a29f9bd3e9d7f9.jpg)

**核心特性**

| **特性**     | **说明**                                                                  |
| :----------- | :------------------------------------------------------------------------ |
| **批量发送** | 客户端打包多条命令，一次性发送，减少网络开销                              |
| **非原子性** | Pipeline 只是批量发送，不保证所有命令连续执行（可能被其他客户端命令打断） |
| **高性能**   | 相比单条命令模式，吞吐量可提升 5~10 倍                                    |
| **无回滚**   | 如果某条命令失败，不会影响其他命令的执行                                  |

**注意事项**

- **命令数量控制**：避免单次 Pipeline 发送过多命令（建议每批 ≤ 1 万条），否则可能阻塞 Redis。
- **集群模式限制**：Redis Cluster 要求 Pipeline 的所有 Key 必须在**同一个 Slot**（可用 `{hash_tag}` 确保，如 `user:{123}:name`）。
- **错误处理**：Pipeline 返回的是一个列表，需逐条检查命令是否成功。
- **与事务的区别**：Pipeline 不保证原子性。

**适用场景**

✔️ **适合**：

- 批量写入（如日志上报、缓存预热）
- 批量查询（如获取多个 Key 的值）
- 对原子性无要求的高并发场景

❌ **不适合**：

- 需要事务保证原子性的操作（改用 `MULTI/EXEC`）
- 命令之间有依赖关系（如后一条命令依赖前一条的结果）

### 【中等】Redis Lua 脚本有什么用？⭐⭐

Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。Redis 的 Lua 脚本提供了一种**原子性执行多个命令**的方式。也就是说，一段 **Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行**，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。

并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。

不过， Lua 脚本依然存在下面这些缺陷：

- **如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销**，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。
- **Redis Cluster 下 Lua 脚本的原子操作也无法保证**，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽）上。

另外，Redis 7.0 新增了 [Redis functions](https://redis.io/docs/manual/programmability/functions-intro/) 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。

## Redis 高可用

### 【中等】Redis 如何实现主从复制？⭐⭐⭐

> - Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？
> - Redis 主从节点间如何复制数据？
> - Redis 的数据一致性是强一致性吗？

Redis 的主从复制过程主要分为**建立连接、数据同步、命令传播**三个阶段。

::: info 建立连接
:::

通过 `SLAVEOF` 命令或 `slaveof` 选项，建立两个节点的主从关系。

- 从节点启动后，会向主节点发送一个 `PSYNC` 命令，请求同步数据。
- `PSYNC` 命令格式为：`PSYNC runid（运行 ID） offset（复制偏移量）`

::: info 数据同步
:::

主节点根据从节点发送的信息，决定进行**完整重同步**还是**部分重同步**。

**完整重同步（full resychronization）**

1. 从节点第一次复制主节点时，发送 `PSYNC ? -1` 给主节点
2. 主节点执行 `BGSAVE` 命令，在**后台生成一个 RDB 快照文件**。
3. 在生成 RDB 文件期间，主节点会将新的写命令记录到**复制缓冲区（Replication Buffer）** 中。
4. RDB 文件生成后，主节点将其发送给从节点。
5. 从节点**清空旧数据**，然后加载这个 RDB 文件到内存，将自身状态更新至主节点执行 `BGSAVE` 时的状态。
6. 主节点再将**复制缓冲区**中记录的写命令发送给从节点，从节点执行这些命令，最终达到与主节点一致的状态。

**部分重同步（partial resychronization）**

- **触发条件**：从节点断线重连后，如果它之前复制的主节点 `runid` 未变，并且其 `offset` 之后的数据仍然存在于主节点的**复制积压缓冲区（Replication Backlog）** 中。
- **过程**：主节点只需要将复制积压缓冲区里从 `offset` 之后的数据发送给从节点即可。

::: info 命令传播
:::

完成同步后，复制进入**命令传播阶段**。

- 主节点将自己执行的**每一条写命令**，都异步地发送给所有从节点。
- 从节点接收并执行这些命令，从而保证主从数据的**最终一致性**。

### 【中等】Redis 哨兵是如何工作的？⭐⭐⭐

> - Redis 哨兵的功能？
> - Redis 哨兵的原理？
> - Redis 哨兵如何选举 Leader？
> - Redis 如何实现故障转移？

**Redis 哨兵（Sentinel）**是一个**高可用性（High Availability）解决方案**，用于管理 Redis 主从架构。它是一个**独立的分布式进程**，通过一系列心跳检测和投票机制，**自动完成故障发现（Failure Detection）和故障转移（Failover）**，从而实现服务的无人值守不间断运行。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/8e92a611649b4b2285aaca30b3cbbd10.png)

Redis 哨兵主要有三个功能：监控、故障转移、通知

::: info 监控
:::

Redis 哨兵每十秒一次发送 `INFO`，获取所有主从服务器信息。

此外，Redis 哨兵通过心跳 `PING` 探测节点是否下线。

- **主观下线**：每秒一次，向所知的所有节点发送 `PING`；超时未响应的节点会被判定为主观下线。
- **客观下线**：**只有主节点才有客观下线**。哨兵向其他哨兵发起确认：是否认同该主节点下线。如果 quorum 数的哨兵判断主节点下线，则视为客观下线。

::: info 故障转移
:::

**主节点客观下线后，哨兵集群通过 Raft 算法选举一个哨兵 Leader，由哨兵 Leader 负责该主节点的故障转移**。

每个哨兵优先投票给最先发起投票请求的节点，得票超过半数的哨兵成为 Leader。

故障转移流程如下：

- 排除下线从节点
- 排除和哨兵、主节点断连的从节点
- 根据优先级、复制偏移量、运行 ID 排序，从中选出主节点
- 将其余从节点从属于新主节点
- 当旧主节点恢复，将其从属于新主节点

::: info 通知
:::

故障转移完成后，哨兵 Leader 会通知其余从节点认主。

此外，哨兵 Leader 向所有从服务器发送 `SLAVEOF` 命令，让它们去复制新的主服务器。

::: info 脑裂
:::

**脑裂**是指：在分布式系统中，因网络分区导致集群中同时存在多个主节点，这些主节点都可能接收写请求，造成数据不一致。

Redis 哨兵应对脑裂，有以下措施：

- **通过多数派原则判定下线（主观下线 + 客观下线）**
  - 主节点故障需多数哨兵确认（超过半数）
  - 防止因单个哨兵误判或网络抖动触发故障转移
- **通过多数派原则选举哨兵 Leader**
  - 哨兵节点数应为奇数
  - quorum 大于集群半数
- **故障转移集中式管理**
  - 故障转移由唯一领导者哨兵执行
  - 确保同一时间只有一个哨兵执行切换，避免多个哨兵同时提升不同从节点
- **旧主强制降级**
  - 故障转移后，哨兵 Leader 将旧的主服务器标记为从服务器。当旧的主服务器重新上线，Sentinel 会向它发送 `SLAVEOF` 命令，让其成为从服务器。
  - 即使旧主节点恢复，也会被降级为从节点，无法继续接收写请求
- **客户端重定向**
  - 客户端仅信任哨兵集群提供的主节点地址
  - 客户端不会同时连接两个“主节点”，自动切换到新主
- **写入保护**
  - 主节在失去所有从节点或从节点延迟过高时拒绝写入
  - 少数派分区的主节点 → 自动拒绝写入
  - 多数派分区的主节点正常服务 → 从节点提升为新主继续写入
  - 客户端写入失败，但数据一致性得到保障
  - 相关配置：min-slaves-to-write（最小从节点数）、min-slaves-max-lag（从节点复制延迟）

### 【中等】Redis 集群是如何工作的？⭐⭐⭐

**[Redis 集群（Redis Cluster）](https://redis.io/topics/cluster-tutorial) 是 Redis 官方提供的分布式方案**。

Redis Cluster 既然被设计分布式系统，自然需要具备分布式系统的基本特性：伸缩性、高可用、一致性。

- **伸缩性** - Redis Cluster 通过划分虚拟 hash 槽来进行“分区”，以实现集群的伸缩性。
- **高可用** - Redis Cluster 采用主从架构，支持“复制”和“自动故障转移”，以保证 Redis Cluster 的高可用。
- **一致性** - 根据 CAP 理论，Consistency、Availability、Partition tolerance 三者不可兼得。而 Redis Cluster 的选择是 AP，即不保证“强一致性”，尽力达到“最终一致性”。

Redis Cluster 应用了 [Raft 协议](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf) 协议和 Gossip 协议。

**Redis Cluster = 虚拟哈希槽分区（数据分布） + 主从复制（数据冗余） + Raft 式故障转移（高可用） + 多数派防脑裂（一致性）**

::: info 集群架构
:::

Redis Cluster 节点分为主节点（master）和从节点（slave）：

- 主节点用于处理槽。
- 从节点用于复制主节点。

Redis 集群中每个节点会保存集群的完整拓扑信息，包括每个节点的 ID、IP、端口、负责的哈希槽范围。

**节点间使用 Gossip 协议 (`PING` / `PONG` 消息）相互通信**。

::: info 虚拟哈希槽分区
:::

**虚拟哈希槽分区规则**

**Redis Cluster 将整个数据库规划为 “16384” 个虚拟的哈希槽**，数据库中的每个键都属于其中一个槽。**每个节点都会记录哪些槽指派给了自己， 而哪些槽又被指派给了其他节点**。

**如果数据库中有任何一个槽没有得到分配，那么集群处于“下线”状态**。

通过向节点发送 [`CLUSTER ADDSLOTS`](https://redis.io/commands/cluster-addslots) 命令，可以将一个或多个槽指派给节点负责。

```shell
> CLUSTER ADDSLOTS 1 2 3
OK
```

集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：

- 节点Ａ存储的哈希槽范围是：0 – 5500
- 节点Ｂ存储的哈希槽范围是：5501 – 11000
- 节点Ｃ存储的哈希槽范围是：11001 – 16384

**重分区**

对 Redis Cluster 的重新分片工作是由客户端（redis-trib）执行的， **重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点**。

重新分区操作可以“**在线**”进行，在重新分区的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。

重新分区的实现原理如下图所示：

![](https://raw.githubusercontent.com/dunwu/images/master/cs/database/redis/redis-cluster-trib.png)

::: info 重定向
:::

**路由（计算哈希槽）**

决定一个 key 应该分配到那个槽的算法是：**计算该 key 的 CRC16 结果再模 16834**。

```
HASH_SLOT = CRC16(KEY) mod 16384
```

**MOVED 错误重定向（永久重定向）**

当客户端向节点发送与数据库键有关的命令时，接受命令的节点会**计算出命令要处理的数据库属于哪个槽**，并**检查这个槽是否指派给了自己**：

- 如果键所在的槽正好指派给了当前节点，那么当前节点直接执行命令。
- 如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个 **`MOVED` 错误**，指引客户端重定向至正确的节点。

**ASK 错误重定向（临时重定向，迁移过程中使用）**

如果节点 A 正在迁移槽 `i` 至节点 B ， 那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时， 节点 A 会向客户端返回一个 `ASK` 错误， 指引客户端到节点 B 继续查找指定的数据库键。

`ASK` 错误与 `MOVED` 的区别在于：

- `MOVED` 错误表示槽的负责权已经从一个节点转移到了另一个节点；
- 而 `ASK` 错误只是两个节点在迁移槽的过程中使用的一种临时措施。

判断 ASK 错误的过程如下图所示：

![](https://raw.githubusercontent.com/dunwu/images/master/cs/database/redis/redis-ask.png)

::: info 故障转移
:::

**故障检测**

**集群中每个节点都会定期向集群中的其他节点发送 `PING` 消息，以此来检测对方是否在线**。

节点的状态信息可以分为：

- 在线状态；
- 疑似下线状态（`PFAIL`） - 即在规定的时间内，没有应答 `PING` 消息
- 已下线状态（`FAIL`） - 半数以上负责处理槽的主节点都将某个主节点视为“疑似下线”，则这个主节点将被标记为“已下线”

**故障转移**

1. 下线主节点的所有从节点中，会有一个从节点被选中。
2. 被选中的从节点会执行 `SLAVEOF no one` 命令，成为新的主节点。
3. 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。
4. 新的主节点向集群广播一条 `PONG` 消息，告知其他节点这个从节点已变成主节点。
5. 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。

**选主**

> Redis Sentinel 和 Redis Cluster 的选主流程非常相似，二者都基于 [Raft 协议](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf) 实现。

1. 从节点发现自己的主节点状态为 `FAIL`。
2. 从节点将自己记录的纪元（`epoch`）加 1，并广播消息，要求所有收到消息且有投票权的主节点都为自己投票。——这里的纪元（`epoch`），相当于 Raft 协议中的选期（`term`）。因个人习惯，后面统一将纪元描述为选期。
3. 如果某主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票，那么主节点就返回一条确认消息，表示支持该从节点成为新的主节点。
4. 每个参与选举的从节点都会根据收到的确认消息，统计自己所得的选票。
5. 假设集群中存在 N 个具有投票权的主节点，那么**当某从节点得到“半数以上”（`N / 2 + 1`）的选票，则该从节点当选为新的主节点**。
6. 由于每个选期中，任意具有投票权的主节点“只能投一票”，所以获得“半数以上”选票的从节点只能有一个。
7. 如果在一个选期中，没有从节点能获得“半数以上”投票，则本次选期作废，开始进入下一个选期，直到选出新的主节点为止。

::: info Redis 集群功能限制
:::

Redis Cluster 相对 **单机**，存在一些功能限制，需要 **开发人员** 提前了解，在使用时做好规避。

- `key` **批量操作** 支持有限：类似 `mset`、`mget` 操作，目前只支持对具有相同 `slot` 值的 `key` 执行 **批量操作**。对于 **映射为不同** `slot` 值的 `key` 由于执行 `mget`、`mget` 等操作可能存在于多个节点上，因此不被支持。
- `key` **事务操作** 支持有限：只支持 **多** `key` 在 **同一节点上** 的 **事务操作**，当多个 `key` 分布在 **不同** 的节点上时 **无法** 使用事务功能。
- `key` 作为 **数据分区** 的最小粒度，不能将一个 **大的键值** 对象如 `hash`、`list` 等映射到 **不同的节点**。
- 不支持 **多数据库空间**：**单机** 下的 Redis 可以支持 `16` 个数据库（`db0 ~ db15`），**集群模式** 下只能使用 **一个** 数据库空间，即 `db0`。
- **复制结构** 只支持一层：**从节点** 只能复制 **主节点**，不支持 **嵌套树状复制** 结构。

::: info Redis 集群规模限制
:::

**Redis Cluster 非常适合构建中小规模 Redis 集群**，这里的中小规模指的是，大概几个到几十个节点这样规模的 Redis 集群。

但是 Redis Cluster 不太适合构建超大规模集群，主要原因是，它采用了去中心化的设计。

Redis 的每个节点上，都保存了所有槽和节点的映射关系表，客户端可以访问任意一个节点，再通过重定向命令，找到数据所在的那个节点。那么，这个映射关系表是如何更新的呢？Redis Cluster 采用了一种去中心化的流言 (Gossip) 协议来传播集群配置的变化。

Gossip 协议的优点是去中心化；缺点是传播速度慢，并且是集群规模越大，传播的越慢。

- 适合中小规模集群（几个到几十个节点）
- Gossip 协议在大规模集群中传播效率低

### 【困难】Redis 中的脑裂问题是如何产生的？⭐⭐

Redis 脑裂问题是指因网络分区导致集群中同时存在两个主节点，网络恢复后旧主节点降级为从节点并进行全量数据同步，造成客户端在此期间写入旧主的数据丢失。

**产生过程：**

1. 主节点与从节点网络中断，但与客户端连接正常
2. 客户端继续向旧主节点写入数据（无法同步到从节点）
3. 哨兵/集群模式下，选举出新主节点，形成双主局面
4. 网络恢复后，旧主节点被降级为从节点
5. 旧主节点清空数据与新主进行全量同步，导致期间写入的数据丢失

**核心原因：**

- 网络分区导致集群分裂
- 异步复制机制的数据延迟
- 故障切换期间客户端仍可向旧主写入数据
- 数据同步机制中从节点会清空旧数据

**解决方案**：通过合理配置（如 min-replicas-to-write 等参数）限制主节点在连接足够多从节点时才可写入，防止脑裂期间数据不一致。

### 【困难】如何解决 Redis 中的脑裂问题？⭐⭐

Redis 解决脑裂的思路： 通过配置限制主节点的写操作条件，防止在网络分区期间客户端向即将失效的旧主节点写入数据，从而避免数据丢失。

**Redis 避免脑裂机制**

- `min-replicas-to-write`：主节点在至少有指定数量的从节点确认写操作的情况下才执行写操作。通常，这个值设为集群的半数以上。
- `min-replicas-max-lag`：主从复制延迟（单位为秒），如果从节点的延迟超过配置值，不会被计入 `min-replicas-to-write` 统计。

**Redis 能完全避免脑裂吗？**

并不能。假设在极限条件下，某主节点发生临时故障，哨兵判断其下线，开始发起选举。选举进行中，主节点恢复，此时它还有半数以上的从节点，仍能持续写入。当哨兵选举完毕，并选出新的主节点，旧主节点需要被强制认主新主节点，其在选举过程中写入的数据会被覆盖，导致了数据不一致。

## Redis 架构

### 【中等】Redis 为什么快？⭐⭐

根据 [Redis 官方 Benchmark](https://redis.io/docs/management/optimization/benchmarks/) 文档的描述，Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。

![Redis 官方 Benchmark QPS 图](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/9df116a7b7e24f62b814c9aedf8b6e5e.png)

Redis 是单线程模型（Redis 6.0 已经支持多线程模型），为什么还能有这么高的并发？

- **Redis 读写基于内存**
- **IO 多路复用** + **读写单线程模型**
  - IO 多路复用是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
  - 单线程模型避免了由于并发而产生的线程切换、锁竞争等开销。
  - 由于，Redis 读写基于内存，性能很高，所以 CPU 并不是制约 Redis 性能表现的瓶颈所在。更多情况下是受到内存大小和网络 I/O 的限制，所以 Redis 核心网络模型使用单线程并没有什么问题。
- **高效的数据结构**

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/9cc33933a1e8445e997c871509c25251.jpg)

图来自 [Why is redis so fast?](https://blog.bytebytego.com/p/why-is-redis-so-fast)

> **扩展**：[【视频】Why is Redis so FAST](https://www.youtube.com/shorts/x8lcdDbKZto)

### 【中等】Redis 单线程模式是怎样的？⭐⭐

Redis 单线程模式指的是其核心网络模型为单线程模式。这个模式为 IO 多路复用+单线程读写请求，其中，IO 多路复用使得 Redis 可以同时处理多个客户端连接。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2023/09/793365f183bd427d9fd1695f189ee80f.png)

> Redis 真的只有单线程吗？

Redis 并非真的只有单线。

- Redis 的主要工作包括接收客户端请求、解析请求和进行数据读写等操作，是由单线程来执行的，这也是常说 Redis 是单线程程序的原因。
- Redis 还启动了 3 个线程来执行**文件关闭**、**AOF 同步写**和**惰性删除**等操作。
- 此外，Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。

### 【中等】Redis 6.0 之后为什么引入了多线程？

随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，**单个主线程处理网络请求的速度跟不上底层网络硬件的速度。**

为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是，对于命令的执行，Redis 仍然使用单线程来处理。

Redis 官方表示，**Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上**。

![](https://raw.githubusercontent.com/dunwu/images/master/archive/2023/09/e06ceb9d55034251ad2b584c24f23417.png)

### 【中等】什么是 Redis 模块？有什么用？

Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，值得借鉴学习！

我们每个人都可以基于 Redis 去定制化开发自己的 Module，比如实现搜索引擎功能、自定义分布式锁和分布式限流。

目前，被 Redis 官方推荐的 Module 有：

- [RediSearch](https://github.com/RediSearch/RediSearch)：用于实现搜索引擎的模块。
- [RedisJSON](https://github.com/RedisJSON/RedisJSON)：用于处理 JSON 数据的模块。
- [RedisGraph](https://github.com/RedisGraph/RedisGraph)：用于实现图形数据库的模块。
- [RedisTimeSeries](https://github.com/RedisTimeSeries/RedisTimeSeries)：用于处理时间序列数据的模块。
- [RedisBloom](https://github.com/RedisBloom/RedisBloom)：用于实现布隆过滤器的模块。
- [RedisAI](https://github.com/RedisAI/RedisAI)：用于执行深度学习/机器学习模型并管理其数据的模块。
- [RedisCell](https://github.com/brandur/redis-cell)：用于实现分布式限流的模块。

关于 Redis 模块的详细介绍，可以查看官方文档：https://redis.io/modules。

### 【困难】Redis 有哪些巧妙的设计？⭐⭐

Redis 的巧妙设计体现在：

- **单线程 + 非阻塞 I/O** → 高吞吐、低延迟。
- **精细优化的数据结构** → 节省内存，提升访问速度。
- **异步化处理**（持久化、删除、复制）→ 减少主线程阻塞。
- **扩展性设计**（模块化、集群）→ 适应不同场景需求。

Redis 作为高性能的内存数据库，有许多巧妙的设计理念和实现细节，使其在性能、简洁性和功能性之间取得平衡。以下是 Redis 的一些巧妙设计：

::: info 单线程模型（核心命令处理）
:::

Redis 采用**单线程处理命令**（6.0+ 后支持多线程 I/O，但核心逻辑仍单线程），避免了锁竞争和上下文切换的开销，同时利用以下优化：

- **非阻塞 I/O**：基于 `epoll/kqueue` 实现高效事件驱动模型。
- **纯内存操作**：绝大多数操作在内存中完成，单线程即可高效处理。
- **原子性保证**：单线程天然支持原子操作，简化了事务、Lua 脚本等实现。

**巧妙点**：牺牲多线程并行性换取无锁设计的简单性和高性能。

::: info 高效数据结构实现
:::

Redis 的核心数据结构经过高度优化：

- **SDS (Simple Dynamic String)**：
  - 预分配内存、惰性释放，减少内存重分配。
  - 二进制安全（可存储任意数据，不像 C 字符串以 `\0` 结尾）。
- **压缩列表 (ziplist)**：
  - 对小数据（如短列表、小哈希）使用紧凑存储，节省内存。
- **快速列表 (quicklist)**：
  - 结合 `ziplist` 和双向链表，优化 `List` 的内存和访问效率。
- **跳跃表 (skiplist)**：
  - 实现 `ZSET`，支持 `O(logN)` 范围查询和高效插入。
- **渐进式 Rehash**：
  - `Hash` 扩容时不阻塞服务，分批次迁移数据。

**巧妙点**：针对不同场景选择最优底层结构，平衡内存和速度。

::: info 异步持久化
:::

Redis 提供两种持久化方式：

- **RDB （快照）**：
  - `fork()` 子进程生成快照，主进程继续服务。
  - 使用 `Copy-On-Write (COW)` 机制减少内存开销。
- **AOF （日志追加）**：
  - 先执行命令再记录日志，避免日志错误影响数据。
  - 支持 `AOF Rewrite` 压缩日志（类似 RDB 的快照逻辑）。

**巧妙点**：通过 `fork()` + `COW` 实现后台持久化，避免阻塞主线程。

::: info 多路复用+零拷贝
:::

- **I/O 多路复用**：
  - 使用 `epoll/kqueue` 监听大量连接，避免线程/进程切换。
- **零拷贝优化**：
  - 网络发送数据时，直接引用内存缓冲区，减少拷贝（如 `sendfile`）。

**巧妙点**：最大化利用系统调用，减少 CPU 和内存开销。

::: info 惰性删除 (Lazy Free)
:::

- **DEL 命令不立即释放内存**，而是异步回收（避免大 Key 删除卡住主线程）。
- 适用于 `UNLINK`、`FLUSHDB ASYNC` 等场景。

**巧妙点**：用空间换时间，避免同步删除导致服务延迟。

::: info 过期键的混合淘汰策略
:::

- **定期删除**：随机抽查部分 Key，清理已过期的。
- **惰性删除**：访问 Key 时检查是否过期，再决定删除。

**巧妙点**：平衡 CPU 和内存，避免全局扫描影响性能。

::: info 模块化设计 (Redis Modules)
:::

- 支持动态加载模块（如 `RedisSearch`、`RedisGraph`），扩展功能而不改核心代码。

**巧妙点**：保持核心精简，通过插件机制扩展能力。

::: info 集群分片的无中心化设计
:::

- **Gossip 协议**：节点间自动发现和状态同步。
- **哈希槽 (Hash Slot)**：数据分片到 16384 个槽，而非一致性哈希，简化迁移。

**巧妙点**：去中心化设计，避免单点瓶颈，支持动态扩缩容。

## Redis 优化

### 【中等】为什么会有慢查询命令？

一个 Redis 命令的执行可以简化为以下 4 步：

1. 发送命令
2. 命令排队
3. 命令执行
4. 返回结果

Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。

Redis 为什么会有慢查询命令呢？

Redis 中的大部分命令都是 O(1) 时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：

- `KEYS *`：会返回所有符合规则的 key。
- `HGETALL`：会返回一个 Hash 中所有的键值对。
- `LRANGE`：会返回 List 中指定范围内的元素。
- `SMEMBERS`：返回 Set 中的所有元素。
- `SINTER`/`SUNION`/`SDIFF`：计算多个 Set 的交集/并集/差集。
- ……

由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过，这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 `HSCAN`、`SSCAN`、`ZSCAN` 代替。

除了这些 O(n) 时间复杂度的命令可能会导致慢查询之外，还有一些时间复杂度可能在 O(N) 以上的命令，例如：

- `ZRANGE`/`ZREVRANGE`：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量，m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
- `ZREMRANGEBYRANK`/`ZREMRANGEBYSCORE`：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量，m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
- ……

### 【中等】如何找到慢查询命令？

在 `redis.conf` 文件中，我们可以使用 `slowlog-log-slower-than` 参数设置耗时命令的阈值，并使用 `slowlog-max-len` 参数设置耗时命令的最大记录条数。

当 Redis 服务器检测到执行时间超过 `slowlog-log-slower-than`阈值的命令时，就会将该命令记录在慢查询日志 (slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。

⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。

`slowlog-log-slower-than`和`slowlog-max-len`的默认配置如下（可以自行修改）：

```shell
# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128
```

除了修改配置文件之外，你也可以直接通过 `CONFIG` 命令直接设置：

```shell
# 命令执行耗时超过 10000 微妙（即 10 毫秒）就会被记录
CONFIG SET slowlog-log-slower-than 10000
# 只保留最近 128 条耗时命令
CONFIG SET slowlog-max-len 128
```

获取慢查询日志的内容很简单，直接使用`SLOWLOG GET` 命令即可。

```shell
127.0.0.1:6379> SLOWLOG GET #慢日志查询
 1) 1) (integer) 5
   2) (integer) 1684326682
   3) (integer) 12000
   4) 1) "KEYS"
      2) "*"
   5) "172.17.0.1:61152"
   6) ""
  // ...
```

慢查询日志中的每个条目都由以下六个值组成：

1. 唯一渐进的日志标识符。
2. 处理记录命令的 Unix 时间戳。
3. 执行所需的时间量，以微秒为单位。
4. 组成命令参数的数组。
5. 客户端 IP 地址和端口。
6. 客户端名称。

`SLOWLOG GET` 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 `SLOWLOG GET N`。

下面是其他比较常用的慢查询相关的命令：

```shell
# 返回慢查询命令的数量
127.0.0.1:6379> SLOWLOG LEN
(integer) 128
# 清空慢查询命令
127.0.0.1:6379> SLOWLOG RESET
OK
```

### 【中等】Redis 中的 Big Key 问题是什么？如何解决？

::: info 什么是 Redis Big Key？
:::

Big Key 并不是指 key 的值很大，而是 key 对应的 value 很大。

一般而言，下面这两种情况被称为 Big Key：

- String 类型的值大于 10 KB；
- Hash、List、Set、ZSet 类型的元素的个数超过 5000 个，或总大小超过 10MB

::: info Big Key 会造成什么问题？
:::

Big Key 会带来以下四种影响：

- **内存分布不均**：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有 Big Key 的 Redis 节点占用内存多，QPS 也会比较大。
- **命令阻塞**：Redis 单线程模型，操作大 Key 耗时，阻塞其他命令。
- **网络传输压力**：每次获取 Big Key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。
- **客户端超时**：由于 Redis 执行命令是单线程处理，然后在操作 Big Key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。

::: info Big Key 解决方案
:::

**（1）开发优化**

- **数据压缩**：存储前压缩 Value（如 Gzip、Snappy）。
- **拆分大对象**：将单个大 Key 拆分为多个小 Key（如 `user:1000:info` → `user:1000:basic` + `user:1000:details`）。
- **优化数据结构**：
  - 避免巨型 String，改用 Hash、List 等分片存储。
  - 使用 `ziplist`、`quicklist` 等紧凑结构。

**（2）业务调整**

- **精简存储数据**：仅保留高频访问字段（如不存用户全部信息，只存 ID + 核心字段）。
- **逻辑优化**：避免业务层生成大 Key（如限制缓存数据大小、分页查询）。

**（3）数据分布优化**

- **集群分片**：通过 Redis Cluster 分散大 Key 到不同节点。
- **本地缓存**：对冷数据使用本地缓存（如 Caffeine），减少 Redis 压力。

**关键点**

- **预防优于治理**：在设计和开发阶段规避大 Key。
- **监控与巡检**：通过 `redis-cli --bigkeys` 或自定义脚本定期检测大 Key。

::: info 如何查找 Redis Big Key？
:::

**（1）使用 `redis-cli --bigkeys`**

**命令**：

```bash
redis-cli -h 127.0.0.1 -p 6379 -a "password" --bigkeys
```

**注意事项**：

- **推荐在从节点执行**（主节点执行可能阻塞业务）
- **低峰期执行** 或 **加 `-i` 参数控制扫描间隔**（如 `-i 0.1` 表示每 100ms 扫描一次）

**缺点**：

- 只能返回**每种数据类型最大的 1 个 Key**（无法获取 Top N）
- 对集合类型**只统计元素个数**，而非实际内存占用

**（2）使用 `SCAN` + 内存分析命令**

**遍历所有 Key**（避免 `KEYS *` 阻塞 Redis）：

```bash
redis-cli --scan --pattern "*" | while read key; do ...; done
```

**分析 Key 大小**：

- **String**：`STRLEN $key`（字节数）
- **集合类型**（List/Hash/Set/ZSet）：
  - **方法 1**：`LLEN`/`HLEN`/`SCARD`/`ZCARD`（元素个数 × 预估元素大小）
  - **方法 2**（Redis 4.0+）：`MEMORY USAGE $key`（精确内存占用）

**优点**：

- 可自定义筛选条件（如大小 Top 10）
- 精确计算内存占用

**（3）使用 `RdbTools` 分析 RDB 文件**

**命令**：

```bash
rdb dump.rdb -c memory --bytes 10240 -f redis.csv  # 导出 >10KB 的 Key 到 CSV
```

**适用场景**：

- 离线分析，不影响线上 Redis
- 精准统计**所有 Key 的内存分布**

**缺点**：需要 Redis 生成 RDB 快照

**总结：3 种方法对比**

| 方法            | 适用场景         | 优点       | 缺点          |
| --------------- | ---------------- | ---------- | ------------- |
| **`--bigkeys`** | 快速找出最大 Key | 简单易用   | 结果不全面    |
| **`SCAN`+命令** | 精确分析内存     | 可定制化   | 需脚本支持    |
| **`RdbTools`**  | 离线全面分析     | 精准无遗漏 | 依赖 RDB 文件 |

**推荐组合**：

- 日常监控用 `--bigkeys`（低峰期执行）
- 深度分析用 `RdbTools`（定期检查 RDB）
- 排查问题时用 `SCAN`+`MEMORY USAGE`（实时精准定位）

### 【中等】如何解决 Redis 中的热点 key 问题？

解决 Redis 中的热点 key 问题的方法：

- **热点 Key 拆分**
  - **垂直分片**：`user:123` → `user:123:base` + `user:123:detail`
  - **水平分片**：`product:views` → `product:views:shard1`/`shard2`
- **多级缓存**：CDN → 本地缓存（Caffeine/Guava） → Redis → DB

- **读写分离**：读请求分流到从节点（配置 `replica-read-only yes`）

- **流量控制**：

  - **Sentinel / Hystrix 等流控中间件**
  - **Redis + Lua 限流**

  ```lua
  -- 示例：每秒限 100 次访问
  local count = redis.call('INCR', KEYS[1])
  if count == 1 then redis.call('EXPIRE', KEYS[1], 1) end
  return count <= 100
  ```

- **数据预热**：定时任务提前加载热点数据到缓存

- **负载均衡**：

  - **Redis Cluster**：分散热点 Key 到不同节点
  - **代理层**：Twemproxy / Redis Proxy / Nginx 实现负载均衡