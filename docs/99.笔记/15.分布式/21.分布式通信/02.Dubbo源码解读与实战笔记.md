---
title: 《Dubbo 源码解读与实战》笔记
categories: 
  - 笔记
  - 分布式
  - 分布式通信
tags: 
  - 分布式
  - 分布式通信
  - RPC
  - Dubbo
date: 2023-06-25 19:24:38
permalink: /pages/10b5b8/
---

# 《Dubbo 源码解读与实战》笔记

## 开篇词 深入掌握 Dubbo 原理与实现，提升你的职场竞争力

[Apache Dubbo](http://dubbo.apache.org/zh-cn/)是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：

- 面向接口的远程方法调用；
- 可靠、智能的容错和负载均衡；
- 服务自动注册和发现能力。

**Dubbo 是一个分布式服务框架，致力于提供高性能、透明化的 RPC 远程服务调用方案以及服务治理方案，以帮助我们解决微服务架构落地时的问题。**

## Dubbo 源码环境搭建：千里之行，始于足下

### Dubbo 核心组件

![](https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javaweb/distributed/rpc/dubbo/dubbo基本架构.png)

Registry - **注册中心**。负责服务地址的注册与查找，服务的 Provider 和 Consumer 只在启动时与注册中心交互。注册中心通过长连接感知 Provider 的存在，在 Provider 出现宕机的时候，注册中心会立即推送相关事件通知 Consumer。

Provider - **服务提供者**。在它启动的时候，会向 Registry 进行注册操作，将自己服务的地址和相关配置信息封装成 URL 添加到 ZooKeeper 中。

Consumer - **服务消费者**。在它启动的时候，会向 Registry 进行订阅操作。订阅操作会从 ZooKeeper 中获取 Provider 注册的 URL，并在 ZooKeeper 中添加相应的监听器。获取到 Provider URL 之后，Consumer 会根据负载均衡算法从多个 Provider 中选择一个 Provider 并与其建立连接，最后发起对 Provider 的 RPC 调用。 如果 Provider URL 发生变更，Consumer 将会通过之前订阅过程中在注册中心添加的监听器，获取到最新的 Provider URL 信息，进行相应的调整，比如断开与宕机 Provider 的连接，并与新的 Provider 建立连接。Consumer 与 Provider 建立的是长连接，且 Consumer 会缓存 Provider 信息，所以一旦连接建立，即使注册中心宕机，也不会影响已运行的 Provider 和 Consumer。

Monitor - **监控中心**。用于统计服务的调用次数和调用时间。Provider 和 Consumer 在运行过程中，会在内存中统计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。监控中心在上面的架构图中并不是必要角色，监控中心宕机不会影响 Provider、Consumer 以及 Registry 的功能，只会丢失监控数据而已。

Container - 服务运行容器。

### Dubbo 核心模块

- **dubbo-common 模块：** Dubbo 的一个公共模块，其中有很多工具类以及公共逻辑，如 Dubbo SPI 实现、时间轮实现、动态编译器等。
- **dubbo-remoting 模块：** Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通信。在 dubbo-remoting-api 子模块中定义该模块的抽象概念，在其他子模块中依赖其他开源组件进行实现，例如，dubbo-remoting-netty4 子模块依赖 Netty 4 实现远程通信，dubbo-remoting-zookeeper 通过 Apache Curator 实现与 ZooKeeper 集群的交互。
- **dubbo-rpc 模块：** Dubbo 中对远程调用协议进行抽象的模块，其中抽象了各种协议，依赖于 dubbo-remoting 模块的远程调用功能。dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具体协议的实现，例如，dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubbo-remoting-netty4 等 dubbo-remoting 子模块。 dubbo-rpc 模块的实现中只包含一对一的调用，不关心集群的相关内容。
- **dubbo-cluster 模块：** Dubbo 中负责管理集群的模块，提供了负载均衡、容错、路由等一系列集群相关的功能，最终的目的是将多个 Provider 伪装为一个 Provider，这样 Consumer 就可以像调用一个 Provider 那样调用 Provider 集群了。
- **dubbo-registry 模块：** Dubbo 中负责与多种开源注册中心进行交互的模块，提供注册中心的能力。其中， dubbo-registry-api 子模块是顶层抽象，其他子模块是针对具体开源注册中心组件的具体实现，例如，dubbo-registry-zookeeper 子模块是 Dubbo 接入 ZooKeeper 的具体实现。
- **dubbo-monitor 模块：** Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调用链跟踪的服务。
- **dubbo-config 模块：** Dubbo 对外暴露的配置都是由该模块进行解析的。例如，dubbo-config-api 子模块负责处理 API 方式使用时的相关配置，dubbo-config-spring 子模块负责处理与 Spring 集成使用时的相关配置方式。有了 dubbo-config 模块，用户只需要了解 Dubbo 配置的规则即可，无须了解 Dubbo 内部的细节。
- **dubbo-metadata 模块：** Dubbo 的元数据模块。dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实现。
- **dubbo-configcenter 模块：** Dubbo 的动态配置模块，主要负责外部化配置以及服务治理规则的存储与通知，提供了多个子模块用来接入多种开源的服务发现组件。

## Dubbo 的配置总线：抓住 URL，就理解了半个 Dubbo

Dubbo 中任意的一个实现都可以抽象为一个 URL，Dubbo 使用 URL 来统一描述了所有对象和配置信息，并贯穿在整个 Dubbo 框架之中。Dubbo URL 格式如下：

```
protocol://username:password@host:port/path?key=value&key=value
```

- **protocol**：URL 的协议。我们常见的就是 HTTP 协议和 HTTPS 协议，当然，还有其他协议，如 FTP 协议、SMTP 协议等。
- **username/password**：用户名/密码。 HTTP Basic Authentication 中多会使用在 URL 的协议之后直接携带用户名和密码的方式。
- **host/port**：主机/端口。在实践中一般会使用域名，而不是使用具体的 host 和 port。
- **path**：请求的路径。
- **parameters**：参数键值对。一般在 GET 请求中会将参数放到 URL 中，POST 请求会将参数放到请求体中。

Dubbo 中和 URL 相关的核心类：

- **URL** - 定义了 URL 的结构；
- **URLBuilder，** 辅助构造 URL；
- **URLStrParser，** 将字符串解析成 URL 对象。

### Dubbo 中的 URL 示例

URL 在 SPI 中的应用：RegistryFactory.getRegistry() 方法。

URL 在服务暴露中的应用：ZookeeperRegistry.doRegister() 方法。

URL 在服务订阅中的应用：Registry.doSubscribe() 方法

## Dubbo SPI 精析，接口实现两极反转（上）

Dubbo 通过 SPI 机制来实现微内核架构，以达到 OCP 原则（即“对扩展开放，对修改封闭”的原则）。

JDK SPI 要点：

- 在 Classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件
- 此文件记录了该 jar 包提供的服务接口的具体实现类

JDK SPI 源码分析

ServiceLoader.load() 方法，首先会尝试获取当前使用的 ClassLoader；查找失败后使用 SystemClassLoader；然后调用 reload() 方法。

在 reload() 方法中，首先会清理 providers 缓存（LinkedHashMap 类型的集合），该缓存用来记录 ServiceLoader 创建的实现对象，其中 Key 为实现类的完整类名，Value 为实现类的对象。之后创建 LazyIterator 迭代器，用于读取 SPI 配置文件并实例化实现类对象。

## Dubbo SPI 精析，接口实现两极反转（下）

Dubbo 按照 SPI 配置文件的用途，将其分成了三类目录。

- META-INF/services/ 目录：该目录下的 SPI 配置文件用来兼容 JDK SPI 。
- META-INF/dubbo/ 目录：该目录用于存放用户自定义 SPI 配置文件。
- META-INF/dubbo/internal/ 目录：该目录用于存放 Dubbo 内部使用的 SPI 配置文件。

Dubbo 将 SPI 配置文件改成了 **KV 格式**，例如：

```ini
dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
```

### SPI 核心实现

@SPI 注解

## 海量定时任务，一个时间轮搞定

## ZooKeeper 与 Curator，求你别用 ZkClient 了（上）

## ZooKeeper 与 Curator，求你别用 ZkClient 了（下）

## 代理模式与常见实现

## Netty 入门，用它做网络编程都说好（上）

## Netty 入门，用它做网络编程都说好（下）

## 简易版 RPC 框架实现（上）

## 简易版 RPC 框架实现（下）

## 本地缓存：降低 ZooKeeper 压力的一个常用手段

## 重试机制是网络操作的基本保证

## ZooKeeper 注册中心实现，官方推荐注册中心实践

## Dubbo Serialize 层：多种序列化算法，总有一款适合你

## Dubbo Remoting 层核心接口分析：这居然是一套兼容所有 NIO 框架的设计？

## Buffer 缓冲区：我们不生产数据，我们只是数据的搬运工

## Transporter 层核心实现：编解码与线程模型一文打尽（上）

## Transporter 层核心实现：编解码与线程模型一文打尽（下）

## Exchange 层剖析：彻底搞懂 Request-Response 模型（上）

## Exchange 层剖析：彻底搞懂 Request-Response 模型（下）

## 核心接口介绍，RPC 层骨架梳理

## 从 Protocol 起手，看服务暴露和服务引用的全流程（上）

## 从 Protocol 起手，看服务暴露和服务引用的全流程（下）

## 加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（上）

## 加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（下）

## 复杂问题简单化，代理帮你隐藏了多少底层细节？

## 加餐：HTTP 协议 + JSON-RPC，Dubbo 跨语言就是如此简单

## Filter 接口，扩展 Dubbo 框架的常用手段指北

## 加餐：深潜 Directory 实现，探秘服务目录玄机

## 路由机制：请求到底怎么走，它说了算（上）

## 路由机制：请求到底怎么走，它说了算（下）

## 加餐：初探 Dubbo 动态配置的那些事儿

## 负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）

## 负载均衡：公平公正物尽其用的负载均衡策略，这里都有（下）

## 集群容错：一个好汉三个帮（上）

## 集群容错：一个好汉三个帮（下）

## 加餐：多个返回值不用怕，Merger 合并器来帮忙

## 加餐：模拟远程调用，Mock 机制帮你搞定

## 加餐：一键通关服务发布全流程

## 加餐：服务引用流程全解析

## 服务自省设计方案：新版本新方案

## 元数据方案深度剖析，如何避免注册中心数据量膨胀？

## 加餐：深入服务自省方案中的服务发布订阅（上）

## 加餐：深入服务自省方案中的服务发布订阅（下）

## 配置中心设计与实现：集中化配置 and 本地化配置，我都要（上）

## 配置中心设计与实现：集中化配置 and 本地化配置，我都要（下）

## 结束语 认真学习，缩小差距

## 参考资料

- [《Dubbo 源码解读与实战》](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393)
