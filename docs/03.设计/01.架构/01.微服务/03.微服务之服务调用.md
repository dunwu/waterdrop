---
title: 微服务之服务调用
date: 2023-05-15 19:08:50
categories:
  - 设计
  - 架构
  - 微服务
tags:
  - 设计
  - 架构
  - 微服务
  - 分布式
  - RPC
permalink: /pages/c1c7b2/
---

# 微服务之服务调用

通过注册中心，服务消费者和服务提供者就可以感知彼此。但是，要实现交互还必须解决通信问题。

在单体应用中，一次服务调用发生在同一台机器上的同一个进程内部，因此也被称为本地方法调用。在微服务应用中，由于服务提供者和服务消费者运行在不同物理机器上的不同进程内，因此也被称为远程方法调用，简称 RPC（Remote Procedure Call）。

RPC 是如何像本地方法调用一样，完成一次请求处理的呢？我们不妨推导一二。首先，服务消费者和服务提供者通常位于网络上两个不同地址，要想交换信息，必须先建立网络连接；建立网络连接后，如果要想识别彼此的信息，必须遵循相同的通信协议；服务提供者和服务消费者，需要采用某种方式数据传输；为了减少传输数据量，还要对数据进行压缩，即序列化。

通过以上分析，我们由此可以得知 RPC 调用需要解决四个问题：

- 如何进行网络传输？
- 数据传输采用什么协议？
- 数据该如何序列化和反序列化？

## 网络传输方式

网络传输方式即服务提供者和服务消费者之间的数据传输采用哪种方式。是同步还是异步？是在单连接上传输，还是多路复用。

常见的网络传输方式有三种：

**同步阻塞方式（BIO）** - 客户端每发一次请求，服务端就生成一个线程去处理。当客户端同时发起的请求很多时，服务端需要创建很多的线程去处理每一个请求，如果达到了系统最大的线程数瓶颈，新来的请求就没法处理了。

BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。

![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630212345.png)

**同步非阻塞方式 (NIO)** - 客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I/O 多路复用技术进行处理。就是把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销。

NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。

BIO 与 NIO 最重要的区别是数据打包和传输的方式：**BIO 以流的方式处理数据，而 NIO 以块的方式处理数据**。

- **面向流的 BIO 一次处理一个字节数据**：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。
- **面向块的 NIO 一次处理一个数据块**，按块处理数据比按流处理数据要快得多。但是面向块的 NIO 缺少一些面向流的 BIO 所具有的优雅性和简单性。

![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630212248.png)

**异步非阻塞方式 (AIO)** - 客户端只需要发起一个 I/O 操作然后立即返回，等 I/O 操作真正完成以后，客户端会得到 I/O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题。

AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I/O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。

> 在实际的 Java 网络通信开发中，可以使用一些成熟的网络通信框架，如：Netty 等。

## 通信协议

**通信协议**要解决的是：服务提供者和服务消费者之间以什么样的**协议**进行网络通信。说白了，是要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？例如：Dubbo 基于 TCP 通信；而 Spring Cloud 基于 HTTP REST 通信。**TCP 通信方式，传输效率更高**；但是，HTTP 通信方式，天然支持对外服务。

HTTP 通信是基于应用层 HTTP 协议的，而 HTTP 协议又是基于传输层 TCP 协议的。一次 HTTP 通信过程就是发起一次 HTTP 调用，而一次 HTTP 调用就会建立一个 TCP 连接，经历**三次握手**的过程来建立连接。完成请求后，再经历一次**四次挥手**的过程来断开连接。

TCP 通信的过程分为四个步骤：**服务器监听**、**客户端请求**、**连接确认**、**数据传输**。当客户端和服务端建立网络连接后，就可以发起请求了。但网络不一定总是可靠的，经常会遇到网络闪断、连接超时、服务端宕机等各种异常，通常的处理手段有两种：**链路存活检测**和**断连重试**。

通过两种通信方式的对比，不难看出：HTTP 通信由于每次都要建立 TCP 连接，而建立连接又较为耗时，所以 **HTTP 通信性能是不如 TCP 通信的**。

除了 HTTP 协议和 TCP 协议以外，一些 RPC 框架还扩展支持了一些私有协议，如 Dubbo 支持的 Dubbo 协议，这里不一一列举。

## 序列化方式

在微服务架构中，**序列化和反序列化**主要解决客户端和服务端采用哪种数据编/解码的问题。常见的序列化方式包括：XML、JSON；二进制类如：[thrift](https://github.com/apache/thrift)、[protobuf](https://github.com/protocolbuffers/protobuf)、[hessian](http://hessian.caucho.com/doc/hessian-overview.xtp)、JDK。

具体采用哪种序列化方式，主要取决于三个方面的因素：

- **支持数据结构类型的丰富度** - 数据结构种类支持的自然是越多越好，这样使用者的开发体验比较友好。
- **跨语言支持** - 序列化方式是否支持跨语言也是一个很重要的因素，否则就无法应对异构服务场景。
- **性能** - 主要看两点，一个是序列化后的压缩比，一个是序列化的速度。以常用的 PB 序列化和 JSON 序列化协议为例来对比分析，PB 序列化的压缩比和速度都要比 JSON 序列化高很多，所以对性能和存储空间要求比较高的系统选用 PB 序列化更合适；而 JSON 序列化虽然性能要差一些，但可读性更好，更适合对外部提供服务。

> 更多序列化的内容可以参考：[Java 序列化](https://dunwu.github.io/blog/pages/2b2f0f/)

微服务框架对比：

|          | RPC                                               | REST                             |
| -------- | ------------------------------------------------- | -------------------------------- |
| 耦合性   | 强耦合                                            | 松散耦合                         |
| 协议     | Tcp                                               | Http、Http2                      |
| 序列化   | 二进制（Thrift、Protobuf、Hessian、Avro、JDK 等） | Xml、Json                        |
| 性能     | 高                                                | 低                               |
| 客户端   | 对编程语言有限制                                  | 跨语言支持更好（支持 Http 即可） |
| 代表技术 | Dubbo、Motan、Tars、gRpc、Thrift                  | Spring Cloud                     |

## 参考资料

- [从 0 开始学微服务](https://time.geekbang.org/column/intro/100014401)
- [RPC 实战与核心原理](https://time.geekbang.org/column/intro/100046201)