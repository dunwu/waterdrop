const e=JSON.parse('{"key":"v-f9c3b992","path":"/pages/d63c0ffb/","title":"Java 并发简介","lang":"zh-CN","frontmatter":{"title":"Java 并发简介","date":"2019-05-06T15:33:13.000Z","permalink":"/pages/d63c0ffb/","category":["Java","JavaCore","并发"],"tag":["Java","JavaCore","并发","线程","安全性","活跃性","性能","死锁","活锁"],"description":"Java 并发简介 摘要 - 并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。 什么是并发 技术在进步，CPU、内存、I/O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：CPU、内存、I/O 设备存在很大的速度差异 - CPU 远快于内存，内存远快于 I/O 设备。木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I/O 操作），所以单方面提高 CPU、内存的性能是无效的。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/d63c0ffb/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 并发简介"}],["meta",{"property":"og:description","content":"Java 并发简介 摘要 - 并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。 什么是并发 技术在进步，CPU、内存、I/O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：CPU、内存、I/O 设备存在很大的速度差异 - CPU 远快于内存，内存远快于 I/O 设备。木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I/O 操作），所以单方面提高 CPU、内存的性能是无效的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-13T09:46:18.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"线程"}],["meta",{"property":"article:tag","content":"安全性"}],["meta",{"property":"article:tag","content":"活跃性"}],["meta",{"property":"article:tag","content":"性能"}],["meta",{"property":"article:tag","content":"死锁"}],["meta",{"property":"article:tag","content":"活锁"}],["meta",{"property":"article:published_time","content":"2019-05-06T15:33:13.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-13T09:46:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 并发简介\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-05-06T15:33:13.000Z\\",\\"dateModified\\":\\"2025-09-13T09:46:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"什么是并发","slug":"什么是并发","link":"#什么是并发","children":[]},{"level":2,"title":"并发的优点","slug":"并发的优点","link":"#并发的优点","children":[{"level":3,"title":"提升资源利用率","slug":"提升资源利用率","link":"#提升资源利用率","children":[]},{"level":3,"title":"程序响应更快","slug":"程序响应更快","link":"#程序响应更快","children":[]}]},{"level":2,"title":"安全性问题","slug":"安全性问题","link":"#安全性问题","children":[{"level":3,"title":"缓存导致的可见性问题","slug":"缓存导致的可见性问题","link":"#缓存导致的可见性问题","children":[]},{"level":3,"title":"线程切换带来的原子性问题","slug":"线程切换带来的原子性问题","link":"#线程切换带来的原子性问题","children":[]},{"level":3,"title":"编译优化带来的有序性问题","slug":"编译优化带来的有序性问题","link":"#编译优化带来的有序性问题","children":[]},{"level":3,"title":"保证并发安全的思路","slug":"保证并发安全的思路","link":"#保证并发安全的思路","children":[]}]},{"level":2,"title":"活跃性问题","slug":"活跃性问题","link":"#活跃性问题","children":[{"level":3,"title":"死锁（Deadlock）","slug":"死锁-deadlock","link":"#死锁-deadlock","children":[]},{"level":3,"title":"如何定位死锁","slug":"如何定位死锁","link":"#如何定位死锁","children":[]},{"level":3,"title":"活锁（Livelock）","slug":"活锁-livelock","link":"#活锁-livelock","children":[]},{"level":3,"title":"饥饿（Starvation）","slug":"饥饿-starvation","link":"#饥饿-starvation","children":[]}]},{"level":2,"title":"性能问题","slug":"性能问题","link":"#性能问题","children":[{"level":3,"title":"上下文切换","slug":"上下文切换","link":"#上下文切换","children":[]},{"level":3,"title":"资源限制","slug":"资源限制","link":"#资源限制","children":[]}]},{"level":2,"title":"并发编程","slug":"并发编程","link":"#并发编程","children":[]},{"level":2,"title":"J.U.C 简介","slug":"j-u-c-简介","link":"#j-u-c-简介","children":[]},{"level":2,"title":"并发术语","slug":"并发术语","link":"#并发术语","children":[{"level":3,"title":"串行、并行、并发","slug":"串行、并行、并发","link":"#串行、并行、并发","children":[]},{"level":3,"title":"同步和异步","slug":"同步和异步","link":"#同步和异步","children":[]},{"level":3,"title":"阻塞和非阻塞","slug":"阻塞和非阻塞","link":"#阻塞和非阻塞","children":[]},{"level":3,"title":"进程、线程、管程、协程","slug":"进程、线程、管程、协程","link":"#进程、线程、管程、协程","children":[]},{"level":3,"title":"竞态条件和临界区","slug":"竞态条件和临界区","link":"#竞态条件和临界区","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1743948422000,"updatedTime":1757756778000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":3}]},"readingTime":{"minutes":26.55,"words":7966},"filePathRelative":"01.Java/01.JavaCore/05.并发/Java_并发_简介.md","localizedDate":"2019年5月6日","excerpt":"<h1> Java 并发简介</h1>\\n<blockquote>\\n<p><strong>摘要</strong> - 并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。</p>\\n</blockquote>\\n<h2> 什么是并发</h2>\\n<p>技术在进步，CPU、内存、I/O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：<strong>CPU、内存、I/O 设备存在很大的速度差异</strong> - CPU 远快于内存，内存远快于 I/O 设备。木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I/O 操作），所以单方面提高 CPU、内存的性能是无效的。</p>","autoDesc":true}');export{e as data};
