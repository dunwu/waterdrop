import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as p,c as u,a as e,b as n,d as l,w as s,e as o}from"./app-3113b888.js";const g={},k=o(`<h1 id="kubernetes-面试" tabindex="-1"><a class="header-anchor" href="#kubernetes-面试" aria-hidden="true">#</a> Kubernetes 面试</h1><h2 id="【中等】什么是-kubernetes-并描述其主要组件及其作用。" tabindex="-1"><a class="header-anchor" href="#【中等】什么是-kubernetes-并描述其主要组件及其作用。" aria-hidden="true">#</a> 【中等】什么是 Kubernetes，并描述其主要组件及其作用。</h2><p>Kubernetes（K8s）是一个<strong>开源的容器编排平台</strong>，用于<strong>自动化部署、扩展和管理容器化应用</strong>。</p><p>它解决了管理大量微服务时的核心难题：</p><ul><li><strong>自动化运维</strong>：实现自动部署、扩缩容、故障恢复（自我修复）、滚动更新。</li><li><strong>高可用与弹性伸缩</strong>：保证应用持续在线，并能轻松应对流量波动。</li><li><strong>资源优化</strong>：高效调度容器，充分利用基础设施资源。</li></ul><p><strong>核心概念</strong></p><figure><img src="https://www.simplyblock.io/wp-content/media/a7fbb2_0290c594b9244137a8858165fa1c22f0mv2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>集群</strong>：由 <strong>Control Plane / Master Node</strong> 和 <strong>Worker Nodes</strong> 组成。</li><li><strong>Pod</strong>：最小部署单元，包含一个或多个紧密关联的容器。</li><li><strong>Deployment</strong>：定义 Pod 的期望状态（如副本数），实现滚动更新和回滚。</li><li><strong>Service</strong>：为动态变化的 Pod 提供稳定的网络访问和服务发现。</li></ul><h2 id="【中等】如何在-kubernetes-中创建一个-pod" tabindex="-1"><a class="header-anchor" href="#【中等】如何在-kubernetes-中创建一个-pod" aria-hidden="true">#</a> 【中等】如何在 Kubernetes 中创建一个 Pod？</h2><p><strong>方法一、配置文件（推荐用于生产）</strong></p><p>（1）<strong>创建 YAML 文件（示例：<code>my-pod.yaml</code>）</strong></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>container
      <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.25.3
      <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）<strong>应用配置</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl apply <span class="token parameter variable">-f</span> my-pod.yaml
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>优势</strong>：可版本控制、可重复、内容清晰，是生产环境标准做法。</p><p><strong>方法二、命令式命令（仅用于测试）</strong></p><p><strong>快速创建 Pod 的命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl run my-redis-pod <span class="token parameter variable">--image</span><span class="token operator">=</span>redis <span class="token parameter variable">--restart</span><span class="token operator">=</span>Never
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><em>注意：必须加 <code>--restart=Never</code> 才会创建独立 Pod，否则会默认创建 Deployment。</em></p><p><strong>优势：</strong> 快速简单，适合临时测试。</p><div class="hint-container info"><p class="hint-container-title">建议</p></div><ul><li><strong>最佳实践：</strong> 在生产中，不应直接创建 Pod，而应使用 <strong>Deployment</strong> 或 <strong>StatefulSet</strong> 等更高层级资源来管理 Pod，以实现自动恢复、扩缩容和滚动更新。</li><li><strong><code>containerPort</code> 字段</strong> 仅是文档说明，实际开放端口需要通过 <strong>Service</strong> 资源来实现。</li></ul><h2 id="【中等】kubernetes-中的-service-和-ingress-有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-service-和-ingress-有什么区别" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Service 和 Ingress 有什么区别？</h2><figure><img src="https://www.opsramp.com/wp-content/uploads/2022/07/Kubernetes-load-balances-traffic-across-the-services-1024x685-1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>Service</strong>：集群<strong>内部</strong>的通信与负载均衡。</li><li><strong>Ingress</strong>：集群<strong>外部</strong>的 HTTP(S) 流量管理与路由。</li><li><strong>典型流量路径</strong>：外部用户 -&gt; <strong>Ingress</strong> -&gt; <strong>Service</strong> -&gt; <strong>Pod</strong>。</li></ul><p><strong>核心区别对比表</strong></p><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Service</th><th style="text-align:left;">Ingress</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>作用层面</strong></td><td style="text-align:left;"><strong>传输层（L4）</strong></td><td style="text-align:left;"><strong>应用层（L7，HTTP/HTTPS）</strong></td></tr><tr><td style="text-align:left;"><strong>主要目标</strong></td><td style="text-align:left;"><strong>内部通信</strong>与稳定性</td><td style="text-align:left;"><strong>外部访问</strong>与智能路由</td></tr><tr><td style="text-align:left;"><strong>依赖关系</strong></td><td style="text-align:left;">Kubernetes 内置功能</td><td style="text-align:left;"><strong>依赖 Service</strong> 作为后端，并需要<strong>部署 Ingress Controller</strong></td></tr><tr><td style="text-align:left;"><strong>功能</strong></td><td style="text-align:left;">负载均衡、服务发现</td><td style="text-align:left;">域名/路径路由、SSL 终止</td></tr></tbody></table><h3 id="service-服务-内部稳定端点" tabindex="-1"><a class="header-anchor" href="#service-服务-内部稳定端点" aria-hidden="true">#</a> Service（服务）：内部稳定端点</h3><ul><li><strong>用途</strong>：为动态变化的 Pod 集合提供一个<strong>稳定的 IP 地址、DNS 名称和端口</strong>，实现服务发现和内部负载均衡。</li><li><strong>核心功能</strong>： <ul><li><strong>服务发现</strong>：通过标签选择器动态找到后端 Pod。</li><li><strong>负载均衡</strong>：将请求分发给多个 Pod 实例。</li></ul></li><li><strong>类型</strong>： <ul><li><strong>ClusterIP（默认）</strong>：仅限集群内部访问。</li><li><strong>NodePort</strong>：通过节点 IP 和静态端口暴露服务，可从外部访问。</li><li><strong>LoadBalancer</strong>：通过云提供商负载均衡器暴露服务到公网。</li></ul></li></ul><h3 id="ingress-入口-外部流量网关" tabindex="-1"><a class="header-anchor" href="#ingress-入口-外部流量网关" aria-hidden="true">#</a> Ingress（入口）：外部流量网关</h3><ul><li><strong>用途</strong>：作为集群的<strong>统一入口</strong>，管理外部访问，实现基于域名和路径的<strong>高级路由</strong>。</li><li><strong>核心功能</strong>： <ul><li><strong>基于规则的路由</strong>：根据 HTTP 请求的域名（如 <code>api.example.com</code>）和路径（如 <code>/api</code>）将流量导向不同的后端 Service。</li><li><strong>SSL/TLS 终止</strong>：在入口处处理 HTTPS 加密/解密。</li></ul></li><li><strong>重要概念</strong>： <ul><li><strong>Ingress Controller</strong>：<strong>必须部署</strong>的<strong>软件</strong>（如 Nginx、Traefik），用于实现 Ingress 规则。</li><li><strong>Ingress Resource</strong>：<strong>声明路由规则</strong>的 YAML 配置文件。</li></ul></li></ul><h2 id="【中等】kubernetes-中如何进行滚动更新和回滚" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中如何进行滚动更新和回滚" aria-hidden="true">#</a> 【中等】Kubernetes 中如何进行滚动更新和回滚？</h2><p>滚动更新和回滚是 <strong>Deployment</strong> 资源的核心功能。Deployment 通过控制 <strong>ReplicaSet</strong> 来管理 Pod，通过改变 Pod 模板的“期望状态”来实现无缝更新。</p><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">核心命令</th><th style="text-align:left;">本质</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>滚动更新</strong></td><td style="text-align:left;"><code>kubectl set image...</code> 或 <code>kubectl apply -f</code></td><td style="text-align:left;">通过创建新 ReplicaSet，<strong>逐步替换</strong> Pod。</td></tr><tr><td style="text-align:left;"><strong>回滚</strong></td><td style="text-align:left;"><code>kubectl rollout undo</code></td><td style="text-align:left;">将 Pod 模板<strong>重置</strong>为历史版本，并再次触发更新。</td></tr></tbody></table><h3 id="滚动更新" tabindex="-1"><a class="header-anchor" href="#滚动更新" aria-hidden="true">#</a> 滚动更新</h3><p><strong>目标</strong>：逐步用新版本 Pod 替换旧版本 Pod，实现<strong>零停机</strong>部署。</p><p><strong>操作方式</strong>：</p><p>（1）<strong>命令式（快速测试）</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl <span class="token builtin class-name">set</span> image deployment/my-app my-container<span class="token operator">=</span>my-app:v2.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）<strong>声明式（生产推荐）</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl apply <span class="token parameter variable">-f</span> deployment.yaml  <span class="token comment"># 修改 yaml 文件中的镜像版本后应用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>关键配置参数</strong>（在 Deployment YAML 的 <code>spec.strategy.rollingUpdate</code> 中）：</p><ul><li><code>maxSurge</code>：允许临时超过期望副本数的 Pod 数量（如 25%），用于平滑更新。</li><li><code>maxUnavailable</code>：更新过程中允许不可用的 Pod 最大数量（如 25%），保证服务最低可用性。</li></ul><p><strong>监控命令</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl rollout status deployment/my-app  <span class="token comment"># 查看实时状态</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="回滚操作" tabindex="-1"><a class="header-anchor" href="#回滚操作" aria-hidden="true">#</a> 回滚操作</h3><p><strong>目标</strong>：当新版本出现问题时，<strong>快速恢复</strong>到之前的稳定版本。</p><p><strong>操作流程</strong>：</p><p>（1）<strong>查看修订历史</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl rollout <span class="token function">history</span> deployment/my-app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）<strong>执行回滚</strong></p><p><strong>回滚到上一个版本</strong>（最常用）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl rollout undo deployment/my-app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>回滚到指定版本</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl rollout undo deployment/my-app --to-revision<span class="token operator">=</span><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>关键配置</strong>：</p><ul><li><code>revisionHistoryLimit</code>：指定保留的旧 ReplicaSet 历史记录数量，默认为 10，供回滚使用。</li></ul><h2 id="【中等】kubernetes-中的-configmap-和-secret-有什么作用" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-configmap-和-secret-有什么作用" aria-hidden="true">#</a> 【中等】Kubernetes 中的 ConfigMap 和 Secret 有什么作用？</h2><p>用 <strong>ConfigMap</strong> 管理应用配置，用 <strong>Secret</strong> 管理所有密码密钥。</p><p><strong>核心区别与总结</strong></p><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">ConfigMap</th><th style="text-align:left;">Secret</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>数据性质</strong></td><td style="text-align:left;"><strong>非敏感</strong>配置</td><td style="text-align:left;"><strong>敏感</strong>信息</td></tr><tr><td style="text-align:left;"><strong>安全性</strong></td><td style="text-align:left;">低，明文</td><td style="text-align:left;">较高（但默认不加密，需配合 RBAC 和 ETCD 加密）</td></tr><tr><td style="text-align:left;"><strong>关键建议</strong></td><td style="text-align:left;">存放应用配置</td><td style="text-align:left;"><strong>永远不要</strong>用 ConfigMap 存密码</td></tr></tbody></table><h3 id="configmap-配置映射" tabindex="-1"><a class="header-anchor" href="#configmap-配置映射" aria-hidden="true">#</a> ConfigMap（配置映射）</h3><ul><li><strong>用途</strong>：<strong>存储非敏感数据</strong>。</li><li><strong>数据类型</strong>：环境变量（如 <code>LOG_LEVEL=info</code>）、配置文件（如 <code>nginx.conf</code>）、命令行参数。</li><li><strong>存储形式</strong>：<strong>明文</strong>存储。</li><li><strong>使用方式</strong>： <ol><li><strong>作为环境变量注入</strong>到容器中。</li><li><strong>作为配置文件挂载</strong>到容器的指定目录（最常用）。</li></ol></li></ul><h3 id="secret-密钥" tabindex="-1"><a class="header-anchor" href="#secret-密钥" aria-hidden="true">#</a> Secret（密钥）</h3><ul><li><strong>用途</strong>：<strong>存储敏感信息</strong>。</li><li><strong>数据类型</strong>：密码、API 密钥、TLS 证书、镜像仓库拉取凭证。</li><li><strong>存储形式</strong>：<strong>Base64 编码</strong>（注意：这是编码，<strong>不是加密</strong>）。</li><li><strong>使用方式</strong>： <ol><li>作为环境变量注入（<strong>不推荐</strong>用于高敏感数据，有日志泄露风险）。</li><li><strong>作为只读文件挂载</strong>（<strong>推荐</strong>方式，更安全）。</li><li>特殊类型 <code>imagePullSecrets</code> 用于拉取私有镜像。</li></ol></li></ul><h2 id="【中等】kubernetes-中如何配置资源配额" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中如何配置资源配额" aria-hidden="true">#</a> 【中等】Kubernetes 中如何配置资源配额？</h2><p><strong>Kubernetes 中通过在命名空间创建 ResourceQuota 对象来配置资源配额</strong>。</p><p><strong>配置方式</strong>：</p><ul><li>用 YAML 定义 <code>ResourceQuota</code> 对象，指定 <code>namespace</code>（仅作用于目标命名空间）</li><li>配置项含两类：计算资源（<code>requests.cpu/limits.memory</code> 等总量上限）、对象数量（<code>pods/services</code> 等最大数量）</li><li>应用命令：<code>kubectl apply -f quota.yaml</code></li></ul><p><strong>核心作用</strong>：</p><ul><li>防资源滥用：限制命名空间资源总用量，避免单个应用占用过多资源</li><li>公平分配：按业务需求为不同命名空间（如开发 / 生产）分配配额</li><li>成本控制：避免超预期资源消耗，降低运维成本</li><li>保障核心业务：为关键业务预留资源，防止被抢占</li></ul><p><strong>注意</strong>：需与 Pod 的 <code>requests/limits</code> 配合；超配额时资源创建会被拒绝。</p><h2 id="【中等】kubernetes-中的-namespace-有什么作用" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-namespace-有什么作用" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Namespace 有什么作用？</h2><p><strong>Namespace（命名空间）</strong> 是 Kubernetes 集群的<strong>虚拟分区</strong>，用于在同一个物理集群中创建多个<strong>逻辑隔离</strong>的工作空间。</p><ul><li><strong>资源与对象隔离</strong>：不同 Namespace 中的资源（如 Pod、Service）可以<strong>重名</strong>。</li><li><strong>资源配额管理</strong>：可以为每个 Namespace 设置独立的 CPU、内存等资源使用上限。</li><li><strong>访问权限控制</strong>：结合 RBAC，可限制不同团队或用户只能访问指定的 Namespace。</li></ul><p><strong>主要使用场景</strong></p><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">目的</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>环境隔离</strong> （最常用）</td><td style="text-align:left;">将开发、测试、生产环境完全分离，避免相互干扰。</td><td style="text-align:left;"><code>dev</code>, <code>test</code>, <code>prod</code></td></tr><tr><td style="text-align:left;"><strong>团队/项目隔离</strong></td><td style="text-align:left;">在共享集群中，为不同团队或项目提供独立的工作空间。</td><td style="text-align:left;"><code>team-a</code>, <code>project-x</code></td></tr><tr><td style="text-align:left;"><strong>系统组件隔离</strong></td><td style="text-align:left;">将 Kubernetes 核心系统组件与用户应用分开管理。</td><td style="text-align:left;"><code>kube-system</code> （存放核心组件）</td></tr></tbody></table><p><strong>关键要点与注意事项</strong></p><ul><li><strong>并非完全隔离</strong>：是逻辑隔离，非物理隔离。异常应用仍可能影响底层节点。</li><li><strong>部分资源不归属</strong>：Node、PersistentVolume 等集群级资源不属于任何 Namespace。</li><li><strong>删除后果严重</strong>：删除 Namespace 会<strong>同步删除</strong>其内所有资源，且不可逆。</li><li><strong>默认空间</strong>：未指定时，操作默认在 <code>default</code> 命名空间进行。</li></ul><h2 id="【中等】kubernetes-中如何进行日志管理" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中如何进行日志管理" aria-hidden="true">#</a> 【中等】Kubernetes 中如何进行日志管理？</h2><p>Kubernetes 本身不提供内置的集中式日志解决方案，但其基础机制是：<strong>应用应将日志输出到标准输出（stdout）和标准错误（stderr）</strong>，而非文件。</p><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">方案</th><th style="text-align:left;">特点</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>开发/调试</strong></td><td style="text-align:left;"><code>kubectl logs</code></td><td style="text-align:left;">简单快捷，但日志易失、分散。</td></tr><tr><td style="text-align:left;"><strong>生产环境</strong></td><td style="text-align:left;"><strong>集群级日志架构</strong></td><td style="text-align:left;"><strong>必备方案</strong>。实现日志的集中、持久化、搜索和告警。</td></tr></tbody></table><p><strong>基础查看（用于开发调试）</strong></p><ul><li><strong>命令</strong>：使用 <code>kubectl logs &lt;pod-name&gt;</code> 直接查看 Pod 的日志。</li><li><strong>原理</strong>：日志由节点上的容器运行时捕获并存储在本地文件中。</li><li><strong>缺点</strong>：<strong>日志分散在各节点</strong>，随 Pod 删除或节点故障而<strong>丢失</strong>，无法集中分析。</li></ul><p><strong>集群级方案（用于生产环境）</strong></p><p>这是必须采用的架构，核心是增加一个<strong>日志代理</strong>，将日志收集到<strong>中心化后端</strong>。</p><ul><li><p><strong>核心组件</strong>：</p><ol><li><strong>日志代理</strong>：以 <strong>DaemonSet</strong> 形式运行在每个节点上（如 <strong>Fluentd</strong> 或 <strong>Fluent Bit</strong>），负责收集和转发该节点上所有容器的日志。</li><li><strong>日志后端</strong>：集中存储和索引日志的系统（如 <strong>Elasticsearch</strong>、<strong>Grafana Loki</strong> 或云厂商服务）。</li><li><strong>可视化界面</strong>：用于查询和展示日志的 Web UI（如 <strong>Kibana</strong>、<strong>Grafana</strong>）。</li></ol></li><li><p><strong>经典架构（EFK）</strong>：<br><code>应用 stdout -&gt; 节点文件 -&gt; Fluentd -&gt; Elasticsearch -&gt; Kibana</code></p></li></ul><p><strong>关键实践与要点</strong></p><ul><li><strong>日志上下文</strong>：日志代理会自动为每条日志添加丰富的元数据（如 Pod 名称、命名空间、标签），极大方便问题排查。</li><li><strong>处理文件日志</strong>：若应用必须写文件到磁盘，可采用 <strong>Sidecar 容器模式</strong>，由 Sidecar 读取日志文件并输出到其 stdout，从而纳入标准收集流程。</li><li><strong>云服务</strong>：在公有云上，直接使用托管的日志服务（如 AWS CloudWatch）是最简单省心的选择。</li></ul><h2 id="【中等】kubernetes-中如何实现持久化存储" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中如何实现持久化存储" aria-hidden="true">#</a> 【中等】Kubernetes 中如何实现持久化存储？</h2><p>在 Kubernetes 中配置持久化存储需通过 <strong>PV（PersistentVolume，持久卷）</strong> 和 <strong>PVC（PersistentVolumeClaim，持久卷声明）</strong> 实现，核心步骤如下：</p><p>（1）<strong>定义 PV（集群级存储资源）</strong></p><p>PV 由管理员配置，代表集群中的实际存储资源（如本地磁盘、NFS、云存储等），示例（NFS 类型）：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pv
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>
    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 10Gi <span class="token comment"># 存储容量</span>
  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> ReadWriteMany <span class="token comment"># 多节点读写</span>
  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>
    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/nfs <span class="token comment"># NFS 共享路径</span>
    <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.1.100 <span class="token comment"># NFS 服务器地址</span>
  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Retain <span class="token comment"># 回收策略（Retain/Delete/Recycle）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用：<code>kubectl apply -f pv.yaml</code></p><p>（2）<strong>定义 PVC（用户申请存储）</strong></p><p>PVC 由用户创建，用于申请 PV 资源，无需关心底层存储细节：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>pvc
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> ReadWriteMany
  <span class="token key atrule">resources</span><span class="token punctuation">:</span>
    <span class="token key atrule">requests</span><span class="token punctuation">:</span>
      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 5Gi <span class="token comment"># 申请 5Gi 存储</span>
  <span class="token comment"># 可选：通过 storageClassName 指定存储类</span>
  <span class="token comment"># storageClassName: &quot;fast&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用：<code>kubectl apply -f pvc.yaml</code></p><p>（3）<strong>Pod 挂载 PVC</strong></p><p>在 Pod 中引用 PVC，实现数据持久化：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app
      <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data<span class="token punctuation">-</span>volume
          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html <span class="token comment"># 容器内挂载路径</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data<span class="token punctuation">-</span>volume
      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>
        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>pvc <span class="token comment"># 关联 PVC</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）进阶：使用 StorageClass 动态供应</p><p>通过 StorageClass 实现 PV 自动创建，无需手动配置 PV：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> fast
<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> kubernetes.io/aws<span class="token punctuation">-</span>ebs <span class="token comment"># 存储插件（如 AWS EBS、Ceph 等）</span>
<span class="token key atrule">parameters</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> gp2 <span class="token comment"># 存储类型</span>
<span class="token key atrule">reclaimPolicy</span><span class="token punctuation">:</span> Delete
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PVC 引用 StorageClass 即可动态获取存储。</p><h2 id="核心作用" tabindex="-1"><a class="header-anchor" href="#核心作用" aria-hidden="true">#</a> 核心作用</h2><ul><li>解耦存储与应用：管理员管理 PV，用户通过 PVC 申请，无需关注底层存储细节</li><li>数据持久化：容器销毁后，数据仍保存在 PV 中，支持跨 Pod 复用</li><li>灵活适配：支持多种存储后端（本地磁盘、NFS、云存储等）</li></ul><p>通过 PV/PVC 机制，Kubernetes 实现了存储资源的标准化管理，满足状态应用（如数据库）的数据持久化需求。</p><h2 id="【中等】kubernetes-中的-helm-有什么作用" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-helm-有什么作用" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Helm 有什么作用？</h2><p>Helm 作为 Kubernetes 包管理工具的核心作用：</p><ul><li><strong>应用打包</strong>：将 Deployment、Service 等资源打包为「Chart」，便于分发复用</li><li><strong>简化部署</strong>：通过 <code>helm install</code> 一键部署，支持动态配置（<code>--set</code> 或 values 文件）</li><li><strong>版本管理</strong>：记录应用版本（Release），支持 <code>upgrade</code> 升级和 <code>rollback</code> 回滚</li><li><strong>依赖管理</strong>：自动处理应用间依赖，一键部署完整应用栈</li><li><strong>模板化配置</strong>：用 Go 模板分离配置与代码，适配多环境部署</li></ul><p>适用于简化复杂 K8s 应用的管理，提升部署效率和可维护性。</p><h2 id="【中等】如何在-kubernetes-中使用-helm-部署应用" tabindex="-1"><a class="header-anchor" href="#【中等】如何在-kubernetes-中使用-helm-部署应用" aria-hidden="true">#</a> 【中等】如何在 Kubernetes 中使用 Helm 部署应用？</h2><p>使用 Helm 在 Kubernetes 中部署应用的核心要点：</p><ol><li><strong>准备工作</strong>：安装 Helm 客户端，添加并更新 Chart 仓库（如 <code>helm repo add</code>）</li><li><strong>部署流程</strong>： <ul><li>搜索 Chart（<code>helm search repo</code>）并查看配置（<code>helm show values</code>）</li><li>自定义配置（通过 <code>values.yaml</code> 或 <code>--set</code> 参数覆盖默认值）</li><li>部署应用（<code>helm install &lt;release 名&gt; &lt;chart 名&gt;</code>）</li></ul></li><li><strong>管理操作</strong>： <ul><li>升级（<code>helm upgrade</code>）：更新配置或 Chart 版本</li><li>回滚（<code>helm rollback</code>）：基于历史版本（<code>helm history</code> 查看）恢复</li><li>卸载（<code>helm uninstall</code>）：删除 Release 及相关资源</li></ul></li><li><strong>自定义应用</strong>：通过 <code>helm create</code> 生成 Chart 结构，编写模板和配置后部署本地 Chart</li></ol><p>优势：简化多资源部署，支持配置分离、版本控制和一键回滚，提升管理效率。</p><h2 id="【中等】kubernetes-中如何进行安全配置" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中如何进行安全配置" aria-hidden="true">#</a> 【中等】Kubernetes 中如何进行安全配置？</h2><ul><li><strong>集群级防护</strong>：API Server 启用 TLS 加密 + IP 限制 + RBAC；kubelet 最小权限配置；用 Secrets / 外部工具（Vault）管理敏感信息</li><li><strong>资源安全配置</strong>： <ul><li>Pod 安全上下文（禁止 root 运行、禁用权限提升等）</li><li>用 Pod 安全标准 / 策略定义运行规则，设资源限制防耗尽</li></ul></li><li><strong>网络安全</strong>：通过 NetworkPolicy 限制 Pod 间通信；服务网格（如 Istio）实现 mTLS 加密</li><li><strong>镜像与供应链</strong>：扫描镜像漏洞，用私有仓库 + 拉取密钥，禁止 <code>latest</code> 标签</li><li><strong>审计与监控</strong>：启用 API Server 审计日志，监控异常行为（如特权容器创建）</li></ul><h2 id="【中等】kubernetes-中的-pod-是什么-其作用是什么" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-pod-是什么-其作用是什么" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Pod 是什么？其作用是什么？</h2><p>Kubernetes 中的 Pod 是集群中最小的部署和管理单元，是容器的封装集合。</p><p><strong>核心构成</strong>：</p><ul><li>包含一个或多个紧密关联的容器（如应用容器 + 日志收集容器）</li><li>共享网络命名空间（同一 Pod 内容器共享 IP 和端口）</li><li>共享存储卷（可通过 Volume 实现容器间数据共享）</li></ul><p><strong>主要作用</strong>：</p>`,124),m=e("li",null,"作为应用部署的基本单位，封装应用运行所需的容器、网络和存储资源",-1),b={href:"https://localhost/",target:"_blank",rel:"noopener noreferrer"},h=e("li",null,"作为 Kubernetes 调度、扩展、自愈的最小单元（如调度到节点、副本集扩缩容均以 Pod 为单位）",-1),v=e("li",null,"抽象底层容器运行时，统一管理容器生命周期",-1),y=o('<p>Pod 具有临时性，生命周期结束后会被销毁重建，其 IP 可能变化，通常通过 Service 提供稳定访问入口。</p><h2 id="【中等】如何在-kubernetes-中实现服务的自动伸缩" tabindex="-1"><a class="header-anchor" href="#【中等】如何在-kubernetes-中实现服务的自动伸缩" aria-hidden="true">#</a> 【中等】如何在 Kubernetes 中实现服务的自动伸缩？</h2><p>Kubernetes 中服务自动伸缩的核心要点：</p><ul><li><strong>核心实现</strong>：通过 HPA（Horizontal Pod Autoscaler）实现，根据指标动态调整 Pod 副本数</li><li><strong>配置要点</strong>： <ul><li>关联目标控制器（Deployment/StatefulSet 等）</li><li>设定副本数范围（minReplicas/maxReplicas）</li><li>基于指标触发伸缩（CPU / 内存使用率或自定义指标）</li></ul></li><li><strong>依赖条件</strong>：需部署 Metrics Server 收集指标，目标 Pod 需定义 resources.requests</li><li><strong>作用</strong>：动态适配负载变化，高峰扩容提升能力，低谷缩容节约资源，保障服务稳定性</li><li><strong>扩展场景</strong>：结合 Prometheus 等工具支持自定义指标（如每秒请求数）伸缩</li></ul><h2 id="【中等】kubernetes-中的-deployment-和-statefulset-有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-deployment-和-statefulset-有什么区别" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Deployment 和 StatefulSet 有什么区别？</h2><p>Kubernetes 中 Deployment 与 StatefulSet 的核心区别：</p><ul><li><strong>适用场景</strong>： <ul><li><strong>Deployment</strong>：适用于无状态应用（如 Web 服务），副本完全等价</li><li><strong>StatefulSet</strong>：适用于有状态应用（如数据库），需稳定身份和存储</li></ul></li><li><strong>核心差异</strong>： <ul><li><strong>命名</strong>：Deployment 随机命名，StatefulSet 固定序号命名（如 db-0、db-1）</li><li><strong>网络</strong>：Deployment 共享 Service IP，StatefulSet 每个 Pod 有稳定 DNS</li><li><strong>存储</strong>：Deployment 共享存储，StatefulSet 每个 Pod 绑定独立 PVC</li><li><strong>更新</strong> / 扩缩容：Deployment 无序操作，StatefulSet 按序号严格执行</li><li><strong>自愈</strong>：Deployment 重建后身份变化，StatefulSet 保持原身份</li></ul></li></ul><p>选择依据：应用是否依赖稳定身份、存储或有序部署 / 更新。</p><h2 id="【中等】kubernetes-中的-ingress-资源有什么作用-如何配置" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-ingress-资源有什么作用-如何配置" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Ingress 资源有什么作用？如何配置？</h2><p>Kubernetes 中 Ingress 资源的核心要点：</p><ul><li><strong>核心作用</strong>： <ul><li>作为集群入口网关，统一管理外部对集群内服务的访问</li><li>支持基于域名、路径的 HTTP/HTTPS 请求路由（如将不同域名请求转发到对应服务）</li><li>实现 SSL 终结（集中管理 HTTPS 证书）和负载均衡</li></ul></li><li><strong>配置前提</strong>：需部署 Ingress 控制器（如 Nginx Ingress Controller），否则规则不生效</li><li><strong>关键配置</strong>： <ul><li><code>ingressClassName</code>：指定使用的控制器</li><li><code>rules</code>：定义路由规则（<code>host</code> 域名 + <code>paths</code> 路径，关联目标 Service）</li><li><code>tls</code>：配置 HTTPS，通过 <code>secretName</code> 关联存储证书的 Secret</li><li><code>pathType</code>：路径匹配类型（Prefix 前缀 / Exact 精确等）</li></ul></li><li><strong>示例场景</strong>：基于域名（<code>web.example.com</code> 到 Web 服务）、路径（<code>/v1</code> 到 API v1 服务）的路由，或配置 HTTPS 加密访问</li></ul><h2 id="【中等】kubernetes-中的-daemonset-有什么作用" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-daemonset-有什么作用" aria-hidden="true">#</a> 【中等】Kubernetes 中的 DaemonSet 有什么作用？</h2><p>Kubernetes 中 DaemonSet 的核心要点：</p><ul><li><strong>核心作用</strong>：确保集群中（或指定标签的）所有节点上都运行且仅运行一个相同的 Pod 副本，专为节点级服务设计。</li><li><strong>典型场景</strong>： <ul><li>节点监控（如 Prometheus Node Exporter）</li><li>日志收集（如 Fluentd）</li><li>网络 / 存储插件的节点代理（如 Calico、Ceph 代理）</li></ul></li><li><strong>关键特性</strong>： <ul><li>自动适配节点变化（新节点加入时自动部署，节点移除时自动清理）</li><li>无需手动配置副本数（由符合条件的节点数量决定）</li><li>支持通过 <code>nodeSelector</code> 等指定部署节点范围</li></ul></li></ul><p>适用于需要在每个节点上部署的系统级服务，简化底层支撑能力的统一管理。</p><h2 id="【中等】kubernetes-中的-replicaset-和-replicationcontroller-有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-replicaset-和-replicationcontroller-有什么区别" aria-hidden="true">#</a> 【中等】Kubernetes 中的 ReplicaSet 和 ReplicationController 有什么区别？</h2><p>Kubernetes 中 ReplicaSet 与 ReplicationController 的核心区别：</p><ol><li><strong>核心差异：标签选择器</strong><ul><li>ReplicationController：仅支持等值选择器（<code>matchLabels</code>），只能匹配标签完全一致的 Pod，灵活性低。</li><li>ReplicaSet：支持等值选择器（<code>matchLabels</code>）和集合选择器（<code>matchExpressions</code>），可通过表达式（如 <code>app in (nginx,web)</code>）实现复杂匹配，灵活性更高。</li></ul></li><li><strong>其他区别</strong><ul><li>API 版本：ReplicationController 使用 <code>v1</code>（老旧），ReplicaSet 使用 <code>apps/v1</code>（标准稳定版）。</li><li>定位：ReplicaSet 是 ReplicationController 的升级替代方案，是 Deployment 的底层依赖，目前为推荐使用的副本管理组件；ReplicationController 已逐步淘汰。</li></ul></li></ol><p>选择建议：优先使用 ReplicaSet，仅在维护旧集群时考虑 ReplicationController。</p><h2 id="【中等】kubernetes-中的-service-有哪几种类型" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-service-有哪几种类型" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Service 有哪几种类型？</h2>',20),f=e("li",null,[e("strong",null,"ClusterIP（默认）"),n("：仅集群内访问，分配内部虚拟 IP；用于集群内服务通信（如前端调后端）。")],-1),P=e("li",null,[e("strong",null,"NodePort"),n("：每个节点开放静态端口（30000-32767），外部通过"),e("code",null,"节点 IP:NodePort"),n("访问；含 ClusterIP 功能，适合临时外部测试。")],-1),x=e("li",null,[e("strong",null,"LoadBalancer"),n("：依赖云服务商负载均衡器，分配外部 IP；用于生产环境公网访问（需云环境支持）。")],-1),S=e("strong",null,"ExternalName",-1),C={href:"https://example.com/",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,[e("strong",null,"Headless Service（无头服务）"),n("：不分配 ClusterIP，DNS 直接返回匹配 Pod IP 列表；适用于 StatefulSet 有状态应用（如数据库主从，需访问特定 Pod）。")],-1),V=o('<p>核心作用：抽象 Pod 动态变化，提供稳定访问入口，适配不同内外网访问场景。</p><h2 id="【中等】kubernetes-的-helm-charts-如何实现应用的版本控制" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-的-helm-charts-如何实现应用的版本控制" aria-hidden="true">#</a> 【中等】Kubernetes 的 Helm Charts 如何实现应用的版本控制？</h2><p>Helm Charts 实现应用版本控制的核心机制：</p><ul><li><strong>Chart 版本管理</strong>：通过 <code>Chart.yaml</code> 的 <code>version</code> 字段（语义化版本）标识模板本身版本，内容变更时同步更新版本号。</li><li><strong>Release 版本控制</strong>： <ul><li>每个部署实例（Release）有独立版本号（自动递增），记录当前 Chart 版本、配置参数和资源状态。</li><li>可通过 <code>helm history</code> 查看所有版本记录，用 <code>helm rollback</code> 回滚到指定版本。</li></ul></li><li><strong>配置与依赖管理</strong><ul><li>配置（<code>values.yaml</code>）与模板分离，不同环境配置独立管理，变更随 Release 版本记录。</li><li>依赖通过 <code>Chart.yaml</code> 声明版本范围，<code>Chart.lock</code> 锁定实际安装版本，确保部署一致性。</li></ul></li></ul><p>核心价值：实现从应用模板到部署实例的全链路版本追踪，支持安全升级与快速回滚，简化 Kubernetes 应用的版本管理。</p><h2 id="【中等】kubernetes-中的-job-和-cronjob-有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-job-和-cronjob-有什么区别" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Job 和 CronJob 有什么区别？</h2><p>Kubernetes 中 Job 和 CronJob 均用于管理短期运行的任务型工作负载，核心区别在于执行时机和调度方式：</p><ul><li>Job 适用于<strong>单次运行</strong>的任务，强调任务的成功完成；</li><li>CronJob 适用于<strong>周期性重复</strong>的任务，通过时间规则自动触发 Job，本质是 Job 的定时调度器。</li></ul><p>两者均专注于短期任务（区别于长期运行的 Deployment），但在执行时机和周期上有明确分工。</p><p><strong>关键特性差异</strong></p><table><thead><tr><th>特性</th><th>Job</th><th>CronJob</th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>手动触发或部署后立即执行</td><td>按 cron 表达式自动定时触发（如 <code>0 3 * * *</code> 表示每天凌晨 3 点）</td></tr><tr><td><strong>任务周期</strong></td><td>一次性完成，执行结束后终止</td><td>周期性重复执行，按调度规则循环触发新 Job</td></tr><tr><td><strong>核心配置</strong></td><td>指定完成的 Pod 数量（<code>completions</code>）、并行数（<code>parallelism</code>）</td><td>包含 cron 表达式（<code>schedule</code>）、任务模板（<code>jobTemplate</code>）、历史任务保留策略等</td></tr></tbody></table>',11),K=e("div",{class:"language-yaml line-numbers-mode","data-ext":"yml"},[e("pre",{class:"language-yaml"},[e("code",null,[e("span",{class:"token key atrule"},"apiVersion"),e("span",{class:"token punctuation"},":"),n(` batch/v1
`),e("span",{class:"token key atrule"},"kind"),e("span",{class:"token punctuation"},":"),n(` Job
`),e("span",{class:"token key atrule"},"metadata"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(" backup"),e("span",{class:"token punctuation"},"-"),n(`job
`),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"completions"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"1"),n(),e("span",{class:"token comment"},"# 需成功完成 1 个 Pod"),n(`
  `),e("span",{class:"token key atrule"},"parallelism"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"1"),n(),e("span",{class:"token comment"},"# 并行执行 1 个 Pod"),n(`
  `),e("span",{class:"token key atrule"},"template"),e("span",{class:"token punctuation"},":"),n(`
    `),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
      `),e("span",{class:"token key atrule"},"containers"),e("span",{class:"token punctuation"},":"),n(`
        `),e("span",{class:"token punctuation"},"-"),n(),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(` backup
          `),e("span",{class:"token key atrule"},"image"),e("span",{class:"token punctuation"},":"),n(" backup"),e("span",{class:"token punctuation"},"-"),n("tool"),e("span",{class:"token punctuation"},":"),n(`v1
          `),e("span",{class:"token key atrule"},"command"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token punctuation"},"["),e("span",{class:"token string"},"'backup'"),e("span",{class:"token punctuation"},","),n(),e("span",{class:"token string"},"'/data'"),e("span",{class:"token punctuation"},"]"),n(`
      `),e("span",{class:"token key atrule"},"restartPolicy"),e("span",{class:"token punctuation"},":"),n(" Never "),e("span",{class:"token comment"},"# 失败后不重启，由 Job 重新创建 Pod"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),N=e("div",{class:"language-yaml line-numbers-mode","data-ext":"yml"},[e("pre",{class:"language-yaml"},[e("code",null,[e("span",{class:"token key atrule"},"apiVersion"),e("span",{class:"token punctuation"},":"),n(` batch/v1
`),e("span",{class:"token key atrule"},"kind"),e("span",{class:"token punctuation"},":"),n(` CronJob
`),e("span",{class:"token key atrule"},"metadata"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(" log"),e("span",{class:"token punctuation"},"-"),n("cleanup"),e("span",{class:"token punctuation"},"-"),n(`cronjob
`),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"schedule"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token string"},"'0 3 * * *'"),n(),e("span",{class:"token comment"},"# 每天凌晨 3 点执行"),n(`
  `),e("span",{class:"token key atrule"},"jobTemplate"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token comment"},"# 嵌套 Job 配置"),n(`
    `),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
      `),e("span",{class:"token key atrule"},"template"),e("span",{class:"token punctuation"},":"),n(`
        `),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
          `),e("span",{class:"token key atrule"},"containers"),e("span",{class:"token punctuation"},":"),n(`
            `),e("span",{class:"token punctuation"},"-"),n(),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(` cleaner
              `),e("span",{class:"token key atrule"},"image"),e("span",{class:"token punctuation"},":"),n(" cleanup"),e("span",{class:"token punctuation"},"-"),n("tool"),e("span",{class:"token punctuation"},":"),n(`v1
              `),e("span",{class:"token key atrule"},"command"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token punctuation"},"["),e("span",{class:"token string"},"'clean'"),e("span",{class:"token punctuation"},","),n(),e("span",{class:"token string"},"'/logs'"),e("span",{class:"token punctuation"},"]"),n(`
          `),e("span",{class:"token key atrule"},"restartPolicy"),e("span",{class:"token punctuation"},":"),n(` Never
  `),e("span",{class:"token key atrule"},"successfulJobsHistoryLimit"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"3"),n(),e("span",{class:"token comment"},"# 保留 3 个成功历史任务"),n(`
  `),e("span",{class:"token key atrule"},"failedJobsHistoryLimit"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"1"),n(),e("span",{class:"token comment"},"# 保留 1 个失败历史任务"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),I=o('<h2 id="【中等】kubernetes-中的-persistent-volume-和-persistent-volume-claim-有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的-persistent-volume-和-persistent-volume-claim-有什么区别" aria-hidden="true">#</a> 【中等】Kubernetes 中的 Persistent Volume 和 Persistent Volume Claim 有什么区别？</h2><ul><li><strong>PV</strong> 是<strong>具体的存储资源</strong>，如一块云硬盘或 NFS 目录。相当于一个<strong>仓库</strong>。</li><li><strong>PVC</strong> 是用户对存储的<strong>抽象请求</strong>，如“我需要 10Gi 可读写的存储”。相当于一份<strong>仓储申请单</strong>。</li></ul><p>Kubernetes 的作用是将 PVC（申请单）与合适的 PV（仓库）进行绑定，供 Pod（用户）使用。</p><p><strong>核心区别对比</strong></p><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Persistent Volume (PV)</th><th style="text-align:left;">Persistent Volume Claim (PVC)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>本质</strong></td><td style="text-align:left;"><strong>存储资源本身</strong></td><td style="text-align:left;"><strong>对存储的请求</strong></td></tr><tr><td style="text-align:left;"><strong>创建者</strong></td><td style="text-align:left;"><strong>集群管理员</strong>（或由系统自动创建）</td><td style="text-align:left;"><strong>应用开发者</strong></td></tr><tr><td style="text-align:left;"><strong>作用范围</strong></td><td style="text-align:left;"><strong>集群级别</strong>资源，不属于任何命名空间</td><td style="text-align:left;"><strong>命名空间级别</strong>资源</td></tr><tr><td style="text-align:left;"><strong>关注点</strong></td><td style="text-align:left;"><strong>“如何提供”</strong>（如 NFS、云硬盘、容量）</td><td style="text-align:left;"><strong>“需要什么”</strong>（如容量、访问模式）</td></tr></tbody></table><p><strong>两种供给模式</strong></p><ul><li><strong>静态供给</strong>：管理员预先创建好一批 PV，PVC 从现有 PV 池中申请绑定。</li><li><strong>动态供给（推荐）</strong>：管理员创建 <strong>StorageClass</strong>（存储类）。当用户创建 PVC 并指定 <code>storageClassName</code> 时，系统<strong>自动按需创建</strong>对应的 PV。这是云环境中的标准做法。</li></ul><p><strong>核心价值：职责分离</strong></p><ul><li><strong>管理员</strong>：负责底层存储基础设施（PV/StorageClass）。</li><li><strong>开发者</strong>：只需通过 PVC 声明存储需求，无需关心后端细节。</li></ul><h2 id="【中等】kubernetes-中的网络策略如何实现" tabindex="-1"><a class="header-anchor" href="#【中等】kubernetes-中的网络策略如何实现" aria-hidden="true">#</a> 【中等】Kubernetes 中的网络策略如何实现？</h2><p><strong>网络策略是一种基于规则的防火墙</strong>，用于控制 Pod 之间的网络流量。它采用 <strong>“默认允许，有策则拒”</strong> 的白名单模型。</p><ul><li><strong>前提</strong>：集群的<strong>网络插件必须支持 NetworkPolicy</strong>（如 Calico、Cilium），否则策略不生效。</li><li><strong>本质</strong>：基于标签的 Pod 级防火墙。</li><li><strong>模型</strong>：白名单。规则之外的流量被拒绝。</li><li><strong>价值</strong>：实现<strong>网络微隔离</strong>，是 Kubernetes 安全的重要基石。</li></ul><p><strong>核心规则模型</strong></p><ul><li><strong>无策略状态</strong>：Pod 未被任何 NetworkPolicy 选中时，<strong>允许所有入站和出站流量</strong>。</li><li><strong>有策略状态</strong>：一旦 Pod 被某个策略选中，则： <ul><li><strong>入站流量</strong>：默认被拒绝，除非在 <code>ingress</code> 规则中明确允许。</li><li><strong>出站流量</strong>：默认仍被允许，除非在 <code>egress</code> 规则中明确限制。</li></ul></li></ul><p><strong>NetworkPolicy 关键组成部分</strong></p><p>一个策略主要定义四部分：</p><ul><li><strong><code>podSelector</code></strong>：<strong>此策略应用于哪些 Pod</strong>（通过标签选择）。</li><li><strong><code>policyTypes</code></strong>：策略类型（<code>Ingress</code>， <code>Egress</code>，或两者）。</li><li><strong><code>ingress</code></strong>：<strong>允许的入站</strong>流量来源（<code>from</code>）和端口（<code>ports</code>）。</li><li><strong><code>egress</code></strong>：<strong>允许的出站</strong>流量目标（<code>to</code>）和端口（<code>ports</code>）。</li></ul><p><strong>流量来源/目标可以是</strong></p><ul><li><code>podSelector</code>：同一命名空间内的其他 Pod。</li><li><code>namespaceSelector</code>：特定命名空间下的 Pod。</li><li><code>ipBlock</code>：外部 IP 地址段（CIDR）。</li></ul>',19),R=e("p",null,"最基础的安全加固",-1),T=e("div",{class:"language-yaml line-numbers-mode","data-ext":"yml"},[e("pre",{class:"language-yaml"},[e("code",null,[e("span",{class:"token key atrule"},"apiVersion"),e("span",{class:"token punctuation"},":"),n(` networking.k8s.io/v1
`),e("span",{class:"token key atrule"},"kind"),e("span",{class:"token punctuation"},":"),n(` NetworkPolicy
`),e("span",{class:"token key atrule"},"metadata"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(" deny"),e("span",{class:"token punctuation"},"-"),n("all"),e("span",{class:"token punctuation"},"-"),n(`ingress
`),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"podSelector"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token punctuation"},"{"),e("span",{class:"token punctuation"},"}"),n(),e("span",{class:"token comment"},"# 选择本命名空间所有 Pod"),n(`
  `),e("span",{class:"token key atrule"},"policyTypes"),e("span",{class:"token punctuation"},":"),n(`
    `),e("span",{class:"token punctuation"},"-"),n(` Ingress
  `),e("span",{class:"token comment"},"# ingress 规则为空，表示拒绝所有入站连接"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),D=e("div",{class:"language-yaml line-numbers-mode","data-ext":"yml"},[e("pre",{class:"language-yaml"},[e("code",null,[e("span",{class:"token punctuation"},"---"),n(`
`),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"podSelector"),e("span",{class:"token punctuation"},":"),n(`
    `),e("span",{class:"token key atrule"},"matchLabels"),e("span",{class:"token punctuation"},":"),n(`
      `),e("span",{class:"token key atrule"},"app"),e("span",{class:"token punctuation"},":"),n(" backend "),e("span",{class:"token comment"},"# 策略作用于后端 Pod"),n(`
  `),e("span",{class:"token key atrule"},"ingress"),e("span",{class:"token punctuation"},":"),n(`
    `),e("span",{class:"token punctuation"},"-"),n(),e("span",{class:"token key atrule"},"from"),e("span",{class:"token punctuation"},":"),n(`
        `),e("span",{class:"token punctuation"},"-"),n(),e("span",{class:"token key atrule"},"podSelector"),e("span",{class:"token punctuation"},":"),n(`
            `),e("span",{class:"token key atrule"},"matchLabels"),e("span",{class:"token punctuation"},":"),n(`
              `),e("span",{class:"token key atrule"},"app"),e("span",{class:"token punctuation"},":"),n(" frontend "),e("span",{class:"token comment"},"# 只允许来自前端 Pod 的流量"),n(`
      `),e("span",{class:"token key atrule"},"ports"),e("span",{class:"token punctuation"},":"),n(`
        `),e("span",{class:"token punctuation"},"-"),n(),e("span",{class:"token key atrule"},"port"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"8080"),n(),e("span",{class:"token comment"},"# 只开放 8080 端口"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),L=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),n(" 参考资料")],-1),A={href:"https://www.mianshiya.com/bank/1812067408974839809",target:"_blank",rel:"noopener noreferrer"};function w(H,J){const r=c("ExternalLinkIcon"),i=c("Tabs");return p(),u("div",null,[k,e("ol",null,[m,e("li",null,[n("提供容器间协同工作的环境（如前后端容器同 Pod 部署，通过 "),e("a",b,[n("localhost"),l(r)]),n(" 通信）")]),h,v]),y,e("ul",null,[f,P,x,e("li",null,[S,n("：将 Service 映射到外部域名（如 "),e("a",C,[n("example.com"),l(r)]),n("），无 Pod 关联；用于访问集群外固定服务（如外部数据库）。")]),_]),V,l(i,{id:"1511",data:[{id:"Job（一次性任务）"},{id:"CronJob（定时任务）"}],"tab-id":"配置示例对比"},{title0:s(({value:t,isActive:a})=>[n("Job（一次性任务）")]),title1:s(({value:t,isActive:a})=>[n("CronJob（定时任务）")]),tab0:s(({value:t,isActive:a})=>[K]),tab1:s(({value:t,isActive:a})=>[N]),_:1}),I,l(i,{id:"1734",data:[{id:"场景：禁止所有入站流量"},{id:"场景：只允许特定前端访问后端 API"}],"tab-id":"经典场景示例"},{title0:s(({value:t,isActive:a})=>[n("场景：禁止所有入站流量")]),title1:s(({value:t,isActive:a})=>[n("场景：只允许特定前端访问后端 API")]),tab0:s(({value:t,isActive:a})=>[R,T]),tab1:s(({value:t,isActive:a})=>[D]),_:1}),L,e("ul",null,[e("li",null,[e("a",A,[n("面试鸭 - Kubernetes 面试题"),l(r)])])])])}const B=d(g,[["render",w],["__file","index.html.vue"]]);export{B as default};
