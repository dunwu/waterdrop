import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as r,o as n}from"./app-DCImtImk.js";const o={};function s(i,e){return n(),a("div",null,[...e[0]||(e[0]=[r('<h1 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h1><blockquote><p><strong>队列</strong>和<strong>栈</strong>都是<strong>操作受限</strong>的<strong>线性表</strong>：前者先进先出，后者先进后出。</p></blockquote><h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h2><h3 id="栈是什么" tabindex="-1"><a class="header-anchor" href="#栈是什么"><span>栈是什么</span></a></h3><p>在 <strong>LIFO(后进先出)</strong> 数据结构中，将首先处理添加到队列中的最新元素。</p><p><strong>栈是一个 LIFO(后进先出) 数据结构</strong>。<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/d95a2ebcef8c42e987ee25fd5c499ff4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</strong>。</p><p>从栈的定义可以看出，栈只支持两个基本操作：<strong>入栈 <code>push()</code></strong> 和 <strong>出栈 <code>pop()</code></strong> ，也就是在栈顶插入一个数据和从栈顶删除一个数据。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 <code>O(1)</code>。</p><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><h3 id="为什么需要栈" tabindex="-1"><a class="header-anchor" href="#为什么需要栈"><span>为什么需要栈</span></a></h3><p>相比数组和链表，栈只是对操作进行了限制，似乎并没有任何优势。为什么不直接使用数组或者链表？为什么还要用这个“操作受限”的“栈”呢？</p><p>特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><h3 id="栈的应用场景" tabindex="-1"><a class="header-anchor" href="#栈的应用场景"><span>栈的应用场景</span></a></h3><p>（1）<strong>函数调用栈</strong></p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/7696bd16144347efbe09a48f97aeb07c.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）<strong>表达式求值</strong></p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/96a340ac3de143e4a541777847add52e.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）<strong>表达式匹配</strong></p><p>可以借助栈来检查表达式中的括号是否匹配</p><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列"><span>队列</span></a></h2><p>在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。</p><p>队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。</p><h3 id="什么是队列" tabindex="-1"><a class="header-anchor" href="#什么是队列"><span>什么是队列</span></a></h3><p><strong>队列：先进先出的线性表</strong>。</p><p><strong>队列是一种“操作受限”的线性表</strong>，只允许在一端插入数据，在另一端删除数据。</p><p>队列的最基本操作：<strong>入队 <code>enqueue()</code></strong>，放一个数据到队列尾部；<strong>出队 <code>dequeue()</code></strong>，从队列头部取一个元素。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/53a38d3876ed42f7bb790b93077e57af.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p>队满的判断条件是 <code>tail == n</code>，队空的判断条件是 <code>head == tail</code>。</p><h3 id="循环队列" tabindex="-1"><a class="header-anchor" href="#循环队列"><span>循环队列</span></a></h3><p>循环队列是一种较为特殊的队列。</p><p>循环队列的要点是确定好 <strong>队空和队满的判定条件</strong>。</p><p>在用数组实现的非循环队列中，队满的判断条件是 <code>(tail+1) % n == head</code>，队空的判断条件是 <code>head == tail</code>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/708b22469bbe45e892d4b682ddc0bbcc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="为什么需要队列" tabindex="-1"><a class="header-anchor" href="#为什么需要队列"><span>为什么需要队列</span></a></h3><p>为什么需要队列和为什么需要栈，是同样的道理，参考 为什么需要栈</p><h3 id="队列的应用场景" tabindex="-1"><a class="header-anchor" href="#队列的应用场景"><span>队列的应用场景</span></a></h3><p>（1）<strong>阻塞队列</strong></p><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是：</p><ul><li>在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；</li><li>如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/a056fc7f23a2468e8e156e07d8246fea.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/48c3dbb13d084075a5f66d13104c32be.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）<strong>并发队列</strong></p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://time.geekbang.org/column/intro/100017301" target="_blank" rel="noopener noreferrer">数据结构与算法之美</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/queue-stack/" target="_blank" rel="noopener noreferrer">Leetcode：栈和队列</a></li></ul>',47)])])}const g=t(o,[["render",s]]),d=JSON.parse('{"path":"/pages/4f160a46/","title":"栈和队列","lang":"zh-CN","frontmatter":{"title":"栈和队列","date":"2014-01-25T16:46:13.000Z","order":2,"categories":["算法"],"tags":["数据结构","线性表","栈","队列"],"permalink":"/pages/4f160a46/","description":"栈和队列 队列和栈都是操作受限的线性表：前者先进先出，后者先进后出。 栈 栈是什么 在 LIFO(后进先出) 数据结构中，将首先处理添加到队列中的最新元素。 栈是一个 LIFO(后进先出) 数据结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"栈和队列\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/d95a2ebcef8c42e987ee25fd5c499ff4.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/7696bd16144347efbe09a48f97aeb07c.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/96a340ac3de143e4a541777847add52e.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/53a38d3876ed42f7bb790b93077e57af.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/708b22469bbe45e892d4b682ddc0bbcc.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/a056fc7f23a2468e8e156e07d8246fea.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/48c3dbb13d084075a5f66d13104c32be.jpg\\"],\\"datePublished\\":\\"2014-01-25T16:46:13.000Z\\",\\"dateModified\\":\\"2026-02-11T15:41:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/4f160a46/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"栈和队列"}],["meta",{"property":"og:description","content":"栈和队列 队列和栈都是操作受限的线性表：前者先进先出，后者先进后出。 栈 栈是什么 在 LIFO(后进先出) 数据结构中，将首先处理添加到队列中的最新元素。 栈是一个 LIFO(后进先出) 数据结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/d95a2ebcef8c42e987ee25fd5c499ff4.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-11T15:41:54.000Z"}],["meta",{"property":"article:tag","content":"队列"}],["meta",{"property":"article:tag","content":"栈"}],["meta",{"property":"article:tag","content":"线性表"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2014-01-25T16:46:13.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-11T15:41:54.000Z"}]]},"git":{"createdTime":1651071272000,"updatedTime":1770824514000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":10,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":3.87,"words":1160},"filePathRelative":"11.算法/栈和队列.md","excerpt":"\\n<blockquote>\\n<p><strong>队列</strong>和<strong>栈</strong>都是<strong>操作受限</strong>的<strong>线性表</strong>：前者先进先出，后者先进后出。</p>\\n</blockquote>\\n<h2>栈</h2>\\n<h3>栈是什么</h3>\\n<p>在 <strong>LIFO(后进先出)</strong> 数据结构中，将首先处理添加到队列中的最新元素。</p>\\n<p><strong>栈是一个 LIFO(后进先出) 数据结构</strong>。<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。</p>","autoDesc":true}');export{g as comp,d as data};
