import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as r,c as l,a as t,b as e,d as i,e as a}from"./app-e3c6686a.js";const d={},g=t("h1",{id:"mysql-面试之事务和锁篇",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#mysql-面试之事务和锁篇","aria-hidden":"true"},"#"),e(" MySQL 面试之事务和锁篇")],-1),c=t("h2",{id:"mysql-事务",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#mysql-事务","aria-hidden":"true"},"#"),e(" MySQL 事务")],-1),u=t("p",null,"扩展阅读：",-1),p={href:"https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-transaction-model.html",target:"_blank",rel:"noopener noreferrer"},h=a(`<h3 id="【基础】什么是事务-什么是-acid" tabindex="-1"><a class="header-anchor" href="#【基础】什么是事务-什么是-acid" aria-hidden="true">#</a> 【基础】什么是事务，什么是 ACID？</h3><details class="hint-container details"><summary>要点</summary><p><strong>事务指的是满足 ACID 特性的一组操作</strong>。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。通俗来说，<strong>事务就是要保证一组数据库操作，要么全部成功，要么全部失败</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242207831.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>ACID 是数据库事务正确执行的四个基本要素。</p><ul><li><strong>原子性（Atomicity）</strong><ul><li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li><li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li></ul></li><li><strong>一致性（Consistency）</strong><ul><li>数据库在事务执行前后都保持一致性状态。</li><li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li></ul></li><li><strong>隔离性（Isolation）</strong><ul><li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li></ul></li><li><strong>持久性（Durability）</strong><ul><li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li><li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li></ul></li></ul><p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p></details><h3 id="【中级】事务存在哪些并发一致性问题" tabindex="-1"><a class="header-anchor" href="#【中级】事务存在哪些并发一致性问题" aria-hidden="true">#</a> 【中级】事务存在哪些并发一致性问题？</h3><details class="hint-container details"><summary>要点</summary><p>事务中存在的并发一致性问题有：</p><ul><li>丢失修改</li><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><p><strong>“丢失修改”是指一个事务的更新操作被另外一个事务的更新操作替换</strong>。</p><p>如下图所示，T<sub>1</sub> 和 T<sub>2</sub> 两个事务对同一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242209867.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据</strong>。</p><p>如下图所示，T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242210430.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致</strong>。</p><p>如下图所示，T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242211015.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>“幻读（phantom read）”是指一个事务内多次读取同一范围的数据，过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据</strong>。</p><p>事务 T<sub>1</sub> 读取某个范围内的记录时，事务 T<sub>2</sub> 在该范围内插入了新的记录，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242212639.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></details><h3 id="【中级】长事务可能会导致哪些问题" tabindex="-1"><a class="header-anchor" href="#【中级】长事务可能会导致哪些问题" aria-hidden="true">#</a> 【中级】长事务可能会导致哪些问题？</h3><details class="hint-container details"><summary>要点</summary><p>长事务可能会导致以下问题：</p><ul><li><strong>锁竞争与资源阻塞</strong><ul><li>长事务长时间持有锁，导致其他事务阻塞，增加系统等待时间，降低并发性能。</li><li>业务线程因数据库请求等待而阻塞，可能引发连锁反应（如服务雪崩），造成严重线上事故。</li></ul></li><li><strong>死锁风险增加</strong> - 多个长事务互相等待对方释放锁，容易形成死锁，导致系统无法正常执行。</li><li><strong>主从延迟问题</strong> - 主库执行时间长，从库同步及重放耗时增加，导致主从数据长时间不一致。</li><li><strong>回滚效率低下</strong> - 长事务执行中途失败时，回滚操作会浪费已执行的资源与时间，影响系统效率。</li></ul></details><h3 id="【高级】事务的二阶段提交是什么" tabindex="-1"><a class="header-anchor" href="#【高级】事务的二阶段提交是什么" aria-hidden="true">#</a> 【高级】事务的二阶段提交是什么？</h3><details class="hint-container details"><summary>要点</summary><p>事务的二阶段提交确保 <strong>redo log（重做日志）</strong> 和 <strong>binlog（二进制日志）</strong> 的一致性，防止崩溃恢复时出现数据丢失或不一致。</p><p><strong>两阶段流程</strong></p><ul><li><strong>Prepare 阶段（准备阶段）</strong> - InnoDB 写入 redo log，并标记为 <strong>prepare</strong> 状态（事务预提交，但未最终提交）。</li><li><strong>Commit 阶段（提交阶段）</strong> - MySQL Server 写入 <strong>binlog</strong>（记录 DML 操作）。binlog 写入成功后，InnoDB 将 redo log 状态改为 <strong>commit</strong>，完成事务提交。</li></ul></details><details class="hint-container details"><summary>细节</summary><p><strong>binlog 和 redo log 的区别</strong></p><table><thead><tr><th style="text-align:left;"><strong>特性</strong></th><th style="text-align:left;"><strong>redo log</strong></th><th style="text-align:left;"><strong>binlog</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>所属层级</strong></td><td style="text-align:left;">InnoDB 引擎层</td><td style="text-align:left;">MySQL Server 层</td></tr><tr><td style="text-align:left;"><strong>日志类型</strong></td><td style="text-align:left;">记录数据页的<strong>物理日志</strong></td><td style="text-align:left;">记录 DML/DDL 操作的<strong>逻辑日志</strong></td></tr><tr><td style="text-align:left;"><strong>存储方式</strong></td><td style="text-align:left;">固定大小，<strong>环形写入</strong></td><td style="text-align:left;"><strong>追加写入</strong>，可无限增长</td></tr><tr><td style="text-align:left;"><strong>主要用途</strong></td><td style="text-align:left;"><strong>崩溃恢复</strong>（保证数据持久性）</td><td style="text-align:left;"><strong>主从复制、数据恢复、备份</strong></td></tr></tbody></table><p><strong>为什么需要二阶段提交？</strong></p><p>无论是单独先写 redo log 或先写 binlog，都可能导致数据不一致：</p><ol><li><strong>先写 redo log，后写 binlog</strong>（宕机时 binlog 未写入） - redo log 恢复数据，但 binlog 缺失该事务 → <strong>主从数据不一致</strong>。</li><li><strong>先写 binlog，后写 redo log</strong>（宕机时 redo log 未写入） - binlog 有记录，但 redo log 未提交 → <strong>数据库实际数据丢失</strong>，与 binlog 不一致。</li></ol><p>为了解决以上问题，所以需要事务二阶段提交（<code>repare</code> → <code>commit</code>），以确保写入两日志的原子性。</p><p><strong>二阶段提交如何保证一致性？</strong></p><p>MySQL 崩溃恢复时，检查两日志状态：</p><ul><li><strong>redo log prepare，binlog 未写入</strong> - 直接回滚（两日志均无有效记录）。</li><li><strong>redo log prepare，binlog 已写入</strong> - 对比两日志数据： <ul><li><strong>一致</strong>：提交事务（redo log commit）。</li><li><strong>不一致</strong>：回滚事务（保证数据一致）。</li></ul></li></ul></details><h3 id="【中级】有哪些事务隔离级别-分别解决了什么问题" tabindex="-1"><a class="header-anchor" href="#【中级】有哪些事务隔离级别-分别解决了什么问题" aria-hidden="true">#</a> 【中级】有哪些事务隔离级别，分别解决了什么问题？</h3><details class="hint-container details"><summary>要点</summary><p>为了解决以上提到的并发一致性问题，SQL 标准提出了四种“事务隔离级别”来应对这些问题。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p><p>事务隔离级别从低到高分别是：</p><ul><li><strong>“读未提交（read uncommitted）”</strong> - 是指，<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</li><li>**“读已提交（read committed）” ** - 是指，<strong>事务提交后，其他事务才能看到它的修改</strong>。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 <ul><li><strong>读已提交解决了脏读的问题</strong>。</li><li>读已提交是大多数数据库的默认事务隔离级别，如 Oracle。</li></ul></li><li><strong>“可重复读（repeatable read）”</strong> - 是指：<strong>保证在同一个事务中多次读取同样数据的结果是一样的</strong>。 <ul><li><strong>可重复读解决了不可重复读问题</strong>。</li><li><strong>可重复读是 InnoDB 存储引擎的默认事务隔离级别</strong>。</li></ul></li><li><strong>“串行化（serializable ）”</strong> - 是指，<strong>强制事务串行执行</strong>，对于同一行记录，加读写锁，一旦出现锁冲突，必须等前面的事务释放锁。 <ul><li><strong>串行化解决了幻读问题</strong>。由于强制事务串行执行，自然避免了所有的并发问题。</li><li><strong>串行化策略会在读取的每一行数据上都加锁</strong>，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</li></ul></li></ul><p>事务隔离级别对并发一致性问题的解决情况：</p><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">丢失修改</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">读未提交</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">读已提交</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">可重复读</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">可串行化</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td></tr></tbody></table></details><h3 id="【中级】mysql-的默认事务隔离级别是什么-为什么" tabindex="-1"><a class="header-anchor" href="#【中级】mysql-的默认事务隔离级别是什么-为什么" aria-hidden="true">#</a> 【中级】MySQL 的默认事务隔离级别是什么？为什么？</h3><details class="hint-container details"><summary>要点</summary><p>事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p><p>MySQL 中的事务功能是在存储引擎层实现的，<strong>并非所有存储引擎都支持事务功能</strong>。比如 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><p><strong>大部分数据库的默认隔离级别是“读已提交”</strong>。然而，<strong>InnoDB 的默认隔离级别是“可重复读”</strong>。这是为了兼容早期 binlog 的 statement 格式问题。如果使用可重复读以下的隔离级别，使用了 statement 格式的 binlog 会产生主从数据不一致的问题。</p><p>此外，<strong>在 InnoDB 中，可重复读隔离级别虽然不能解决幻读，但是可以很大程度的避免幻读的发生</strong>。根据不同的查询方式，分别提出了避免幻读的方案：</p><ul><li>针对<strong>快照读</strong>（普通 <code>select</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（<code>select ... for update</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>很大程度的避免幻读，不代表完全解决幻读问题，下面是两个示例：</p><ul><li>对于快照读，MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</li><li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</li></ul></details><h3 id="【高级】mysql-是如何实现事务的" tabindex="-1"><a class="header-anchor" href="#【高级】mysql-是如何实现事务的" aria-hidden="true">#</a> 【高级】MySQL 是如何实现事务的？</h3><details class="hint-container details"><summary>要点</summary><p>MySQL 主要是通过 <strong>锁</strong>、<strong>Redo Log</strong> 、<strong>Undo Log</strong>、<strong>MVCC</strong> 来实现事务。</p><ul><li>MySQL 利用**锁（行锁、间隙锁等等）**机制，<strong>控制数据的并发修改</strong>，满足事务的隔离性。</li><li><strong>Redo Log（重做日志）</strong>，它会<strong>记录事务对数据库的所有修改</strong>，当 MySQL 发生宕机或崩溃时，<strong>通过重放 redo log 就可以恢复数据</strong>，用来满足事务的持久性。</li><li><strong>Undo Log（回滚日志）</strong>，它会<strong>记录事务的反向操作</strong>，简单地说就是保存数据的历史版本，<strong>用于事务的回滚</strong>，使得事务执行失败之后可以恢复之前的样子。实现原子性和隔离性</li><li><strong>MVCC（多版本并发控制）</strong>，满足了非锁定读的需求，提高了并发度，<strong>实现了读已提交和可重复读两种隔离级别</strong>，实现了事务的隔离性。</li></ul><p>事务实现了原子性、隔离性和持久性特性后，本身就达到了一致性的目的。</p></details><h3 id="【高级】各事务隔离级别是如何实现的" tabindex="-1"><a class="header-anchor" href="#【高级】各事务隔离级别是如何实现的" aria-hidden="true">#</a> 【高级】各事务隔离级别是如何实现的？</h3><details class="hint-container details"><summary>要点</summary><p>四种隔离级别具体是如何实现的呢？</p><p>以 InnoDB 的事务实现来说明：</p><ul><li>对于“读未提交”隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于“串行化”隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于“读提交”和“可重复读”隔离级别的事务来说，它们都是通过 ReadView 来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。 <ul><li>“读提交”隔离级别是在“每个语句执行前”都会重新生成一个 ReadView</li><li>“可重复读”隔离级别是在“启动事务时”生成一个 ReadView，然后整个事务期间都在用这个 ReadView。</li></ul></li></ul></details><h3 id="【中级】什么是-mvcc" tabindex="-1"><a class="header-anchor" href="#【中级】什么是-mvcc" aria-hidden="true">#</a> 【中级】什么是 MVCC？</h3><details class="hint-container details"><summary>要点</summary><p><strong>MVCC 是 Multi Version Concurrency Control 的缩写，即“多版本并发控制”</strong>。MVCC 的设计目标是提高数据库的并发性，采用非阻塞的方式去处理读/写并发冲突，可以将其看成一种乐观锁。</p><p>不仅是 MySQL，包括 Oracle、PostgreSQL 等其他关系型数据库都实现了各自的 MVCC，实现机制没有统一标准。<strong>MVCC 是 InnoDB 存储引擎实现事务隔离级别的一种具体方式</strong>。其主要用于实现读已提交和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p></details><h3 id="【高级】mvcc-的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#【高级】mvcc-的实现原理是什么" aria-hidden="true">#</a> 【高级】MVCC 的实现原理是什么？</h3><details class="hint-container details"><summary>要点</summary><p>MVCC 的实现原理，主要基于隐式字段、UndoLog、ReadView 来实现。</p><h4 id="隐式字段" tabindex="-1"><a class="header-anchor" href="#隐式字段" aria-hidden="true">#</a> 隐式字段</h4><p>InnoDB 存储引擎中，数据表的每行记录，除了用户显示定义的字段以外，还有几个数据库隐式定义的字段：</p><ul><li><code>row_id</code> - <strong>隐藏的自增 ID</strong>。如果数据表没有指定主键，InnoDB 会自动基于 <code>row_id</code> 产生一个聚簇索引。</li><li><code>trx_id</code> - <strong>最近修改的事务 ID</strong>。事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li><li><code>roll_pointer</code> - <strong>回滚指针</strong>，指向这条记录的上一个版本。</li></ul><h4 id="undolog" tabindex="-1"><a class="header-anchor" href="#undolog" aria-hidden="true">#</a> UndoLog</h4><p>MVCC 的多版本指的是多个版本的快照，快照存储在 UndoLog 中。该日志通过回滚指针 <code>roll_pointer</code> 把一个数据行的所有快照链接起来，构成一个<strong>版本链</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242213050.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="readview" tabindex="-1"><a class="header-anchor" href="#readview" aria-hidden="true">#</a> ReadView</h4><p><strong>ReadView 就是事务进行快照读时产生的读视图（快照）</strong>。</p><p>ReadView 有四个重要的字段：</p><ul><li><code>m_ids</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”的事务 ID 列表。注意：这是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li><code>min_trx_id</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”中事务 id 最小的事务，也就是 <code>m_ids</code> 的最小值。</li><li><code>max_trx_id</code> - 这个并不是 m_ids 的最大值，而是指创建 ReadView 时当前数据库中应该给下一个事务分配的 ID 值，也就是全局事务中最大的事务 ID 值 + 1；</li><li><code>creator_trx_id</code> - 指的是创建该 ReadView 的事务的事务 ID。</li></ul><p>在创建 ReadView 后，我们可以将记录中的 trx_id 划分为三种情况：</p><ul><li>已提交事务</li><li>已启动但未提交的事务</li><li>未启动的事务</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242214504.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>ReadView 如何判断版本链中哪个版本可见？</p></blockquote><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li><code>trx_id == creator_trx_id</code> - 表示 <code>trx_id</code> 版本记录由 ReadView 所代表的当前事务产生，当然可以访问。</li><li><code>trx_id &lt; min_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之前已提交的事务生成的，当前事务可以访问。</li><li><code>trx_id &gt;= max_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之后才启动的事务生成的，当前事务不可以访问。</li><li><code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> - 需要判断 <code>trx_id</code> 是否在 <code>m_ids</code> 列表中 <ul><li>如果 <code>trx_id</code> 在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务依然活跃（未提交事务），当前事务不可以访问。</li><li>如果 <code>trx_id</code> 不在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务已提交，当前事务可以访问。</li></ul></li></ul><p>这种通过“版本链”来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p></details><h3 id="【高级】mvcc-实现了哪些隔离级别-如何实现的" tabindex="-1"><a class="header-anchor" href="#【高级】mvcc-实现了哪些隔离级别-如何实现的" aria-hidden="true">#</a> 【高级】MVCC 实现了哪些隔离级别，如何实现的？</h3><details class="hint-container details"><summary>要点</summary><p>对于“读已提交”和“可重复读”隔离级别的事务来说，它们都是通过 MVCC 的 ReadView 机制来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。</p><blockquote><p>MVCC 如何实现可重复读隔离级别</p></blockquote><p><strong>可重复读隔离级别只有在启动事务时才会创建 ReadView，然后整个事务期间都使用这个 ReadView</strong>。这样就保证了在事务期间读到的数据都是事务启动前的记录。</p><p>举个例子，假设有两个事务依次执行以下操作：</p><ul><li>初始，表中 id = 1 的 value 列值为 100。</li><li>事务 2 读取数据，value 为 100；</li><li>事务 1 将 value 设为 200；</li><li>事务 2 读取数据，value 为 100；</li><li>事务 1 提交事务；</li><li>事务 2 读取数据，value 依旧为 100；</li></ul><p>以上操作，如下图所示。T2 事务在事务过程中，是否可以看到 T1 事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242217983.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从图中不难看出：</p><ul><li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li><li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出 <code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见。</li></ul><p>综上所述，在 T2 事务中，自始至终只能看到 <code>trx_id = 100</code> 的版本记录。</p><blockquote><p>MVCC 如何实现读已提交隔离级别</p></blockquote><p><strong>读已提交隔离级别每次读取数据时都会创建一个 ReadView</strong>。这意味着，事务期间的多次读取同一条数据，前后读取的数据可能会出现不一致——因为，这期间可能有另外一个事务修改了该记录，并提交了事务。</p><p>举个例子，假设有两个事务依次执行以下操作：</p><ul><li>初始，表中 id = 1 的 value 列值为 100。</li><li>事务 2 读取数据（创建 ReadView），value 为 0；</li><li>事务 1 将 value 设为 100；</li><li>事务 2 读取数据（创建 ReadView），value 为 0；</li><li>事务 1 提交事务；</li><li>事务 2 读取数据（创建 ReadView），value 为 100；</li></ul><p>以上操作，如下图所示，T2 事务在事务过程中，是否可以看到其他事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242218464.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从图中不难看出：</p><ul><li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li><li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出第二次查询时（T1 更新未提交），<code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见；而第三次查询时（T1 更新已提交），<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中可见；</li></ul><p>综上所述，在 T2 事务中，当 T1 事务提交前，可读取到的是 <code>trx_id = 100</code> 的版本记录；当 T1 事务提交后，可读取到的是 <code>trx_id = 101</code> 的版本记录。</p><blockquote><p>MVCC + Next-Key Lock 如何解决幻读</p></blockquote><p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 <code>SELECT</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（<code>SELECT ... FOR UPDATE</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 <code>SELECT ... FOR UPDATE</code> 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。</li></ul></details><h2 id="mysql-锁" tabindex="-1"><a class="header-anchor" href="#mysql-锁" aria-hidden="true">#</a> MySQL 锁</h2><h3 id="【中级】mysql-中有哪些锁" tabindex="-1"><a class="header-anchor" href="#【中级】mysql-中有哪些锁" aria-hidden="true">#</a> 【中级】MySQL 中有哪些锁？</h3><details class="hint-container details"><summary>要点</summary><p>为了解决并发一致性问题，MySQL 支持了很多种锁来实现不同程度的隔离性，以保证数据的安全性。</p><ul><li><strong>独享锁和共享锁</strong></li><li><strong>悲观锁和乐观锁</strong></li><li><strong>全局锁</strong> - 锁定整个数据库。典型应用是全库逻辑备份。</li><li><strong>表级锁</strong><ul><li><strong>表锁</strong> - 表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。</li><li><strong>元数据锁（Metadata Lock, MDL）</strong> - 用于保护表结构变更，MDL 不需要显式使用，在访问一个表的时候会被自动加上。 <ul><li>增删改查，加读锁</li><li>结构变更，加写锁</li></ul></li><li><strong>意向锁（Intention Lock）</strong> - 表明事务打算在表中的行上获取什么类型的锁。 <ul><li><strong>意向共享锁 (IS)</strong></li><li><strong>意向排他锁 (IX)</strong></li></ul></li><li><strong>自增锁（Auto Increment Lock）</strong></li></ul></li><li><strong>行级锁</strong><ul><li><strong>记录锁（Record Lock）</strong> - 锁定索引中的单条记录。</li><li><strong>间隙锁（Gap Lock）</strong> - 锁定索引记录之间的间隙。</li><li><strong>临键锁（Next-Key Lock）</strong> - 记录锁+间隙锁的组合。</li><li><strong>插入意向锁（Insert Intention Lock）</strong> - INSERT 操作设置的间隙锁。</li></ul></li></ul></details><h3 id="【中级】独享锁-vs-共享锁" tabindex="-1"><a class="header-anchor" href="#【中级】独享锁-vs-共享锁" aria-hidden="true">#</a> 【中级】独享锁 vs. 共享锁？</h3><details class="hint-container details"><summary>要点</summary><p>InnoDB 实现标准行级锁定，根据是否独享资源，可以把锁分为两类：</p><ul><li><strong>独享锁（Exclusive）</strong>，简写为 X 锁，又称为“<strong>写锁</strong>”、“<strong>排它锁</strong>”。 <ul><li>独享锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。</li><li>使用方式：<code>SELECT ... FOR UPDATE;</code></li></ul></li><li><strong>共享锁（Shared）</strong>，简写为 S 锁，又称为“<strong>读锁</strong>”。 <ul><li>共享锁锁定的资源可以被其他用户读取，但不能修改。在进行 <code>SELECT</code> 的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。</li><li>使用方式：<code>SELECT ... LOCK IN SHARE MODE;</code></li></ul></li></ul><blockquote><p>为什么要引入读写锁机制？</p></blockquote><p>实际上，读写锁是一种通用的锁机制，并非 MySQL 的专利。在很多软件领域，都存在读写锁机制。</p><p>因为读操作本身是线程安全的，而一般业务往往又是读多写少的情况。因此，如果对读操作进行互斥，是不必要的，并且会大大降低并发访问效率。正式为了应对这种问题，产生了读写锁机制。</p><p>读写锁的特点是：<strong>读读不互斥</strong>、<strong>读写互斥</strong>、<strong>写写互斥</strong>。简言之：<strong>只要存在写锁，其他事务就不能做任何操作</strong>。</p><blockquote><p>注：InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。</p></blockquote></details><h3 id="【中级】悲观锁-vs-乐观锁" tabindex="-1"><a class="header-anchor" href="#【中级】悲观锁-vs-乐观锁" aria-hidden="true">#</a> 【中级】悲观锁 vs. 乐观锁？</h3><details class="hint-container details"><summary>要点</summary><p>基于加锁方式分类，MySQL 可以分为悲观锁和乐观锁。</p><ul><li><strong>悲观锁</strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 <ul><li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li><li>实现方式：<strong>使用数据库中的锁机制</strong>。</li></ul></li><li><strong>乐观锁</strong> - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。 <ul><li>实现方式：<strong>更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改</strong>。</li></ul></li></ul><blockquote><p>为什么要引入乐观锁？</p></blockquote><p>乐观锁也是一种通用的锁机制，在很多软件领域，都存在乐观锁机制。</p><p><strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。那么，为了提高并发度，能不能尽量不加锁呢？</p><p>乐观锁，顾名思义，就是假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。虽然不加锁，但不意味着什么都不做，而是在更新的时候，判断一下在此期间是否有其他线程更新该数据。乐观锁最常见的实现方式，是使用版本号机制或 CAS 算法（Compare And Swap）去实现。</p><p>【示例】MySQL 乐观锁示例</p><p>假设，order 表中有一个字段 status，表示订单状态：status 为 1 代表订单未支付；status 为 2 代表订单已支付。现在，要将 id 为 1 的订单状态置为已支付，则操作如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token keyword">status</span><span class="token punctuation">,</span> version <span class="token keyword">from</span> <span class="token keyword">order</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment">#{id}</span>

<span class="token keyword">update</span> <span class="token keyword">order</span>
<span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment">#{id} and version=#{version};</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乐观锁的<strong>优点</strong>是：减少锁竞争，提高并发度。</p><p>乐观锁的<strong>缺点</strong>是：</p><ul><li><strong>存在 ABA 问题</strong>。所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后又其他线程把 B 值改成了 A，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了</li><li>如果乐观锁所检查的数据存在大量锁竞争，会由于<strong>不断循环重试，产生大量的 CPU 开销</strong>。</li></ul></details><h3 id="【中级】全局锁-vs-表级锁-vs-行级锁" tabindex="-1"><a class="header-anchor" href="#【中级】全局锁-vs-表级锁-vs-行级锁" aria-hidden="true">#</a> 【中级】全局锁 vs. 表级锁 vs. 行级锁？</h3><details class="hint-container details"><summary>要点</summary><p>前文提到了，<strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。在不得不加锁的情况下，显然，加锁的范围越小，锁竞争的发生频率就越小，系统的并发程度就越高。但是，加锁也需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销，<strong>锁粒度越小，系统的锁操作开销就越大</strong>。因此，在选择锁粒度时，也需要在锁开销和并发程度之间做一个权衡。</p><p>根据加锁的范围，MySQL 的锁大致可以分为：</p><ul><li><strong>全局锁</strong> - <strong>“全局锁”会锁定整个数据库</strong>。</li><li><strong>表级锁（table lock）</strong> - <strong>“表级锁”锁定整张表</strong>。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。表级锁有： <ul><li><strong>表锁</strong> - 表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。</li><li><strong>元数据锁（MDL）</strong> - MDL 不需要显式使用，在访问一个表的时候会被自动加上。 <ul><li>增删改查，加读锁</li><li>结构变更，加写锁</li></ul></li><li><strong>意向锁（Intention Lock）</strong></li><li><strong>自增锁（AUTO-INC）</strong></li></ul></li><li><strong>行级锁（row lock）</strong> - <strong>“行级锁”锁定指定的行记录</strong>。这样其它线程还是可以对同一个表中的其它行记录进行操作。行级锁有： <ul><li><strong>记录锁（Record Lock）</strong></li><li><strong>间隙锁（Gap Lock）</strong></li><li><strong>临键锁（Next-Key Lock）</strong></li><li><strong>插入意向锁</strong></li></ul></li></ul><p>以上各种加锁粒度，在不同存储引擎中的支持情况并不相同。如：InnoDB 支持全局锁、表级锁、行级锁；而 MyISAM 只支持全局锁、表级锁。</p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p></details><h3 id="【中级】死锁是如何产生的" tabindex="-1"><a class="header-anchor" href="#【中级】死锁是如何产生的" aria-hidden="true">#</a> 【中级】死锁是如何产生的？</h3><details class="hint-container details"><summary>要点</summary><p><strong>“死锁”是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p><p>产生死锁的场景：</p><ul><li>多个事务以不同的顺序锁定资源，可能会产生死锁。</li><li>多个事务同时锁定同一个资源时，也会产生死锁。</li></ul></details><h3 id="【高级】如何避免死锁" tabindex="-1"><a class="header-anchor" href="#【高级】如何避免死锁" aria-hidden="true">#</a> 【高级】如何避免死锁？</h3><details class="hint-container details"><summary>要点</summary><p><strong>死锁的四个必要条件</strong>：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。由此可知，要想避免死锁，就要从这几个必要条件上去着手：</p><ul><li>更新表时，<strong>尽量使用主键更新</strong>，减少冲突；</li><li><strong>避免长事务</strong>，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；</li><li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li><li>在编程中<strong>尽量按照固定的顺序来处理数据库记录</strong>，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li><li>在允许幻读和不可重复读的情况下，尽量使用读已提交事务隔离级别，可以避免 Gap Lock 导致的死锁问题；</li><li>还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</li></ul></details><h3 id="【高级】如何解决死锁" tabindex="-1"><a class="header-anchor" href="#【高级】如何解决死锁" aria-hidden="true">#</a> 【高级】如何解决死锁？</h3><details class="hint-container details"><summary>要点</summary><p>当出现死锁以后，有两种策略：</p><ul><li><strong>设置事务等待锁的超时时间</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li><li><strong>开启死锁检测</strong>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，表示开启这个逻辑。</li></ul><p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，若直接把这个时间设置成一个很小的值，比如 1s，也是不可取的。当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当事务被锁时，就要查看它所依赖的线程是否被其他事务锁住，如此循环，来判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。</p></details><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,39),m={href:"https://book.douban.com/subject/23008813/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://time.geekbang.org/column/intro/139",target:"_blank",rel:"noopener noreferrer"},b={href:"https://xiaolincoding.com/mysql/",target:"_blank",rel:"noopener noreferrer"};function x(_,f){const n=s("ExternalLinkIcon");return r(),l("div",null,[g,c,t("blockquote",null,[u,t("ul",null,[t("li",null,[t("a",p,[e("MySQL 官方文档之 InnoDB 锁和事务模型"),i(n)])])])]),h,t("ul",null,[t("li",null,[t("a",m,[e("《高性能 MySQL》"),i(n)])]),t("li",null,[t("a",y,[e("极客时间教程 - MySQL 实战 45 讲"),i(n)])]),t("li",null,[t("a",b,[e("图解 MySQL 介绍"),i(n)])])])])}const L=o(d,[["render",x],["__file","index.html.vue"]]);export{L as default};
