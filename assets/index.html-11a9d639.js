const e=JSON.parse('{"key":"v-84bdc13a","path":"/pages/33d6187f/","title":"《极客时间教程 - Java 并发编程实战》笔记三","lang":"zh-CN","frontmatter":{"title":"《极客时间教程 - Java 并发编程实战》笔记三","date":"2024-08-30T08:02:52.000Z","permalink":"/pages/33d6187f/","category":["笔记","Java"],"tag":["Java","并发"],"description":"《极客时间教程 - Java 并发编程实战》笔记三 Immutability 模式：如何利用不变性解决并发问题？ 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。 快速实现具备不可变性的类","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/33d6187f/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"《极客时间教程 - Java 并发编程实战》笔记三"}],["meta",{"property":"og:description","content":"《极客时间教程 - Java 并发编程实战》笔记三 Immutability 模式：如何利用不变性解决并发问题？ 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。 快速实现具备不可变性的类"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-13T15:15:47.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2024-08-30T08:02:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-13T15:15:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《极客时间教程 - Java 并发编程实战》笔记三\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-30T08:02:52.000Z\\",\\"dateModified\\":\\"2025-09-13T15:15:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"Immutability 模式：如何利用不变性解决并发问题？","slug":"immutability-模式-如何利用不变性解决并发问题","link":"#immutability-模式-如何利用不变性解决并发问题","children":[{"level":3,"title":"快速实现具备不可变性的类","slug":"快速实现具备不可变性的类","link":"#快速实现具备不可变性的类","children":[]},{"level":3,"title":"利用享元模式避免创建重复对象","slug":"利用享元模式避免创建重复对象","link":"#利用享元模式避免创建重复对象","children":[]},{"level":3,"title":"使用 Immutability 式的注意事项","slug":"使用-immutability-式的注意事项","link":"#使用-immutability-式的注意事项","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"Copy-on-Write 模式：不是延时策略的 COW","slug":"copy-on-write-模式-不是延时策略的-cow","link":"#copy-on-write-模式-不是延时策略的-cow","children":[{"level":3,"title":"Copy-on-Write 模式的应用领域","slug":"copy-on-write-模式的应用领域","link":"#copy-on-write-模式的应用领域","children":[]},{"level":3,"title":"一个真实案例","slug":"一个真实案例","link":"#一个真实案例","children":[]}]},{"level":2,"title":"线程本地存储模式：没有共享，就没有伤害","slug":"线程本地存储模式-没有共享-就没有伤害","link":"#线程本地存储模式-没有共享-就没有伤害","children":[{"level":3,"title":"ThreadLocal 的使用方法","slug":"threadlocal-的使用方法","link":"#threadlocal-的使用方法","children":[]},{"level":3,"title":"ThreadLocal 的工作原理","slug":"threadlocal-的工作原理","link":"#threadlocal-的工作原理","children":[]},{"level":3,"title":"ThreadLocal 与内存泄露","slug":"threadlocal-与内存泄露","link":"#threadlocal-与内存泄露","children":[]}]},{"level":2,"title":"InheritableThreadLocal 与继承性","slug":"inheritablethreadlocal-与继承性","link":"#inheritablethreadlocal-与继承性","children":[]},{"level":2,"title":"Guarded Suspension 模式：等待唤醒机制的规范实现","slug":"guarded-suspension-模式-等待唤醒机制的规范实现","link":"#guarded-suspension-模式-等待唤醒机制的规范实现","children":[{"level":3,"title":"Guarded Suspension 模式","slug":"guarded-suspension-模式","link":"#guarded-suspension-模式","children":[]},{"level":3,"title":"扩展 Guarded Suspension 模式","slug":"扩展-guarded-suspension-模式","link":"#扩展-guarded-suspension-模式","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"Balking 模式：再谈线程安全的单例模式","slug":"balking-模式-再谈线程安全的单例模式","link":"#balking-模式-再谈线程安全的单例模式","children":[{"level":3,"title":"Balking 模式的经典实现","slug":"balking-模式的经典实现","link":"#balking-模式的经典实现","children":[]},{"level":3,"title":"用 volatile 实现 Balking 模式","slug":"用-volatile-实现-balking-模式","link":"#用-volatile-实现-balking-模式","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"Thread-Per-Message 模式：最简单实用的分工方法","slug":"thread-per-message-模式-最简单实用的分工方法","link":"#thread-per-message-模式-最简单实用的分工方法","children":[{"level":3,"title":"如何理解 Thread-Per-Message 模式","slug":"如何理解-thread-per-message-模式","link":"#如何理解-thread-per-message-模式","children":[]},{"level":3,"title":"用 Thread 实现 Thread-Per-Message 模式","slug":"用-thread-实现-thread-per-message-模式","link":"#用-thread-实现-thread-per-message-模式","children":[]},{"level":3,"title":"用 Fiber 实现 Thread-Per-Message 模式","slug":"用-fiber-实现-thread-per-message-模式","link":"#用-fiber-实现-thread-per-message-模式","children":[]}]},{"level":2,"title":"Worker Thread 模式：如何避免重复创建线程？","slug":"worker-thread-模式-如何避免重复创建线程","link":"#worker-thread-模式-如何避免重复创建线程","children":[{"level":3,"title":"Worker Thread 模式及其实现","slug":"worker-thread-模式及其实现","link":"#worker-thread-模式及其实现","children":[]},{"level":3,"title":"正确地创建线程池","slug":"正确地创建线程池","link":"#正确地创建线程池","children":[]},{"level":3,"title":"避免线程死锁","slug":"避免线程死锁","link":"#避免线程死锁","children":[]}]},{"level":2,"title":"两阶段终止模式：如何优雅地终止线程？","slug":"两阶段终止模式-如何优雅地终止线程","link":"#两阶段终止模式-如何优雅地终止线程","children":[{"level":3,"title":"如何理解两阶段终止模式","slug":"如何理解两阶段终止模式","link":"#如何理解两阶段终止模式","children":[]},{"level":3,"title":"用两阶段终止模式终止监控操作","slug":"用两阶段终止模式终止监控操作","link":"#用两阶段终止模式终止监控操作","children":[]},{"level":3,"title":"如何优雅地终止线程池","slug":"如何优雅地终止线程池","link":"#如何优雅地终止线程池","children":[]}]},{"level":2,"title":"生产者-消费者模式：用流水线思想提高效率","slug":"生产者-消费者模式-用流水线思想提高效率","link":"#生产者-消费者模式-用流水线思想提高效率","children":[{"level":3,"title":"生产者-消费者模式的优点","slug":"生产者-消费者模式的优点","link":"#生产者-消费者模式的优点","children":[]},{"level":3,"title":"支持批量执行以提升性能","slug":"支持批量执行以提升性能","link":"#支持批量执行以提升性能","children":[]},{"level":3,"title":"支持分阶段提交以提升性能","slug":"支持分阶段提交以提升性能","link":"#支持分阶段提交以提升性能","children":[]}]},{"level":2,"title":"设计模式模块热点问题答疑","slug":"设计模式模块热点问题答疑","link":"#设计模式模块热点问题答疑","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1757776547000,"updatedTime":1757776547000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":39.73,"words":11918},"filePathRelative":"00.笔记/01.Java/极客时间教程-Java并发编程实战笔记三.md","localizedDate":"2024年8月30日","excerpt":"<h1> 《极客时间教程 - Java 并发编程实战》笔记三</h1>\\n<h2> Immutability 模式：如何利用不变性解决并发问题？</h2>\\n<p>解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：<strong>不变性（Immutability）模式</strong>。所谓<strong>不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化</strong>。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</p>\\n<h3> 快速实现具备不可变性的类</h3>","autoDesc":true}');export{e as data};
