const e=JSON.parse('{"key":"v-56f1eb8c","path":"/pages/e98ae9d2/","title":"Java 并发之内存模型","lang":"zh-CN","frontmatter":{"title":"Java 并发之内存模型","date":"2020-12-25T18:43:11.000Z","permalink":"/pages/e98ae9d2/","category":["Java","JavaCore","并发"],"tag":["Java","JavaCore","并发","JMM","Happens-Before","内存屏障","volatile","synchronized","final","指令重排序"],"description":"Java 并发之内存模型 Java 内存模型（Java Memory Model），简称 JMM。Java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。Java 内存模型通过 屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 物理内存模型 物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 硬件处理效率存在很大差异","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/e98ae9d2/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 并发之内存模型"}],["meta",{"property":"og:description","content":"Java 并发之内存模型 Java 内存模型（Java Memory Model），简称 JMM。Java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。Java 内存模型通过 屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 物理内存模型 物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 硬件处理效率存在很大差异"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-13T09:10:08.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"JMM"}],["meta",{"property":"article:tag","content":"Happens-Before"}],["meta",{"property":"article:tag","content":"内存屏障"}],["meta",{"property":"article:tag","content":"volatile"}],["meta",{"property":"article:tag","content":"synchronized"}],["meta",{"property":"article:tag","content":"final"}],["meta",{"property":"article:tag","content":"指令重排序"}],["meta",{"property":"article:published_time","content":"2020-12-25T18:43:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-13T09:10:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 并发之内存模型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-12-25T18:43:11.000Z\\",\\"dateModified\\":\\"2025-09-13T09:10:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"物理内存模型","slug":"物理内存模型","link":"#物理内存模型","children":[{"level":3,"title":"硬件处理效率存在很大差异","slug":"硬件处理效率存在很大差异","link":"#硬件处理效率存在很大差异","children":[]},{"level":3,"title":"缓存一致性","slug":"缓存一致性","link":"#缓存一致性","children":[]},{"level":3,"title":"指令重排序","slug":"指令重排序","link":"#指令重排序","children":[]}]},{"level":2,"title":"Java 内存模型","slug":"java-内存模型","link":"#java-内存模型","children":[{"level":3,"title":"主内存和工作内存","slug":"主内存和工作内存","link":"#主内存和工作内存","children":[]},{"level":3,"title":"JMM 内存操作的问题","slug":"jmm-内存操作的问题","link":"#jmm-内存操作的问题","children":[]},{"level":3,"title":"内存间交互操作","slug":"内存间交互操作","link":"#内存间交互操作","children":[]},{"level":3,"title":"并发安全特性","slug":"并发安全特性","link":"#并发安全特性","children":[]}]},{"level":2,"title":"Happens-Before","slug":"happens-before","link":"#happens-before","children":[]},{"level":2,"title":"内存屏障","slug":"内存屏障","link":"#内存屏障","children":[]},{"level":2,"title":"Synchronized 内存语义","slug":"synchronized-内存语义","link":"#synchronized-内存语义","children":[{"level":3,"title":"synchronized 的应用","slug":"synchronized-的应用","link":"#synchronized-的应用","children":[]},{"level":3,"title":"synchronized 的原理","slug":"synchronized-的原理","link":"#synchronized-的原理","children":[]},{"level":3,"title":"synchronized 的优化","slug":"synchronized-的优化","link":"#synchronized-的优化","children":[]},{"level":3,"title":"synchronized 的误区","slug":"synchronized-的误区","link":"#synchronized-的误区","children":[]}]},{"level":2,"title":"volatile 内存语义","slug":"volatile-内存语义","link":"#volatile-内存语义","children":[{"level":3,"title":"保证线程可见性","slug":"保证线程可见性","link":"#保证线程可见性","children":[]},{"level":3,"title":"禁止指令重排序","slug":"禁止指令重排序","link":"#禁止指令重排序","children":[]},{"level":3,"title":"volatile 不保证原子性","slug":"volatile-不保证原子性","link":"#volatile-不保证原子性","children":[]},{"level":3,"title":"volatile 的应用","slug":"volatile-的应用","link":"#volatile-的应用","children":[]}]},{"level":2,"title":"final 内存语义","slug":"final-内存语义","link":"#final-内存语义","children":[]},{"level":2,"title":"long 和 double 的特殊规则","slug":"long-和-double-的特殊规则","link":"#long-和-double-的特殊规则","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1743948422000,"updatedTime":1757754608000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":2}]},"readingTime":{"minutes":42.16,"words":12648},"filePathRelative":"01.Java/01.JavaCore/05.并发/Java_并发_内存模型.md","localizedDate":"2020年12月25日","excerpt":"<h1> Java 并发之内存模型</h1>\\n<p>Java 内存模型（Java Memory Model），简称 <strong>JMM</strong>。Java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。Java 内存模型通过 <strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>。</p>\\n<h2> 物理内存模型</h2>\\n<p>物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>\\n<h3> 硬件处理效率存在很大差异</h3>","autoDesc":true}');export{e as data};
