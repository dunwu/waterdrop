const e=JSON.parse('{"key":"v-3d54f9c7","path":"/pages/8ede3b07/","title":"Java 并发面试三","lang":"zh-CN","frontmatter":{"title":"Java 并发面试三","date":"2024-07-23T07:21:03.000Z","permalink":"/pages/8ede3b07/","category":["Java","JavaCore","面试"],"tag":["Java","JavaCore","面试","并发"],"description":"Java 并发面试三 ThreadLocal ThreadLocal 有什么用？ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/8ede3b07/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 并发面试三"}],["meta",{"property":"og:description","content":"Java 并发面试三 ThreadLocal ThreadLocal 有什么用？ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-06T14:07:02.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2024-07-23T07:21:03.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-06T14:07:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 并发面试三\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-23T07:21:03.000Z\\",\\"dateModified\\":\\"2025-04-06T14:07:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[{"level":3,"title":"ThreadLocal 有什么用？","slug":"threadlocal-有什么用","link":"#threadlocal-有什么用","children":[]},{"level":3,"title":"如何使用 ThreadLocal？","slug":"如何使用-threadlocal","link":"#如何使用-threadlocal","children":[]},{"level":3,"title":"ThreadLocal 原理了解吗？","slug":"threadlocal-原理了解吗","link":"#threadlocal-原理了解吗","children":[]},{"level":3,"title":"ThreadLocal 内存泄露问题是怎么导致的？","slug":"threadlocal-内存泄露问题是怎么导致的","link":"#threadlocal-内存泄露问题是怎么导致的","children":[]}]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[{"level":3,"title":"什么是线程池？","slug":"什么是线程池","link":"#什么是线程池","children":[]},{"level":3,"title":"为什么要用线程池？","slug":"为什么要用线程池","link":"#为什么要用线程池","children":[]},{"level":3,"title":"如何创建线程池？","slug":"如何创建线程池","link":"#如何创建线程池","children":[]},{"level":3,"title":"为什么不推荐使用内置线程池？","slug":"为什么不推荐使用内置线程池","link":"#为什么不推荐使用内置线程池","children":[]},{"level":3,"title":"线程池常见参数有哪些？如何解释？","slug":"线程池常见参数有哪些-如何解释","link":"#线程池常见参数有哪些-如何解释","children":[]},{"level":3,"title":"线程池的核心线程会被回收吗？","slug":"线程池的核心线程会被回收吗","link":"#线程池的核心线程会被回收吗","children":[]},{"level":3,"title":"线程池的拒绝策略有哪些？","slug":"线程池的拒绝策略有哪些","link":"#线程池的拒绝策略有哪些","children":[]},{"level":3,"title":"如果不允许丢弃任务任务，应该选择哪个拒绝策略？","slug":"如果不允许丢弃任务任务-应该选择哪个拒绝策略","link":"#如果不允许丢弃任务任务-应该选择哪个拒绝策略","children":[]},{"level":3,"title":"CallerRunsPolicy 拒绝策略有什么风险？如何解决？","slug":"callerrunspolicy-拒绝策略有什么风险-如何解决","link":"#callerrunspolicy-拒绝策略有什么风险-如何解决","children":[]},{"level":3,"title":"线程池常用的阻塞队列有哪些？","slug":"线程池常用的阻塞队列有哪些","link":"#线程池常用的阻塞队列有哪些","children":[]},{"level":3,"title":"线程池处理任务的流程了解吗？","slug":"线程池处理任务的流程了解吗","link":"#线程池处理任务的流程了解吗","children":[]},{"level":3,"title":"线程池中线程异常后，销毁还是复用？","slug":"线程池中线程异常后-销毁还是复用","link":"#线程池中线程异常后-销毁还是复用","children":[]},{"level":3,"title":"如何给线程池命名？","slug":"如何给线程池命名","link":"#如何给线程池命名","children":[]},{"level":3,"title":"如何设定线程池的大小？","slug":"如何设定线程池的大小","link":"#如何设定线程池的大小","children":[]},{"level":3,"title":"如何动态修改线程池的参数？","slug":"如何动态修改线程池的参数","link":"#如何动态修改线程池的参数","children":[]},{"level":3,"title":"如何设计一个能够根据任务的优先级来执行的线程池？","slug":"如何设计一个能够根据任务的优先级来执行的线程池","link":"#如何设计一个能够根据任务的优先级来执行的线程池","children":[]}]},{"level":2,"title":"Future","slug":"future","link":"#future","children":[{"level":3,"title":"Future 类有什么用？","slug":"future-类有什么用","link":"#future-类有什么用","children":[]},{"level":3,"title":"Callable 和 Future 有什么关系？","slug":"callable-和-future-有什么关系","link":"#callable-和-future-有什么关系","children":[]},{"level":3,"title":"CompletableFuture 类有什么用？","slug":"completablefuture-类有什么用","link":"#completablefuture-类有什么用","children":[]}]},{"level":2,"title":"AQS","slug":"aqs","link":"#aqs","children":[{"level":3,"title":"AQS 是什么？","slug":"aqs-是什么","link":"#aqs-是什么","children":[]},{"level":3,"title":"AQS 的原理是什么？","slug":"aqs-的原理是什么","link":"#aqs-的原理是什么","children":[]},{"level":3,"title":"Semaphore 有什么用？","slug":"semaphore-有什么用","link":"#semaphore-有什么用","children":[]},{"level":3,"title":"Semaphore 的原理是什么？","slug":"semaphore-的原理是什么","link":"#semaphore-的原理是什么","children":[]},{"level":3,"title":"CountDownLatch 有什么用？","slug":"countdownlatch-有什么用","link":"#countdownlatch-有什么用","children":[]},{"level":3,"title":"CountDownLatch 的原理是什么？","slug":"countdownlatch-的原理是什么","link":"#countdownlatch-的原理是什么","children":[]},{"level":3,"title":"用过 CountDownLatch 么？什么场景下用的？","slug":"用过-countdownlatch-么-什么场景下用的","link":"#用过-countdownlatch-么-什么场景下用的","children":[]},{"level":3,"title":"CyclicBarrier 有什么用？","slug":"cyclicbarrier-有什么用","link":"#cyclicbarrier-有什么用","children":[]},{"level":3,"title":"CyclicBarrier 的原理是什么？","slug":"cyclicbarrier-的原理是什么","link":"#cyclicbarrier-的原理是什么","children":[]}]},{"level":2,"title":"虚拟线程","slug":"虚拟线程","link":"#虚拟线程","children":[]},{"level":2,"title":"案例","slug":"案例","link":"#案例","children":[{"level":3,"title":"生产者消费者模式","slug":"生产者消费者模式","link":"#生产者消费者模式","children":[]}]}],"git":{"createdTime":1743948422000,"updatedTime":1743948422000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":50.47,"words":15140},"filePathRelative":"01.Java/01.JavaCore/99.面试/Java_面试_并发（三）.md.md","localizedDate":"2024年7月23日","excerpt":"<h1> Java 并发面试三</h1>\\n<h2> ThreadLocal</h2>\\n<h3> ThreadLocal 有什么用？</h3>\\n<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>\\n<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>","autoDesc":true}');export{e as data};
