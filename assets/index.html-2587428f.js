const e=JSON.parse('{"key":"v-a05e2c06","path":"/pages/2a32dcde/","title":"RocketMQ 面试","lang":"zh-CN","frontmatter":{"title":"RocketMQ 面试","date":"2022-07-12T07:49:48.000Z","order":99,"permalink":"/pages/2a32dcde/","category":["分布式","分布式通信","MQ","RocketMQ"],"tag":["分布式","通信","MQ","RocketMQ","面试"],"description":"RocketMQ 面试 【困难】事务消息是如何工作的？ MQ 事务方案本质是利用 MQ 功能实现的本地消息表。事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。 Kafka 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。 RocketMQ 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/2a32dcde/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"RocketMQ 面试"}],["meta",{"property":"og:description","content":"RocketMQ 面试 【困难】事务消息是如何工作的？ MQ 事务方案本质是利用 MQ 功能实现的本地消息表。事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。 Kafka 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。 RocketMQ 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-19T00:24:17.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"通信"}],["meta",{"property":"article:tag","content":"MQ"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:published_time","content":"2022-07-12T07:49:48.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-19T00:24:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 面试\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-07-12T07:49:48.000Z\\",\\"dateModified\\":\\"2025-09-19T00:24:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":3,"title":"【困难】事务消息是如何工作的？","slug":"【困难】事务消息是如何工作的","link":"#【困难】事务消息是如何工作的","children":[]},{"level":3,"title":"【中等】RocketMQ 的事务消息有什么缺点？","slug":"【中等】rocketmq-的事务消息有什么缺点","link":"#【中等】rocketmq-的事务消息有什么缺点","children":[]},{"level":3,"title":"【中等】为什么 RocketMQ 不用 ZooKeeper，而是自己开发 NameServer？","slug":"【中等】为什么-rocketmq-不用-zookeeper-而是自己开发-nameserver","link":"#【中等】为什么-rocketmq-不用-zookeeper-而是自己开发-nameserver","children":[]}],"git":{"createdTime":1757776547000,"updatedTime":1758241457000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":2}]},"readingTime":{"minutes":4.98,"words":1495},"filePathRelative":"15.分布式/分布式通信/MQ/RocketMQ/RocketMQ面试.md","localizedDate":"2022年7月12日","excerpt":"<h1> RocketMQ 面试</h1>\\n<h3> 【困难】事务消息是如何工作的？</h3>\\n<p>MQ 事务方案本质是利用 MQ 功能实现的本地消息表。事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。</p>\\n<ul>\\n<li><strong>Kafka</strong> 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。</li>\\n<li><strong>RocketMQ</strong> 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</li>\\n</ul>","autoDesc":true}');export{e as data};
