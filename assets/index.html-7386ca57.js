import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as s,a,b as e,d,e as i}from"./app-1c9286fd.js";const o={},h=i('<h1 id="《极客时间教程-深入浅出-java-虚拟机》笔记" tabindex="-1"><a class="header-anchor" href="#《极客时间教程-深入浅出-java-虚拟机》笔记" aria-hidden="true">#</a> 《极客时间教程 - 深入浅出 Java 虚拟机》笔记</h1><h2 id="开篇词-jvm-一块难啃的骨头" tabindex="-1"><a class="header-anchor" href="#开篇词-jvm-一块难啃的骨头" aria-hidden="true">#</a> 开篇词：JVM，一块难啃的骨头</h2><p>略</p><h2 id="一探究竟-为什么需要-jvm-它处在什么位置" tabindex="-1"><a class="header-anchor" href="#一探究竟-为什么需要-jvm-它处在什么位置" aria-hidden="true">#</a> 一探究竟：为什么需要 JVM？它处在什么位置？</h2><p><strong>JVM</strong> - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 <code>*.java</code> 文件编译为 JVM 可理解的 <code>*.class</code> 文件（字节码）。Java 有一句著名的口号：“Write Once, Run Anywhere（一次编写，随处运行）”，JVM 正是其核心所在。实际上，JVM 针对不同的系统（Windows、Linux、MacOS）有不同的实现，目的在于用相同的字节码执行同样的结果。</p><p><strong>JRE</strong> - Java Runtime Environment 的缩写，即 Java 运行时环境。它是运行已编译 Java 程序所需的一切的软件包，主要包括 JVM、Java 类库（Class Library）、Java 命令和其他基础结构。但是，它不能用于创建新程序。</p><p><strong>JDK</strong> - Java Development Kit 的缩写，即 Java SDK。它不仅包含 JRE 的所有功能，还包含编译器 (javac) 和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><blockquote><p>总结来说，JDK、JRE、JVM 三者的关系是：JDK &gt; JRE &gt; JVM</p><p><strong>JDK = JRE + 开发/调试工具</strong></p><p><strong>JRE = JVM + Java 类库 + Java 运行库</strong></p><p><strong>JVM = 类加载系统 + 运行时内存区域 + 执行引擎</strong></p></blockquote><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504030804019.png" alt="enter image description here" tabindex="0" loading="lazy"><figcaption>enter image description here</figcaption></figure>',9),c={href:"https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre",target:"_blank",rel:"noopener noreferrer"},g=i('<h2 id="大厂面试题-你不得不掌握的-jvm-内存管理" tabindex="-1"><a class="header-anchor" href="#大厂面试题-你不得不掌握的-jvm-内存管理" aria-hidden="true">#</a> 大厂面试题：你不得不掌握的 JVM 内存管理</h2><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4VrjWAPqAuAARqnz6cigo666.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4VrjaANruFAAQKxZvgfSs652.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4VrjaAIlgaAAJKReuKXII670.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="大厂面试题-从覆盖-jdk-的类开始掌握类的加载机制" tabindex="-1"><a class="header-anchor" href="#大厂面试题-从覆盖-jdk-的类开始掌握类的加载机制" aria-hidden="true">#</a> 大厂面试题：从覆盖 JDK 的类开始掌握类的加载机制</h2><p>Java 类的完整生命周期包括以下几个阶段：</p><ul><li><strong>加载（Loading）</strong> - 将 _.java 文件转为 _.class</li><li><strong>链接（Linking）</strong><ul><li><strong>验证（Verification）</strong> - 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求</li><li><strong>准备（Preparation）</strong> - 为 static 变量在方法区分配内存并初始化为默认值</li><li><strong>解析（Resolution）</strong> - 将常量池的符号引用替换为直接引用的过程</li></ul></li><li><strong>初始化（Initialization）</strong> - 为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化</li></ul><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/CgqCHl9ZjveAemjoAAB4J1dCVDo17.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>类加载器</p><ul><li><p>Bootstrap ClassLoader - 负责加载 <code>&lt;JAVA_HOME&gt;\\lib</code> 或被 <code>-Xbootclasspath</code> 指定的路径</p></li><li><p>ExtClassLoader - 负责加载 <code>&lt;JAVA_HOME&gt;\\lib\\ext</code> 或被<code>java.ext.dir</code> 指定的路径</p></li><li><p>AppClassLoader - 负载加载 <code>classpath</code> 路径</p></li><li><p>自定义类加载器 - 继承自 <code>java.lang.ClassLoader</code></p></li></ul><p><strong>双亲委派机制</strong> - 除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4cQNeAZ4FuAABzsqSozok762.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="动手实践-从栈帧看字节码是如何在-jvm-中进行流转的" tabindex="-1"><a class="header-anchor" href="#动手实践-从栈帧看字节码是如何在-jvm-中进行流转的" aria-hidden="true">#</a> 动手实践：从栈帧看字节码是如何在 JVM 中进行流转的</h2><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/CgpOIF4ezuOAK_6bAACFY5oeX-Y174.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/CgpOIF4ezeKAHVCXAABv7rzSgXE896.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>javap - javap 是 JDK 自带的反解析工具。它的作用是将 .class 字节码文件解析成可读的文件格式。</p></li><li><p>jclasslib - jclasslib 是一个图形化的工具，能够更加直观的查看字节码中的内容。</p></li></ul><h2 id="大厂面试题-得心应手应对-oom-的疑难杂症" tabindex="-1"><a class="header-anchor" href="#大厂面试题-得心应手应对-oom-的疑难杂症" aria-hidden="true">#</a> 大厂面试题：得心应手应对 OOM 的疑难杂症</h2><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4hefWAWKFZAAMwndGjScg437.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对象生命周期判断</p><ul><li>引用计数法</li><li>可达性分析法 - GC Roots</li></ul><p>引用类型：</p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><h2 id="深入剖析-垃圾回收你真的了解吗-上" tabindex="-1"><a class="header-anchor" href="#深入剖析-垃圾回收你真的了解吗-上" aria-hidden="true">#</a> 深入剖析：垃圾回收你真的了解吗？（上）</h2><p>垃圾回收算法</p><ul><li>标记-复制 - 效率最高，但会浪费大量内存空间</li><li>标记-清除 - 效率一般，会产生大量内存碎片</li><li>标记-整理 - 效率最差，但是不会浪费空间，也消除了内存碎片</li></ul><p>GC 分代收集：年轻代 GC 使用标记-复制算法；老年代 GC 使用标记-清除算法、标记-整理算法。</p><p>常见 GC 收集器：</p><ul><li>年轻代：Serial、ParNew、Parallel</li><li>老年代：Serial Old、Parallel Old、CMS</li><li>元空间：G1、ZGC</li></ul><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4lQuiAHmINAACWihcFScA929.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>GC 收集器配置参数：</p><ul><li><strong>-XX:+UseSerialGC</strong> 年轻代和老年代都用串行收集器</li><li><strong>-XX:+UseParNewGC</strong> 年轻代使用 ParNew，老年代使用 Serial Old</li><li><strong>-XX:+UseParallelGC</strong> 年轻代使用 ParallerGC，老年代使用 Serial Old</li><li><strong>-XX:+UseParallelOldGC</strong> 新生代和老年代都使用并行收集器</li><li><strong>-XX:+UseConcMarkSweepGC</strong>，表示年轻代使用 ParNew，老年代的用 CMS</li><li><strong>-XX:+UseG1GC</strong> 使用 G1 垃圾回收器</li><li><strong>-XX:+UseZGC</strong> 使用 ZGC 垃圾回收器</li></ul><h2 id="深入剖析-垃圾回收你真的了解吗-下" tabindex="-1"><a class="header-anchor" href="#深入剖析-垃圾回收你真的了解吗-下" aria-hidden="true">#</a> 深入剖析：垃圾回收你真的了解吗？（下）</h2><ul><li>Minor GC：发生在年轻代的 GC。</li><li>Major GC：发生在老年代的 GC。</li><li>Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。</li></ul><p>CMS 垃圾回收器分为四个阶段：</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清理</li></ol><p>CMS 中都会有哪些停顿（STW）：</p><ol><li>初始标记，这部分的停顿时间较短；</li><li>Minor GC（可选），在预处理阶段对年轻代的回收，停顿由年轻代决定；</li><li>重新标记，由于 preclaen 阶段的介入，这部分停顿也较短；</li><li>Serial-Old 收集老年代的停顿，主要发生在预留空间不足的情况下，时间会持续很长；</li><li>Full GC，永久代空间耗尽时的操作，由于会有整理阶段，持续时间较长。</li></ol><h2 id="大厂面试题-有了-g1-还需要其他垃圾回收器吗" tabindex="-1"><a class="header-anchor" href="#大厂面试题-有了-g1-还需要其他垃圾回收器吗" aria-hidden="true">#</a> 大厂面试题：有了 G1 还需要其他垃圾回收器吗？</h2><p>G1 最重要的概念，其实就是 Region。它采用分而治之，部分收集的思想，尽力达到我们给它设定的停顿目标。</p><h2 id="案例实战-亿级流量高并发下如何进行估算和调优" tabindex="-1"><a class="header-anchor" href="#案例实战-亿级流量高并发下如何进行估算和调优" aria-hidden="true">#</a> 案例实战：亿级流量高并发下如何进行估算和调优</h2><p>GC 指标：</p><ul><li>系统容量（Capacity）</li><li>延迟（Latency）</li><li>吞吐量（Throughput）</li></ul><p><strong>选择垃圾回收器</strong></p><ul><li>如果你的堆大小不是很大（比如 100MB），选择串行收集器一般是效率最高的。参数：-XX:+UseSerialGC。</li><li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有 1C，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。参数：-XX:+UseSerialGC。</li><li>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。参数：-XX:+UseParallelGC。</li><li>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1、ZGC、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。参数：-XX:+UseConcMarkSweepGC、-XX:+UseG1GC、-XX:+UseZGC 等。</li></ul><h2 id="第-09-讲-案例实战-面对突如其来的-gc-问题如何下手解决" tabindex="-1"><a class="header-anchor" href="#第-09-讲-案例实战-面对突如其来的-gc-问题如何下手解决" aria-hidden="true">#</a> 第 09 讲：案例实战：面对突如其来的 GC 问题如何下手解决</h2><h2 id="第-10-讲-动手实践-自己模拟-jvm-内存溢出场景" tabindex="-1"><a class="header-anchor" href="#第-10-讲-动手实践-自己模拟-jvm-内存溢出场景" aria-hidden="true">#</a> 第 10 讲：动手实践：自己模拟 JVM 内存溢出场景</h2><h2 id="第-11-讲-动手实践-遇到问题不要慌-轻松搞定内存泄漏" tabindex="-1"><a class="header-anchor" href="#第-11-讲-动手实践-遇到问题不要慌-轻松搞定内存泄漏" aria-hidden="true">#</a> 第 11 讲：动手实践：遇到问题不要慌，轻松搞定内存泄漏</h2><p>jinfo、jstat、jstack、jhsdb（jmap）等是经常被使用的一些工具，尤其是 jmap，在分析处理内存泄漏问题的时候，是必须的。</p><h2 id="工具进阶-如何利用-mat-找到问题发生的根本原因" tabindex="-1"><a class="header-anchor" href="#工具进阶-如何利用-mat-找到问题发生的根本原因" aria-hidden="true">#</a> 工具进阶：如何利用 MAT 找到问题发生的根本原因</h2><p>MAT 是用来分析内存快照的。</p><h2 id="动手实践-让面试官刮目相看的堆外内存排查" tabindex="-1"><a class="header-anchor" href="#动手实践-让面试官刮目相看的堆外内存排查" aria-hidden="true">#</a> 动手实践：让面试官刮目相看的堆外内存排查</h2><h2 id="预警与解决-深入浅出-gc-监控与调优" tabindex="-1"><a class="header-anchor" href="#预警与解决-深入浅出-gc-监控与调优" aria-hidden="true">#</a> 预警与解决：深入浅出 GC 监控与调优</h2><h2 id="案例分析-一个高死亡率的报表系统的优化之路" tabindex="-1"><a class="header-anchor" href="#案例分析-一个高死亡率的报表系统的优化之路" aria-hidden="true">#</a> 案例分析：一个高死亡率的报表系统的优化之路</h2><h2 id="案例分析-分库分表后-我的应用崩溃了" tabindex="-1"><a class="header-anchor" href="#案例分析-分库分表后-我的应用崩溃了" aria-hidden="true">#</a> 案例分析：分库分表后，我的应用崩溃了</h2><h2 id="动手实践-从字节码看方法调用的底层实现" tabindex="-1"><a class="header-anchor" href="#动手实践-从字节码看方法调用的底层实现" aria-hidden="true">#</a> 动手实践：从字节码看方法调用的底层实现</h2><h2 id="大厂面试题-不要搞混-jmm-与-jvm" tabindex="-1"><a class="header-anchor" href="#大厂面试题-不要搞混-jmm-与-jvm" aria-hidden="true">#</a> 大厂面试题：不要搞混 JMM 与 JVM</h2><h2 id="动手实践-从字节码看并发编程的底层实现" tabindex="-1"><a class="header-anchor" href="#动手实践-从字节码看并发编程的底层实现" aria-hidden="true">#</a> 动手实践：从字节码看并发编程的底层实现</h2><h2 id="动手实践-不为人熟知的字节码指令" tabindex="-1"><a class="header-anchor" href="#动手实践-不为人熟知的字节码指令" aria-hidden="true">#</a> 动手实践：不为人熟知的字节码指令</h2><h2 id="深入剖析-如何使用-java-agent-技术对字节码进行修改" tabindex="-1"><a class="header-anchor" href="#深入剖析-如何使用-java-agent-技术对字节码进行修改" aria-hidden="true">#</a> 深入剖析：如何使用 Java Agent 技术对字节码进行修改</h2><h2 id="_23-动手实践-jit-参数配置如何影响程序运行" tabindex="-1"><a class="header-anchor" href="#_23-动手实践-jit-参数配置如何影响程序运行" aria-hidden="true">#</a> 23 动手实践：JIT 参数配置如何影响程序运行？</h2><h2 id="案例分析-大型项目如何进行性能瓶颈调优" tabindex="-1"><a class="header-anchor" href="#案例分析-大型项目如何进行性能瓶颈调优" aria-hidden="true">#</a> 案例分析：大型项目如何进行性能瓶颈调优？</h2><h2 id="未来-jvm-的历史与展望" tabindex="-1"><a class="header-anchor" href="#未来-jvm-的历史与展望" aria-hidden="true">#</a> 未来：JVM 的历史与展望</h2><h2 id="福利-常见-jvm-面试题补充" tabindex="-1"><a class="header-anchor" href="#福利-常见-jvm-面试题补充" aria-hidden="true">#</a> 福利：常见 JVM 面试题补充</h2>',63);function p(u,f){const l=n("ExternalLinkIcon");return t(),s("div",null,[h,a("blockquote",null,[a("p",null,[e("摘自 "),a("a",c,[e("stackoverflow 高票问题 - What is the difference between JDK and JRE?"),d(l)])])]),g])}const v=r(o,[["render",p],["__file","index.html.vue"]]);export{v as default};
