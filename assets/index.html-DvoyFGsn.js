import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as n,o as i}from"./app-DM5IpGMv.js";const s={};function r(l,t){return i(),e("div",null,[...t[0]||(t[0]=[n('<h1 id="设计面试" tabindex="-1"><a class="header-anchor" href="#设计面试"><span>设计面试</span></a></h1><h2 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计"><span>系统设计</span></a></h2><h3 id="【困难】如何设计一个秒杀系统-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【困难】如何设计一个秒杀系统-⭐⭐⭐"><span>【困难】如何设计一个秒杀系统？⭐⭐⭐</span></a></h3><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://time.geekbang.org/column/intro/127" target="_blank" rel="noopener noreferrer">如何设计一个秒杀系统</a></li><li><a href="https://segmentfault.com/a/1190000020970562" target="_blank" rel="noopener noreferrer">一个秒杀系统的设计思考</a></li></ul></div><p>秒杀系统所要应对的场景就是：<strong>瞬时海量请求</strong>。</p><div class="hint-container info"><p class="hint-container-title">秒杀系统的难点</p></div><ul><li><strong>高并发</strong>：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二： <ul><li>并发读：主要是读取剩余库存量以及商品信息</li><li>并发写：主要是下单后，系统写入订单记录</li></ul></li><li><strong>超卖</strong>：秒杀系统中售卖的商品一般都是性价比很高，不怎么赚钱，甚至赔钱赚哟喝的商品。一旦出现超卖现象，会给商家带来巨大的经济损失。从系统层面来看，比如某秒杀商品本来库存 100 件，但是在高并发场景下，瞬时下单量超过 100 件，处理不当，让这些下单都成功了，就会出现超卖。</li><li><strong>恶意请求</strong>：有些人为了低价购入秒杀商品，通过在多台机器上跑脚本，模拟大量用户抢商品的请求（走自己的路，让别人无路可走）。</li><li><strong>数据库崩溃</strong>：海量请求下，如果没有 MQ 削峰，没有过载保护，让所有请求都打到数据库，那么数据库基本就挂了。数据库如果挂了，也会波及其他业务，从而可能让整个系统、网站陷入瘫痪。</li><li><strong>对现有业务造成冲击</strong></li></ul><div class="hint-container info"><p class="hint-container-title">秒杀系统设计目标</p></div><p>秒杀系统架构的思考角度可以概括为：<strong>稳、准、快</strong></p><ul><li><strong>稳（高可用）</strong>：系统架构要满足高可用，系统要能撑住活动。</li><li><strong>准（一致性）</strong>：商品减库存方式非常关键，不能出现超卖。</li><li><strong>快（高性能）</strong>：整个请求链路，从前端到后端，依赖组件都要做到协同优化。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/07/29c58abfb6e7455fa3711f014fcfb352.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container info"><p class="hint-container-title">前端优化-静态页面</p></div><p>把秒杀商品页面静态化，减少查数据库的 IO 开销。然后，可以将这些静态页面做 CDN 缓存，如果项目是前后端分离的，还可以在反向代理服务器侧设置静态缓存。</p><p>如每个商品都由 ID 来标识，那么 <a href="http://item.xxx.com/item.htm?id=xxxx" target="_blank" rel="noopener noreferrer">http://item.xxx.com/item.htm?id=xxxx</a> 就可以作为唯一的 URL 标识。相应的页面可以提前做前端缓存，这样就不需要向后台查询商品信息。</p><div class="hint-container info"><p class="hint-container-title">前端优化-按钮控制</p></div><p>在秒杀活动开启时间前，下单按钮禁用。</p><p>此外，按钮一旦点击之后，禁用一段时间，防止有人疯狂输出。</p><div class="hint-container info"><p class="hint-container-title">后端优化-限流、熔断、降级、隔离</p></div><p>秒杀活动，本质上还是一个营销活动，性质和打折、促销一样。</p><p>秒杀系统设计底线原则，是不应该影响现有业务。所以，为了避免防不胜防，百密一疏的情况下，秒杀系统崩了。</p><ul><li><strong>隔离</strong>：将秒杀系统、数据与其他正常业务隔离。彼此隔离，自然互不影响。</li><li><strong>限流</strong>：设置阈值，超过阈值，拒绝请求。防止数据库被打死。</li><li><strong>降级</strong>：保证核心业务继续工作，非核心业务各安天命。</li><li><strong>熔断</strong>：不要影响别的系统。</li></ul><div class="hint-container info"><p class="hint-container-title">后端优化-多级缓存</p></div><p>缓存要预热，避免瞬间流量冲击。</p><p>此外，防止雪崩、穿透、击穿问题的常规处理要做好。</p><p>缓存也要保证高可用。</p><div class="hint-container info"><p class="hint-container-title">后端优化-流量削峰</p></div><p>削峰的思路：排队、答题、分层过滤。</p><ul><li>排队：用消息队列来缓冲瞬时流量的方案。但是，消息队列自身也有上限，如果积压过多，也会处理不了。</li><li>答题（摇一摇）：可以限制秒杀器并延缓请求。</li><li>分层过滤：采用漏斗式的设计尽可能拦截无效请求。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/07/a2edeebfcfca47c0a91d64430927dd65.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container info"><p class="hint-container-title">后端优化-减库存</p></div><p><strong>恶意下单</strong></p><p>恶意下单的解决方案还是要结合安全和反作弊措施来制止：</p><ul><li>识别频繁下单不付款或重复下单不付款的卖家，阻断其下单。</li><li>限制个人购买数</li></ul><p><strong>避免超卖</strong></p><p>减库存在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（Cache）中，可以大大提升读性能。</p><div class="hint-container info"><p class="hint-container-title">后端优化-URL 动态化</p></div><p>通过 MD5 之类的加密算法加密随机的字符串去做 url，然后通过前端代码获取 url 后台校验才能通过。</p><h3 id="【困难】如何设计一个-rpc-框架-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【困难】如何设计一个-rpc-框架-⭐⭐"><span>【困难】如何设计一个 RPC 框架？⭐⭐</span></a></h3><p>设计一个 RPC 框架，可以自下而上梳理一下所需要的能力：</p><ul><li>通信传输模块：RPC 本质上就是一个远程调用，那肯定就需要通过网络来传输数据。</li><li>协议模块：传输的数据如何定义，就需要通过协议和序列化方式来确定。此外，为了减少传输数据的大小，可以加入压缩功能。</li><li>代理模块：为了屏蔽用户的感知，让用户更聚焦于自身业务，需要引入动态代理来托管远程调用。</li></ul><p>以上，是一个 RPC 框架的基础能力，使用于 P2P 场景。</p><p>但是，如果面对集群模式，以上能力就不够了。同一个服务可能有多个提供者。消费者选择调用哪个提供者？消费者怎么找到提供者的访问地址？请求提供者失败了如何处理？这些都依赖于服务治理的能力。</p><p>服务治理，需要很多个模块的能力：服务发现、负载均衡、路由、容错、配置挂历等。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/8a2e9f49d4ca48a0bbb5f922a73b2839.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>具备了这些能力就万事大吉了吗？RPC 框架很难一开始就面面俱到，但作为基础能力，在实际应用中，难免会有定制化的要求。这就要求 RPC 框架具备良好的扩展性。</p><p>通常来说，<strong>框架软件可以通过 SPI 技术来实现微内核+插件架构</strong>。根据依赖倒置原则，框架应该先将每个功能点都抽象成接口，并提供默认实现。然后，利用 SPI 机制，可以动态地为某个接口寻找服务实现。</p><p>加上了插件功能之后，我们的 RPC 框架就包含了两大核心体系——核心功能体系与插件体系，如下图所示：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/e6c2943b16b24c6393caa2cf4a6dd7f6.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【困难】如何设计一个-mq-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【困难】如何设计一个-mq-⭐⭐"><span>【困难】如何设计一个 MQ？⭐⭐</span></a></h3><div class="hint-container info"><p class="hint-container-title">消息模型设计——存什么？</p></div><table><thead><tr><th style="text-align:left;">模型</th><th style="text-align:left;">特点</th><th style="text-align:left;">适用场景</th><th style="text-align:left;">代表产品</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>点对点（Queue）</strong></td><td style="text-align:left;">一条消息只被一个消费者消费</td><td style="text-align:left;">任务队列</td><td style="text-align:left;">Kafka、RabbitMQ</td></tr><tr><td style="text-align:left;"><strong>发布订阅（Topic）</strong></td><td style="text-align:left;">一条消息被所有订阅者消费</td><td style="text-align:left;">事件广播</td><td style="text-align:left;">Kafka、RocketMQ</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">存储设计——放哪儿？</p></div><blockquote><p><strong>记忆点：</strong> <strong>顺序写 + 分段存储 + 索引 + 刷盘策略</strong></p></blockquote><p><strong>核心策略</strong>：</p><ul><li><strong>顺序写（性能关键）</strong>：一般采用日志文件存储，所有消息顺序追加，不分 Topic。</li><li><strong>分段存储</strong>：每个文件固定大小（如 1GB），写满后建新文件</li><li><strong>索引机制</strong>：一般记录消息在日志中的 Offset。</li><li><strong>刷盘策略</strong><ul><li><strong>同步刷盘</strong>：消息落盘才返回成功（安全）</li><li><strong>异步刷盘</strong>：先写内存，批量刷盘（性能）</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">推拉模型设计——怎么取？</p></div><table><thead><tr><th style="text-align:left;">模式</th><th style="text-align:left;">特点</th><th style="text-align:left;">实现方式</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Push</strong></td><td style="text-align:left;">Broker 主动推，实时性高</td><td style="text-align:left;">长连接推送（易压垮消费端）</td></tr><tr><td style="text-align:left;"><strong>Pull</strong></td><td style="text-align:left;">消费端主动拉，控制性强</td><td style="text-align:left;">定时拉取（延迟可调）</td></tr><tr><td style="text-align:left;"><strong>Long Polling</strong></td><td style="text-align:left;">拉不到就等一会儿</td><td style="text-align:left;">综合两者优点</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">高可用设计——挂了怎么办？</p></div><blockquote><p><strong>记忆点：</strong> <strong>主从复制 + 故障转移 + 多副本</strong></p></blockquote><ul><li>复制（Kafka/RocketMQ） <ul><li>Master: 处理读写</li><li>Slave: 从 Master 同步数据，Master 挂掉后接管</li></ul></li><li>多副本（Kafka） <ul><li>每个 Partition 有多个 Replica，Leader 负责读写</li><li>ISR 机制保证数据一致性</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">可靠性设计——消息不丢不重</p></div><blockquote><p><strong>记忆点：</strong> <strong>ACK 机制 + 重试 + 死信队列</strong></p></blockquote><p><strong>关键机制</strong>：</p><ul><li><strong>生产者 ACK</strong>：发送后等待 Broker 确认</li><li><strong>消费者 ACK</strong>：处理完才提交 offset</li><li><strong>重试队列</strong>：消费失败的消息重试 N 次</li><li><strong>死信队列</strong>：超过重试次数，人工介入</li></ul><div class="hint-container info"><p class="hint-container-title">性能设计——如何快</p></div><table><thead><tr><th style="text-align:left;">优化项</th><th style="text-align:left;">做法</th><th style="text-align:left;">效果</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>分区</strong></td><td style="text-align:left;">分而治之+负载均衡</td><td style="text-align:left;">使负载在集群中尽量均衡</td></tr><tr><td style="text-align:left;"><strong>零拷贝</strong></td><td style="text-align:left;">使用 mmap 或 sendfile</td><td style="text-align:left;">减少数据拷贝次数</td></tr><tr><td style="text-align:left;"><strong>页缓存</strong></td><td style="text-align:left;">充分利用 OS Page Cache</td><td style="text-align:left;">读写性能提升</td></tr><tr><td style="text-align:left;"><strong>批处理</strong></td><td style="text-align:left;">批量发送、批量刷盘</td><td style="text-align:left;">TPS 大幅提升</td></tr><tr><td style="text-align:left;"><strong>压缩</strong></td><td style="text-align:left;">消息体压缩（gzip/lz4）</td><td style="text-align:left;">网络带宽节省</td></tr></tbody></table><h3 id="【中等】如何设计一个短链服务-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】如何设计一个短链服务-⭐⭐"><span>【中等】如何设计一个短链服务？⭐⭐</span></a></h3><div class="hint-container info"><p class="hint-container-title">功能设计</p></div><blockquote><p>要点：生成、存储、重定向</p></blockquote><p><strong>生成：长链变短码</strong></p><p>生成短链的方案：</p><ul><li><strong>哈希</strong>：对长链接进行哈希（如 <code>MD5</code>），得到一个32位字符串。</li><li><strong>自增 ID</strong>：用一个中心服务（如 Redis）生成自增数字 ID（如：100001, 100002）。</li></ul><p>短链不够短，可以采用转码：把数值转成 <strong>62 进制</strong>（用光所有数字+大小写字母）。例如 ID <code>100001</code> -&gt; 短码 <code>aB3</code>。</p><p><strong>存储：写 DB，读 Cache</strong></p><ul><li><strong>写路径</strong>：<code>长链接 -&gt; 发号器拿 ID -&gt; 转短码 -&gt; 存 MySQL（落盘）</code></li><li><strong>读路径（关键）</strong>： <ul><li><strong>第一步</strong>：查 <strong>Redis</strong>（缓存），有就直接用。</li><li><strong>第二步</strong>：Redis 没有，查 <strong>MySQL</strong>（数据库）。</li><li><strong>第三步</strong>：查到后，<strong>回写 Redis</strong>，下次就快了。</li></ul></li></ul><p><strong>重定向：301 还是 302？</strong></p><ul><li><strong>301（永久）</strong>： <ul><li><em>特点</em>：浏览器会记住，下次不访问短链服务器了。</li><li><em>缺点</em>：<strong>没法统计点击次数</strong>。</li></ul></li><li><strong>302（临时）</strong>： <ul><li><em>特点</em>：每次都先找短链服务器，再跳转。</li><li><em>优点</em>：<strong>可以精确计数</strong>（点了几次，谁点的）。</li><li><strong>结论：推荐 302</strong>，为了数据和灵活性。</li></ul></li></ul><p>性能设计</p><ul><li><strong>缓存</strong>：缓存挡住 99%的读请求，不让流量打垮 DB。</li><li><strong>预发号</strong>：短链生成服务不要每次都找发号器，而是一次性生成一批短链（比如 1000 个）放本地内存，用完了再拿。减少对发号器的压力。</li><li><strong>布隆过滤器</strong>： <ul><li>如果有人恶意输入不存在的短码（如 <code>aaaaaa</code>），系统会先去查 Redis 和 DB，造成<strong>缓存穿透</strong>。</li><li><strong>布隆过滤器</strong>像一个前置的“筛查员”，快速判断这个短码<strong>肯定不存在</strong>，直接拦截掉，保护后端。</li></ul></li></ul><h3 id="【中等】如何实现一个订单超时取消功能" tabindex="-1"><a class="header-anchor" href="#【中等】如何实现一个订单超时取消功能"><span>【中等】如何实现一个订单超时取消功能？</span></a></h3><p>本质是一个延迟任务调度问题。主流实现方案有：</p><ul><li><strong>定时任务扫描</strong></li><li><strong>延迟消息队列</strong>：底层采用<strong>时间轮</strong>实现。</li></ul><h3 id="如何实现一个分布式单例对象" tabindex="-1"><a class="header-anchor" href="#如何实现一个分布式单例对象"><span>如何实现一个分布式单例对象？</span></a></h3><p>要让一个对象在分布式环境下全局唯一，需要满足两个条件：</p><ul><li><strong>进程内单例</strong>：在每台机器上，这个对象只初始化一次（本地单例）。</li><li><strong>进程间互斥</strong>：在整个集群中，只允许<strong>一台机器</strong>的这个对象真正工作，其他机器的对象处于**“待命”<strong>或</strong>“禁用”**状态。</li></ul><p>实现思路分为两步：</p><ol><li>用分布式锁控制创建过程，保证同一时刻只有一个进程能创建。</li><li>把对象存到外部存储，让所有进程都能访问到。</li></ol><h3 id="【困难】如何设计一个分布式锁" tabindex="-1"><a class="header-anchor" href="#【困难】如何设计一个分布式锁"><span>【困难】如何设计一个分布式锁？</span></a></h3><p>参考：<a href="https://dunwu.github.io/waterdrop/pages/808cce55/#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" target="_blank" rel="noopener noreferrer">分布式锁</a></p><h3 id="【中等】如何实现接口每分钟调用统计功能" tabindex="-1"><a class="header-anchor" href="#【中等】如何实现接口每分钟调用统计功能"><span>【中等】如何实现接口每分钟调用统计功能？</span></a></h3><blockquote><p>要点：记、存、看</p></blockquote><div class="hint-container info"><p class="hint-container-title">记（数据埋点）</p></div><p>拦截接口调用（拦截器、过滤器或AOP），记录每次请求。</p><ul><li><strong>关键信息</strong>： <ul><li><strong>接口名</strong>：<code>/api/user</code></li><li><strong>时间桶</strong>：当前时间的分钟级窗口，例如 <code>2026-02-26 14:00</code></li></ul></li><li><strong>操作</strong>：每来一次请求，就给对应的“接口+分钟”计数器加1。</li></ul><div class="hint-container info"><p class="hint-container-title">存（数据存储）</p></div><p>统计的核心是：<strong>写入极其频繁（每次请求都要写），读取相对低频（每分钟/每小时看一次）。</strong></p><p><strong>推荐方案：Redis Hash</strong>：</p><ul><li><strong>数据结构</strong>：用 Redis 的 Hash。 <ul><li><strong>Key</strong>：统计日期+分钟，如 <code>stats:20260226:1400</code></li><li><strong>Field</strong>：接口名，如 <code>/api/user</code></li><li><strong>Value</strong>：调用次数（整数）</li></ul></li><li><strong>操作</strong>：每次请求执行 <code>HINCRBY stats:20260226:1400 /api/user 1</code></li><li><strong>优点</strong>： <ul><li><strong>极高性能</strong>：内存操作，原子递增。</li><li><strong>结构清晰</strong>：一个 Key 存一分钟的所有接口数据。</li><li><strong>自动过期</strong>：可以给 Key 设置过期时间（比如保留 7 天），自动清理旧数据。</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">看（数据展示）</p></div><p>从存储中读取数据并展示出来。</p><ul><li><strong>查询实时分钟数据</strong>：直接 <code>HGETALL stats:20260226:1400</code>，拿到这一分钟所有接口的计数。</li><li><strong>查询历史趋势</strong>：遍历多个分钟 Key，聚合出接口的调用趋势。</li><li><strong>可视化</strong>：可以对接 Grafana，或自己写一个简单的接口返回 JSON 数据供前端图表展示。</li></ul><p><strong>记忆点</strong>：<strong>“Redis Hash 来计数，每分钟一个 Key，Field 是接口，Value 是次数。”</strong></p><h3 id="如何设计一个文件上传系统" tabindex="-1"><a class="header-anchor" href="#如何设计一个文件上传系统"><span>如何设计一个文件上传系统？</span></a></h3><h3 id="如何设计一个分布式-id-发号器" tabindex="-1"><a class="header-anchor" href="#如何设计一个分布式-id-发号器"><span>如何设计一个分布式 ID 发号器？</span></a></h3><h3 id="什么是限流-限流算法有哪些-怎么实现的" tabindex="-1"><a class="header-anchor" href="#什么是限流-限流算法有哪些-怎么实现的"><span>什么是限流？限流算法有哪些？怎么实现的？</span></a></h3><h3 id="如何设计一个点赞系统" tabindex="-1"><a class="header-anchor" href="#如何设计一个点赞系统"><span>如何设计一个点赞系统？</span></a></h3><h3 id="即时通讯项目中怎么实现历史消息的下拉分页加载" tabindex="-1"><a class="header-anchor" href="#即时通讯项目中怎么实现历史消息的下拉分页加载"><span>即时通讯项目中怎么实现历史消息的下拉分页加载？</span></a></h3><h3 id="hashmap-是不是线程安全的-如果如何来实现一个线程安全的-hashmap-你要怎么设计-如果不用加锁你要怎么设计" tabindex="-1"><a class="header-anchor" href="#hashmap-是不是线程安全的-如果如何来实现一个线程安全的-hashmap-你要怎么设计-如果不用加锁你要怎么设计"><span>HashMap 是不是线程安全的？如果如何来实现一个线程安全的 HashMap 你要怎么设计？如果不用加锁你要怎么设计？</span></a></h3><h3 id="如何设计一个购物车功能" tabindex="-1"><a class="header-anchor" href="#如何设计一个购物车功能"><span>如何设计一个购物车功能？</span></a></h3><h3 id="怎么设计电商系统的订单数据同步方案-同步到数仓-要求数据准确、性能高" tabindex="-1"><a class="header-anchor" href="#怎么设计电商系统的订单数据同步方案-同步到数仓-要求数据准确、性能高"><span>怎么设计电商系统的订单数据同步方案（同步到数仓）？要求数据准确、性能高</span></a></h3><h3 id="设计一个实时数据同步系统-将-mysql-数据实时同步到数据仓库" tabindex="-1"><a class="header-anchor" href="#设计一个实时数据同步系统-将-mysql-数据实时同步到数据仓库"><span>设计一个实时数据同步系统，将 MySQL 数据实时同步到数据仓库？</span></a></h3><h3 id="如何设计一个高可用的数据同步系统-需要考虑哪些容错机制" tabindex="-1"><a class="header-anchor" href="#如何设计一个高可用的数据同步系统-需要考虑哪些容错机制"><span>如何设计一个高可用的数据同步系统？需要考虑哪些容错机制？</span></a></h3><h3 id="如何设计一个-api-网关-需要考虑哪些核心功能-如何实现动态路由和限流" tabindex="-1"><a class="header-anchor" href="#如何设计一个-api-网关-需要考虑哪些核心功能-如何实现动态路由和限流"><span>如何设计一个 API 网关，需要考虑哪些核心功能？如何实现动态路由和限流？</span></a></h3><h3 id="api-网关如何实现接口版本管理-如果要同时支持-v1、v2、v3-多个版本的接口-你会怎么设计" tabindex="-1"><a class="header-anchor" href="#api-网关如何实现接口版本管理-如果要同时支持-v1、v2、v3-多个版本的接口-你会怎么设计"><span>API 网关如何实现接口版本管理？如果要同时支持 v1、v2、v3 多个版本的接口，你会怎么设计？</span></a></h3><h3 id="网关层如何防止接口重放攻击-如果攻击者抓取了请求包进行重放-你如何识别和拦截" tabindex="-1"><a class="header-anchor" href="#网关层如何防止接口重放攻击-如果攻击者抓取了请求包进行重放-你如何识别和拦截"><span>网关层如何防止接口重放攻击？如果攻击者抓取了请求包进行重放，你如何识别和拦截？</span></a></h3><h3 id="微服务架构中-如何设计一个配置中心-配置变更后如何实时通知各个服务" tabindex="-1"><a class="header-anchor" href="#微服务架构中-如何设计一个配置中心-配置变更后如何实时通知各个服务"><span>微服务架构中，如何设计一个配置中心？配置变更后如何实时通知各个服务？</span></a></h3><h3 id="如果配置中心挂了-各个微服务应该如何保证可用性-你会设计什么降级策略" tabindex="-1"><a class="header-anchor" href="#如果配置中心挂了-各个微服务应该如何保证可用性-你会设计什么降级策略"><span>如果配置中心挂了，各个微服务应该如何保证可用性？你会设计什么降级策略？</span></a></h3><h3 id="电商系统中-用户下单后如何保证订单、库存、支付三个服务的数据一致性-请设计一个分布式事务方案" tabindex="-1"><a class="header-anchor" href="#电商系统中-用户下单后如何保证订单、库存、支付三个服务的数据一致性-请设计一个分布式事务方案"><span>电商系统中，用户下单后如何保证订单、库存、支付三个服务的数据一致性？请设计一个分布式事务方案</span></a></h3><h3 id="如果如何实现一个分布式事务的补偿机制-应该注意哪些问题-补偿失败了怎么办" tabindex="-1"><a class="header-anchor" href="#如果如何实现一个分布式事务的补偿机制-应该注意哪些问题-补偿失败了怎么办"><span>如果如何实现一个分布式事务的补偿机制，应该注意哪些问题？补偿失败了怎么办？</span></a></h3><h3 id="分布式缓存中-如何实现一致性-hash-算法-相比普通-hash-它解决了什么问题" tabindex="-1"><a class="header-anchor" href="#分布式缓存中-如何实现一致性-hash-算法-相比普通-hash-它解决了什么问题"><span>分布式缓存中，如何实现一致性 Hash 算法？相比普通 Hash，它解决了什么问题？</span></a></h3><h3 id="如何设计一个灰度发布系统-如何控制流量逐步切换到新版本" tabindex="-1"><a class="header-anchor" href="#如何设计一个灰度发布系统-如何控制流量逐步切换到新版本"><span>如何设计一个灰度发布系统？如何控制流量逐步切换到新版本？</span></a></h3><h3 id="如何实现一个单点登录-sso-系统-如果有多个子系统-用户只需登录一次即可访问所有系统" tabindex="-1"><a class="header-anchor" href="#如何实现一个单点登录-sso-系统-如果有多个子系统-用户只需登录一次即可访问所有系统"><span>如何实现一个单点登录（SSO）系统？如果有多个子系统，用户只需登录一次即可访问所有系统</span></a></h3><h3 id="sso-系统中-如果认证中心挂了怎么办-如何保证已登录用户不受影响" tabindex="-1"><a class="header-anchor" href="#sso-系统中-如果认证中心挂了怎么办-如何保证已登录用户不受影响"><span>SSO 系统中，如果认证中心挂了怎么办？如何保证已登录用户不受影响？</span></a></h3><h3 id="如何设计一个接口签名验证机制-防止参数被篡改和重放攻击" tabindex="-1"><a class="header-anchor" href="#如何设计一个接口签名验证机制-防止参数被篡改和重放攻击"><span>如何设计一个接口签名验证机制？防止参数被篡改和重放攻击？</span></a></h3><h3 id="接口中的敏感数据-如身份证号、手机号-应该如何加密传输和存储" tabindex="-1"><a class="header-anchor" href="#接口中的敏感数据-如身份证号、手机号-应该如何加密传输和存储"><span>接口中的敏感数据（如身份证号、手机号）应该如何加密传输和存储？</span></a></h3><h3 id="加密后的数据怎么支持模糊搜索" tabindex="-1"><a class="header-anchor" href="#加密后的数据怎么支持模糊搜索"><span>加密后的数据怎么支持模糊搜索？</span></a></h3><h3 id="如何防止接口被恶意刷量-除了限流-还有哪些防护手段" tabindex="-1"><a class="header-anchor" href="#如何防止接口被恶意刷量-除了限流-还有哪些防护手段"><span>如何防止接口被恶意刷量？除了限流，还有哪些防护手段？</span></a></h3><h3 id="如何实现一个滑动验证码功能-如何防止被机器识别破解" tabindex="-1"><a class="header-anchor" href="#如何实现一个滑动验证码功能-如何防止被机器识别破解"><span>如何实现一个滑动验证码功能？如何防止被机器识别破解？</span></a></h3><h3 id="短信验证码如何防止被恶意轰炸-如果有人不断请求发送验证码-你会如何限制" tabindex="-1"><a class="header-anchor" href="#短信验证码如何防止被恶意轰炸-如果有人不断请求发送验证码-你会如何限制"><span>短信验证码如何防止被恶意轰炸？如果有人不断请求发送验证码，你会如何限制？</span></a></h3><h3 id="什么是死信队列-在什么场景下会用到-如何设计死信队列的处理机制" tabindex="-1"><a class="header-anchor" href="#什么是死信队列-在什么场景下会用到-如何设计死信队列的处理机制"><span>什么是死信队列？在什么场景下会用到？如何设计死信队列的处理机制？</span></a></h3><h3 id="如何实现微信扫码登录" tabindex="-1"><a class="header-anchor" href="#如何实现微信扫码登录"><span>如何实现微信扫码登录？</span></a></h3><h3 id="如何设计一个排行榜功能" tabindex="-1"><a class="header-anchor" href="#如何设计一个排行榜功能"><span>如何设计一个排行榜功能？</span></a></h3><p>可以使用 Redis 的 zset 数据类型来实现。</p><h3 id="如何设计一个点赞功能" tabindex="-1"><a class="header-anchor" href="#如何设计一个点赞功能"><span>如何设计一个点赞功能？</span></a></h3><p>点赞功能的核心操作是：</p><ul><li>点赞</li><li>取消点赞</li><li>查看点赞列表</li></ul><p>本质是一个按时间排序的去重集合，可以使用 Redis 的 zset 数据类型来实现。</p><h3 id="如何在-10-亿个数据中找到最大的-1-万个" tabindex="-1"><a class="header-anchor" href="#如何在-10-亿个数据中找到最大的-1-万个"><span>如何在 10 亿个数据中找到最大的 1 万个？</span></a></h3><p>构建容量大小为 1 万的堆，每次从 10 亿数据中读 1 万条数据，写入最小堆，循环直至读完所有数据。最终，还留存在最小堆中的数据就是 TOP 10000</p><h3 id="有几台机器存储着几亿的淘宝搜索日志-假设你只有一台-2g-的电脑-如何选出搜索热度最高的十个关键词" tabindex="-1"><a class="header-anchor" href="#有几台机器存储着几亿的淘宝搜索日志-假设你只有一台-2g-的电脑-如何选出搜索热度最高的十个关键词"><span>有几台机器存储着几亿的淘宝搜索日志，假设你只有一台 2g 的电脑，如何选出搜索热度最高的十个关键词？</span></a></h3><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h2><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://www.mianshiya.com/bank/1776477775448772610?current=1&amp;pageSize=20" target="_blank" rel="noopener noreferrer">面试鸭 Java 后端面试题</a></li><li><a href="https://www.mianshiya.com/bank/1772565012490067970?current=1&amp;pageSize=20&amp;mark=3" target="_blank" rel="noopener noreferrer">后端经典面试题合集</a></li></ul>',145)])])}const d=a(s,[["render",r]]),p=JSON.parse('{"path":"/pages/fac907c8/","title":"设计面试","lang":"zh-CN","frontmatter":{"title":"设计面试","date":"2025-09-13T23:04:28.000Z","categories":["设计"],"tags":["设计","面试"],"permalink":"/pages/fac907c8/","description":"设计面试 系统设计 【困难】如何设计一个秒杀系统？⭐⭐⭐ 扩展 如何设计一个秒杀系统 一个秒杀系统的设计思考 秒杀系统所要应对的场景就是：瞬时海量请求。 秒杀系统的难点 高并发：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二： 并发读：主要是读取剩余库存量以及商品信息 并发写：主要是下单后，系统写入订单记录 超卖：秒杀系统中售卖的商品一般都是...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计面试\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/07/29c58abfb6e7455fa3711f014fcfb352.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/07/a2edeebfcfca47c0a91d64430927dd65.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/8a2e9f49d4ca48a0bbb5f922a73b2839.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/e6c2943b16b24c6393caa2cf4a6dd7f6.jpg\\"],\\"datePublished\\":\\"2025-09-13T23:04:28.000Z\\",\\"dateModified\\":\\"2026-02-27T23:52:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/fac907c8/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"设计面试"}],["meta",{"property":"og:description","content":"设计面试 系统设计 【困难】如何设计一个秒杀系统？⭐⭐⭐ 扩展 如何设计一个秒杀系统 一个秒杀系统的设计思考 秒杀系统所要应对的场景就是：瞬时海量请求。 秒杀系统的难点 高并发：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二： 并发读：主要是读取剩余库存量以及商品信息 并发写：主要是下单后，系统写入订单记录 超卖：秒杀系统中售卖的商品一般都是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/07/29c58abfb6e7455fa3711f014fcfb352.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-27T23:52:15.000Z"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"设计"}],["meta",{"property":"article:published_time","content":"2025-09-13T23:04:28.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-27T23:52:15.000Z"}]]},"git":{"createdTime":1757896161000,"updatedTime":1772236335000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":3,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":14.81,"words":4442},"filePathRelative":"03.设计/设计面试.md","excerpt":"\\n<h2>系统设计</h2>\\n<h3>【困难】如何设计一个秒杀系统？⭐⭐⭐</h3>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">扩展</p>\\n<ul>\\n<li><a href=\\"https://time.geekbang.org/column/intro/127\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">如何设计一个秒杀系统</a></li>\\n<li><a href=\\"https://segmentfault.com/a/1190000020970562\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一个秒杀系统的设计思考</a></li>\\n</ul>\\n</div>","autoDesc":true}');export{d as comp,p as data};
