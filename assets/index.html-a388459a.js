import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as i,c as l,a as e,b as n,d as s,e as o}from"./app-f29527f5.js";const t={},d=o('<h1 id="docker-快速入门" tabindex="-1"><a class="header-anchor" href="#docker-快速入门" aria-hidden="true">#</a> Docker 快速入门</h1><h2 id="一、docker-的简介" tabindex="-1"><a class="header-anchor" href="#一、docker-的简介" aria-hidden="true">#</a> 一、Docker 的简介</h2><h3 id="什么是-docker" tabindex="-1"><a class="header-anchor" href="#什么是-docker" aria-hidden="true">#</a> 什么是 Docker</h3><blockquote><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong></p></blockquote><p>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h3 id="为什么需要-docker" tabindex="-1"><a class="header-anchor" href="#为什么需要-docker" aria-hidden="true">#</a> 为什么需要 Docker</h3>',8),p=o("<li><strong>更高效的利用系统资源</strong> - 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</li><li><strong>更快速的启动时间</strong> - 传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</li><li><strong>一致的运行环境</strong> - 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</li>",3),u=e("strong",null,"持续交付和部署",-1),h={href:"https://zh.wikipedia.org/wiki/DevOps",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"Docker",-1),b={href:"https://yeasy.gitbooks.io/docker_practice/image/dockerfile",target:"_blank",rel:"noopener noreferrer"},m={href:"https://en.wikipedia.org/wiki/Continuous_integration",target:"_blank",rel:"noopener noreferrer"},g={href:"https://en.wikipedia.org/wiki/Continuous_delivery",target:"_blank",rel:"noopener noreferrer"},v={href:"https://yeasy.gitbooks.io/docker_practice/image/build.html",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"Dockerfile",-1),f=e("li",null,[e("strong",null,"更轻松的迁移"),n(" - 由于 "),e("code",null,"Docker"),n(" 确保了执行环境的一致性，使得应用的迁移更加容易。"),e("code",null,"Docker"),n(" 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。")],-1),D=e("strong",null,"更轻松的维护和扩展",-1),x=e("code",null,"Docker",-1),q=e("code",null,"Docker",-1),y={href:"https://hub.docker.com/search/?type=image&image_filter=official",target:"_blank",rel:"noopener noreferrer"},w=o('<figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/os/docker/containers-and-vm.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="docker-的主要用途" tabindex="-1"><a class="header-anchor" href="#docker-的主要用途" aria-hidden="true">#</a> Docker 的主要用途</h3><p>Docker 提供了被称为容器的松散隔离环境，在环境中可以打包和运行应用程序。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负载，而是直接在主机的内核中运行。这意味着您可以在给定的硬件组合上运行更多容器，而不是使用虚拟机。你甚至可以在实际上是虚拟机的主机中运行 Docker 容器！</p><p>Docker 的主要用途，目前有三大类。</p><ul><li>**提供一次性的环境。**比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>**提供弹性的云服务。**因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>**组建微服务架构。**通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ul><h3 id="docker-的核心概念" tabindex="-1"><a class="header-anchor" href="#docker-的核心概念" aria-hidden="true">#</a> Docker 的核心概念</h3><h4 id="镜像" tabindex="-1"><a class="header-anchor" href="#镜像" aria-hidden="true">#</a> 镜像</h4><p>Docker 把应用程序及其依赖，打包在镜像（Image）文件里面。</p><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p><strong>分层存储</strong></p><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h4 id="容器" tabindex="-1"><a class="header-anchor" href="#容器" aria-hidden="true">#</a> 容器</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>',16),$={href:"https://en.wikipedia.org/wiki/Linux_namespaces",target:"_blank",rel:"noopener noreferrer"},R=e("code",null,"root",-1),C=e("p",null,[n("前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为"),e("strong",null,"容器存储层"),n("。")],-1),I=e("p",null,"容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。",-1),O={href:"https://yeasy.gitbooks.io/docker_practice/content/data_management/volume.html",target:"_blank",rel:"noopener noreferrer"},N=e("p",null,"数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。",-1),U=e("h4",{id:"仓库",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#仓库","aria-hidden":"true"},"#"),n(" 仓库")],-1),M={href:"https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html",target:"_blank",rel:"noopener noreferrer"},S=o("<p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>",2),E={href:"https://store.docker.com/images/ubuntu",target:"_blank",rel:"noopener noreferrer"},j=e("code",null,"ubuntu",-1),L=e("code",null,"16.04",-1),P=e("code",null,"18.04",-1),F=e("code",null,"ubuntu:14.04",-1),K=e("code",null,"ubuntu:18.04",-1),V=e("code",null,"ubuntu",-1),B=e("code",null,"ubuntu:latest",-1),W=e("p",null,[n("仓库名经常以 "),e("em",null,"两段式路径"),n(" 形式出现，比如 "),e("code",null,"jwilder/nginx-proxy"),n("，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。")],-1),z=e("h2",{id:"二、docker-的运维",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#二、docker-的运维","aria-hidden":"true"},"#"),n(" 二、Docker 的运维")],-1),T=e("p",null,"不同操作系统环境下安装 Docker 的方式有所不同，详情可以参：",-1),X={href:"https://docs.docker.com/install/",target:"_blank",rel:"noopener noreferrer"},Y={href:"https://docker_practice.gitee.io/install/",target:"_blank",rel:"noopener noreferrer"},H={href:"https://docker_practice.gitee.io/install/mirror.html",target:"_blank",rel:"noopener noreferrer"},G=e("p",null,"安装完成后，运行下面的命令，验证是否安装成功。",-1),A=e("ul",null,[e("li",null,[e("code",null,"docker version")]),e("li",null,[e("code",null,"docker info")])],-1),J=e("code",null,"sudo",-1),Q={href:"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user",target:"_blank",rel:"noopener noreferrer"},Z=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">usermod</span> <span class="token parameter variable">-aG</span> <span class="token function">docker</span> <span class="token environment constant">$USER</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,1),ee=e("code",null,"docker",-1),ne={href:"https://docs.docker.com/config/daemon/systemd/",target:"_blank",rel:"noopener noreferrer"},ae=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># service 命令的用法</span>
$ <span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">docker</span> start

<span class="token comment"># systemctl 命令的用法</span>
$ <span class="token function">sudo</span> systemctl start <span class="token function">docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、hello-world-实例" tabindex="-1"><a class="header-anchor" href="#三、hello-world-实例" aria-hidden="true">#</a> 三、Hello World 实例</h2>`,2),se={href:"https://hub.docker.com/r/library/hello-world/",target:"_blank",rel:"noopener noreferrer"},oe={href:"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html",target:"_blank",rel:"noopener noreferrer"},re=o(`<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image pull library/hello-world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>`,3),ce={href:"https://hub.docker.com/r/library/",target:"_blank",rel:"noopener noreferrer"},ie=e("code",null,"library",-1),le=o(`<blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image pull hello-world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>现在，运行这个 image 文件。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container run hello-world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container run hello-world

Hello from Docker<span class="token operator">!</span>
This message shows that your installation appears to be working correctly.

<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container run <span class="token parameter variable">-it</span> ubuntu <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote>`,12),te={href:"https://docs.docker.com/engine/reference/commandline/container_kill/",target:"_blank",rel:"noopener noreferrer"},de=e("code",null,"docker container kill",-1),pe=o(`<blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container <span class="token function">kill</span> <span class="token punctuation">[</span>containID<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><h2 id="四、制作-docker-容器" tabindex="-1"><a class="header-anchor" href="#四、制作-docker-容器" aria-hidden="true">#</a> 四、制作 Docker 容器</h2>`,2),ue={href:"http://www.ruanyifeng.com/blog/2017/08/koa.html",target:"_blank",rel:"noopener noreferrer"},he={href:"https://github.com/ruanyf/koa-demos/archive/master.zip",target:"_blank",rel:"noopener noreferrer"},ke=o(`<blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> clone https://github.com/ruanyf/koa-demos.git
$ <span class="token builtin class-name">cd</span> koa-demos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="编写-dockerfile-文件" tabindex="-1"><a class="header-anchor" href="#编写-dockerfile-文件" aria-hidden="true">#</a> 编写 Dockerfile 文件</h3>`,2),be=e("code",null,".dockerignore",-1),me={href:"https://github.com/ruanyf/koa-demos/blob/master/.dockerignore",target:"_blank",rel:"noopener noreferrer"},ge=o(`<blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>.git
node_modules
npm-debug.log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>`,2),ve={href:"https://github.com/ruanyf/koa-demos/blob/master/Dockerfile",target:"_blank",rel:"noopener noreferrer"},_e=o(`<blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM node:8.4
COPY <span class="token builtin class-name">.</span> /app
WORKDIR /app
RUN <span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--registry</span><span class="token operator">=</span>https://registry.npm.taobao.org
EXPOSE <span class="token number">3000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即 8.4 版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="创建-image-文件" tabindex="-1"><a class="header-anchor" href="#创建-image-文件" aria-hidden="true">#</a> 创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> koa-demo <span class="token builtin class-name">.</span>
<span class="token comment"># 或者</span>
$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> koa-demo:0.0.1 <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><h3 id="生成容器" tabindex="-1"><a class="header-anchor" href="#生成容器" aria-hidden="true">#</a> 生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container run <span class="token parameter variable">-p</span> <span class="token number">8000</span>:3000 <span class="token parameter variable">-it</span> koa-demo /bin/bash
<span class="token comment"># 或者</span>
$ <span class="token function">docker</span> container run <span class="token parameter variable">-p</span> <span class="token number">8000</span>:3000 <span class="token parameter variable">-it</span> koa-demo:0.0.1 /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>root@66d80f4aaf1e:/app<span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>root@66d80f4aaf1e:/app<span class="token comment"># node demos/01.js</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote>`,18),fe={href:"http://127.0.0.1:8000",target:"_blank",rel:"noopener noreferrer"},De={href:"https://github.com/ruanyf/koa-demos/blob/master/demos/01.js",target:"_blank",rel:"noopener noreferrer"},xe=o(`<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 在本机的另一个终端窗口，查出容器的 ID</span>
$ <span class="token function">docker</span> container <span class="token function">ls</span>

<span class="token comment"># 停止指定的容器运行</span>
$ <span class="token function">docker</span> container <span class="token function">kill</span> <span class="token punctuation">[</span>containerID<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查出容器的 ID</span>
$ <span class="token function">docker</span> container <span class="token function">ls</span> <span class="token parameter variable">--all</span>

<span class="token comment"># 删除指定的容器文件</span>
$ <span class="token function">docker</span> container <span class="token function">rm</span> <span class="token punctuation">[</span>containerID<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-p</span> <span class="token number">8000</span>:3000 <span class="token parameter variable">-it</span> koa-demo /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><h3 id="cmd-命令" tabindex="-1"><a class="header-anchor" href="#cmd-命令" aria-hidden="true">#</a> CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM node:8.4
COPY <span class="token builtin class-name">.</span> /app
WORKDIR /app
RUN <span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--registry</span><span class="token operator">=</span>https://registry.npm.taobao.org
EXPOSE <span class="token number">3000</span>
CMD <span class="token function">node</span> demos/01.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> container run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-p</span> <span class="token number">8000</span>:3000 <span class="token parameter variable">-it</span> koa-demo:0.0.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><h3 id="发布-image-文件" tabindex="-1"><a class="header-anchor" href="#发布-image-文件" aria-hidden="true">#</a> 发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>`,16),qe={href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"},ye={href:"https://cloud.docker.com/",target:"_blank",rel:"noopener noreferrer"},we=o(`<blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> login
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>接着，为本地的 image 标注用户名和版本。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image tag <span class="token punctuation">[</span>imageName<span class="token punctuation">]</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span>/<span class="token punctuation">[</span>repository<span class="token punctuation">]</span>:<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>
<span class="token comment"># 实例</span>
$ <span class="token function">docker</span> image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>也可以不标注用户名，重新构建一下 image 文件。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image build <span class="token parameter variable">-t</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span>/<span class="token punctuation">[</span>repository<span class="token punctuation">]</span>:<span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>最后，发布 image 文件。</p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> image push <span class="token punctuation">[</span>username<span class="token punctuation">]</span>/<span class="token punctuation">[</span>repository<span class="token punctuation">]</span>:<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote>`,7),$e={href:"http://hub.docker.com",target:"_blank",rel:"noopener noreferrer"},Re=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),n(" 参考资料")],-1),Ce={href:"https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html",target:"_blank",rel:"noopener noreferrer"},Ie={href:"https://github.com/yeasy/docker_practice",target:"_blank",rel:"noopener noreferrer"};function Oe(Ne,Ue){const a=c("ExternalLinkIcon");return i(),l("div",null,[d,e("ul",null,[p,e("li",null,[u,n(" - 对开发和运维（"),e("a",h,[n("DevOps"),s(a)]),n("）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 "),k,n(" 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 "),e("a",b,[n("Dockerfile"),s(a)]),n(" 来进行镜像构建，并结合 "),e("a",m,[n("持续集成(Continuous Integration)"),s(a)]),n(" 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 "),e("a",g,[n("持续部署(Continuous Delivery/Deployment)"),s(a)]),n(" 系统进行自动部署。而且使用 "),e("a",v,[_,s(a)]),n(" 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。")]),f,e("li",null,[D,n(" - "),x,n(" 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，"),q,n(" 团队同各个开源项目团队一起维护了一大批高质量的 "),e("a",y,[n("官方镜像"),s(a)]),n("，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。")])]),w,e("p",null,[n("容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 "),e("a",$,[n("命名空间"),s(a)]),n("。因此容器可以拥有自己的 "),R,n(" 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。")]),C,I,e("p",null,[n("按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 "),e("a",O,[n("数据卷（Volume）"),s(a)]),n("、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。")]),N,U,e("p",null,[n("镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，"),e("a",M,[n("Docker Registry"),s(a)]),n(" 就是这样的服务。")]),S,e("p",null,[n("以 "),e("a",E,[n("Ubuntu 镜像"),s(a)]),n(" 为例，"),j,n(" 是仓库的名字，其内包含有不同的版本标签，如，"),L,n(", "),P,n("。我们可以通过 "),F,n("，或者 "),K,n(" 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 "),V,n("，那将视为 "),B,n("。")]),W,z,T,e("ul",null,[e("li",null,[e("a",X,[n("Docker 官方安装指南"),s(a)])]),e("li",null,[e("a",Y,[n("安装 Docker（中文）"),s(a)])])]),e("p",null,[n("国内访问 Docker 比较慢，如果需要提速，可以参考 "),e("a",H,[n("镜像加速器"),s(a)])]),G,A,e("p",null,[n("Docker 需要用户具有 sudo 权限，为了避免每次命令都输入"),J,n("，可以把用户加入 Docker 用户组（"),e("a",Q,[n("官方文档"),s(a)]),n("）。")]),Z,e("p",null,[n("Docker 是服务器----客户端架构。命令行运行"),ee,n("命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（"),e("a",ne,[n("官方文档"),s(a)]),n("）。")]),ae,e("p",null,[n('下面，我们通过最简单的 image 文件"'),e("a",se,[n('hello world"'),s(a)]),n("，感受一下 Docker。")]),e("p",null,[n("需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在"),e("a",oe,[n("下一篇文章"),s(a)]),n("的第一节。有需要的朋友，可以先看一下。")]),re,e("p",null,[n("由于 Docker 官方提供的 image 文件，都放在"),e("a",ce,[ie,s(a)]),n("组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。")]),le,e("p",null,[n("对于那些不会自动终止的容器，必须使用"),e("a",te,[de,s(a)]),n(" 命令手动终止。")]),pe,e("p",null,[n("下面我以 "),e("a",ue,[n("koa-demos"),s(a)]),n(" 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。")]),e("p",null,[n("作为准备工作，请先"),e("a",he,[n("下载源码"),s(a)]),n("。")]),ke,e("p",null,[n("首先，在项目的根目录下，新建一个文本文件"),be,n("，写入下面的"),e("a",me,[n("内容"),s(a)]),n("。")]),ge,e("p",null,[n("然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的"),e("a",ve,[n("内容"),s(a)]),n("。")]),_e,e("p",null,[n("这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 "),e("a",fe,[n("http://127.0.0.1:8000"),s(a)]),n('，网页显示"Not Found"，这是因为这个 '),e("a",De,[n("demo"),s(a)]),n(" 没有写路由。")]),xe,e("p",null,[n("首先，去 "),e("a",qe,[n("hub.docker.com"),s(a)]),n(" 或 "),e("a",ye,[n("cloud.docker.com"),s(a)]),n(" 注册一个账户。然后，用下面的命令登录。")]),we,e("p",null,[n("发布成功以后，登录 "),e("a",$e,[n("hub.docker.com"),s(a)]),n("，就可以看到已经发布的 image 文件。")]),Re,e("ul",null,[e("li",null,[e("a",Ce,[n("Docker 入门教程"),s(a)])]),e("li",null,[e("a",Ie,[n("Docker — 从入门到实践"),s(a)])])])])}const Ee=r(t,[["render",Oe],["__file","index.html.vue"]]);export{Ee as default};
