import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as e}from"./app-D2mhfMf9.js";const r={};function p(o,a){return e(),s("div",null,[...a[0]||(a[0]=[n('<h1 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h1><h2 id="什么是堆" tabindex="-1"><a class="header-anchor" href="#什么是堆"><span>什么是堆？</span></a></h2><p>堆（Heap）是一个可以被看成近似完全二叉树的数组。</p><ul><li><strong>堆是一个完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</strong>。</li></ul><p>堆可以分为大顶堆和小顶堆。</p><ul><li><p>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“<strong>大顶堆</strong>”。</p></li><li><p>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“<strong>小顶堆</strong>”。</p></li></ul><h2 id="如何实现堆" tabindex="-1"><a class="header-anchor" href="#如何实现堆"><span>如何实现堆</span></a></h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/64d7d313e3dd4ded93aa59886cd04230.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>堆常见的操作：</p><ul><li>HEAPIFY 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li>HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li>HEAPPOP：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li><li>HEAPSORT：借由 HEAPFY 建堆和 HEAPPOP 堆数组进行排序，时间复杂度为$ O(N log N)$，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><h2 id="堆的应用场景" tabindex="-1"><a class="header-anchor" href="#堆的应用场景"><span>堆的应用场景</span></a></h2><h3 id="求-top-n" tabindex="-1"><a class="header-anchor" href="#求-top-n"><span>求 TOP N</span></a></h3><p>堆结构的一个常见应用是建立优先队列（Priority Queue）。</p><p>求 Top K 的问题抽象成两类。一类是针对静态数据集合；另一类是针对动态数据集合</p><h3 id="优先级队列" tabindex="-1"><a class="header-anchor" href="#优先级队列"><span>优先级队列</span></a></h3><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>堆和优先级队列非常相似：往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><blockquote><p>参考：Java 的 <code>PriorityQueue</code> 类</p></blockquote><h3 id="求中位数" tabindex="-1"><a class="header-anchor" href="#求中位数"><span>求中位数</span></a></h3>',20)])])}const l=t(r,[["render",p]]),c=JSON.parse('{"path":"/pages/9b7d8810/","title":"堆","lang":"zh-CN","frontmatter":{"title":"堆","date":"2015-03-09T16:01:27.000Z","order":2,"categories":["算法"],"tags":["数据结构","树","二叉树","堆"],"permalink":"/pages/9b7d8810/","description":"堆 什么是堆？ 堆（Heap）是一个可以被看成近似完全二叉树的数组。 堆是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 堆可以分为大顶堆和小顶堆。 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。 对于每个节点的值...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"堆\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/64d7d313e3dd4ded93aa59886cd04230.jpg\\"],\\"datePublished\\":\\"2015-03-09T16:01:27.000Z\\",\\"dateModified\\":\\"2026-02-11T15:41:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/9b7d8810/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"堆"}],["meta",{"property":"og:description","content":"堆 什么是堆？ 堆（Heap）是一个可以被看成近似完全二叉树的数组。 堆是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 堆可以分为大顶堆和小顶堆。 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。 对于每个节点的值..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/64d7d313e3dd4ded93aa59886cd04230.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-11T15:41:54.000Z"}],["meta",{"property":"article:tag","content":"堆"}],["meta",{"property":"article:tag","content":"二叉树"}],["meta",{"property":"article:tag","content":"树"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2015-03-09T16:01:27.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-11T15:41:54.000Z"}]]},"git":{"createdTime":1651071272000,"updatedTime":1770824514000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":11,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":2.02,"words":606},"filePathRelative":"11.算法/堆.md","excerpt":"\\n<h2>什么是堆？</h2>\\n<p>堆（Heap）是一个可以被看成近似完全二叉树的数组。</p>\\n<ul>\\n<li><strong>堆是一个完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>\\n<li><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</strong>。</li>\\n</ul>\\n<p>堆可以分为大顶堆和小顶堆。</p>\\n<ul>\\n<li>\\n<p>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“<strong>大顶堆</strong>”。</p>\\n</li>\\n<li>\\n<p>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“<strong>小顶堆</strong>”。</p>\\n</li>\\n</ul>","autoDesc":true}');export{l as comp,c as data};
