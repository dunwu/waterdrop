import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,e as r}from"./app-7f6c254b.js";const d={},n=r('<h1 id="《极客时间教程-深入拆解-java-虚拟机》笔记" tabindex="-1"><a class="header-anchor" href="#《极客时间教程-深入拆解-java-虚拟机》笔记" aria-hidden="true">#</a> 《极客时间教程 - 深入拆解 Java 虚拟机》笔记</h1><h2 id="开篇词-为什么我们要学习-java-虚拟机" tabindex="-1"><a class="header-anchor" href="#开篇词-为什么我们要学习-java-虚拟机" aria-hidden="true">#</a> 开篇词 为什么我们要学习 Java 虚拟机？</h2><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/414248014bf825dd610c3095eed75377.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="java-代码是怎么运行的" tabindex="-1"><a class="header-anchor" href="#java-代码是怎么运行的" aria-hidden="true">#</a> Java 代码是怎么运行的？</h2><p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/ab5c3523af08e0bf2f689c1d6033ef77.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p><p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。</p><p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。</p><p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/5ee351091464de78eed75438b6f9183b.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="java-的基本类型" tabindex="-1"><a class="header-anchor" href="#java-的基本类型" aria-hidden="true">#</a> Java 的基本类型</h2><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/77dfb788a8ad5877e77fc28ed2d51745.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="java-虚拟机是如何加载-java-类的" tabindex="-1"><a class="header-anchor" href="#java-虚拟机是如何加载-java-类的" aria-hidden="true">#</a> Java 虚拟机是如何加载 Java 类的</h2><ul><li>加载 - 是指查找字节流，并且据此创建类的过程。</li><li>链接 - 是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。 <ul><li>验证 - 确保被加载类能够满足 Java 虚拟机的约束条件。</li><li>准备 - 为被加载类的静态字段分配内存。</li><li>解析 - 将符号引用解析为直接引用。</li></ul></li><li>初始化 - 为标记为常量值的字段赋值，以及执行 <code>&lt;clinit&gt;</code> 方法的过程。Java 虚拟机会通过加锁来确保类的 <code>&lt;clinit&gt;</code> 方法仅被执行一次。</li></ul><h2 id="jvm-是如何执行方法调用的-上" tabindex="-1"><a class="header-anchor" href="#jvm-是如何执行方法调用的-上" aria-hidden="true">#</a> JVM 是如何执行方法调用的？（上）</h2><p>重载指的是方法名相同而参数类型不相同的方法之间的关系。</p><p>重写指的是子类中定义和父类方法名相同且参数类型相同的方法。</p><p>重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ol><li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；</li><li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；</li><li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。</li></ol><h2 id="jvm-是如何执行方法调用的-下" tabindex="-1"><a class="header-anchor" href="#jvm-是如何执行方法调用的-下" aria-hidden="true">#</a> JVM 是如何执行方法调用的？（下）</h2><p>虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java 虚拟机会采用静态绑定。</p><p>否则，Java 虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。</p><p>Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。</p><p>在解析虚方法调用时，Java 虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。</p><p>Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。</p><p>当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。</p><p>否则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。</p><h2 id="jvm-是如何处理异常的" tabindex="-1"><a class="header-anchor" href="#jvm-是如何处理异常的" aria-hidden="true">#</a> JVM 是如何处理异常的？</h2><p>Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 finally 代码块都会生成异常表条目。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/17e2a3053b06b0a4383884f106e31c06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="jvm-是如何实现反射的" tabindex="-1"><a class="header-anchor" href="#jvm-是如何实现反射的" aria-hidden="true">#</a> JVM 是如何实现反射的？</h2><p>在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。</p><p>方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。</p><h2 id="jvm-是怎么实现-invokedynamic-的-上" tabindex="-1"><a class="header-anchor" href="#jvm-是怎么实现-invokedynamic-的-上" aria-hidden="true">#</a> JVM 是怎么实现 invokedynamic 的？（上）</h2><p>invokedynamic 底层机制的基石：方法句柄。</p><p>方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。</p><p>方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。</p><p>方法句柄的调用和反射调用一样，都是间接调用，同样会面临无法内联的问题。</p><h2 id="jvm-是怎么实现-invokedynamic-的-下" tabindex="-1"><a class="header-anchor" href="#jvm-是怎么实现-invokedynamic-的-下" aria-hidden="true">#</a> JVM 是怎么实现 invokedynamic 的？（下）</h2><p>invokedymaic 指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行 invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。</p><p>Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类。</p><p>对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例。</p><p>不管是捕获型的还是未捕获型的 Lambda 表达式，它们的性能上限皆可以达到直接调用的性能。其中，捕获型 Lambda 表达式借助了即时编译器中的逃逸分析，来避免实际的新建适配器类实例的操作。</p><h2 id="java-对象的内存布局" tabindex="-1"><a class="header-anchor" href="#java-对象的内存布局" aria-hidden="true">#</a> Java 对象的内存布局</h2><h3 id="压缩指针" tabindex="-1"><a class="header-anchor" href="#压缩指针" aria-hidden="true">#</a> 压缩指针</h3><p>在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header），这个由标记字段和类型指针所构成。其中，标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。</p><p>在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。也就是说，每一个 Java 对象在内存中的额外开销就是 16 个字节。</p><p>Java 虚拟机引入了压缩指针的概念，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也能够内存对齐。</p><h3 id="字段重排序" tabindex="-1"><a class="header-anchor" href="#字段重排序" aria-hidden="true">#</a> 字段重排序</h3><h2 id="垃圾回收-上" tabindex="-1"><a class="header-anchor" href="#垃圾回收-上" aria-hidden="true">#</a> 垃圾回收（上）</h2><h3 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h3><p>引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p><p>如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。</p><h3 id="可达性分析法" tabindex="-1"><a class="header-anchor" href="#可达性分析法" aria-hidden="true">#</a> 可达性分析法</h3><p>可达性分析法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p><p>GC Roots 包括（但不限于）如下几种：</p><ol><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。</li></ol><h3 id="stop-the-world" tabindex="-1"><a class="header-anchor" href="#stop-the-world" aria-hidden="true">#</a> Stop-the-world</h3><p>传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p><h3 id="垃圾回收方式" tabindex="-1"><a class="header-anchor" href="#垃圾回收方式" aria-hidden="true">#</a> 垃圾回收方式</h3><h4 id="标记-复制" tabindex="-1"><a class="header-anchor" href="#标记-复制" aria-hidden="true">#</a> 标记-复制</h4><p>标记-复制把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/4749cad235deb1542d4ca3b232ebf261.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="标记-清除" tabindex="-1"><a class="header-anchor" href="#标记-清除" aria-hidden="true">#</a> 标记-清除</h4><p>标记-清除即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/f225126be24826658ca5a899fcff5003.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="标记-整理" tabindex="-1"><a class="header-anchor" href="#标记-整理" aria-hidden="true">#</a> 标记-整理</h4><p>标记-整理把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/415ee8e4aef12ff076b42e41660dad39.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="垃圾回收-下" tabindex="-1"><a class="header-anchor" href="#垃圾回收-下" aria-hidden="true">#</a> 垃圾回收（下）</h2><p>Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。</p><p>可以通过参数 -XX:SurvivorRatio 来调整 Eden 区和 Survivor 区的比例。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入拆解Java虚拟机/assets/2cc29b8de676d3747416416a3523e4e5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</p><p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p><p>总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。</p><h2 id="java-内存模型" tabindex="-1"><a class="header-anchor" href="#java-内存模型" aria-hidden="true">#</a> Java 内存模型</h2><p>Java 内存模型还定义了下述线程间的 happens-before 关系。</p><ol><li>解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。</li><li>volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。</li><li>线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。</li><li>线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。</li><li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。</li><li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li></ol><p>happens-before 关系还具备传递性。如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。</p><h2 id="java-虚拟机是怎么实现-synchronized-的" tabindex="-1"><a class="header-anchor" href="#java-虚拟机是怎么实现-synchronized-的" aria-hidden="true">#</a> Java 虚拟机是怎么实现 synchronized 的？</h2><p>当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。</p><p>当用 synchronized 标记方法时，你会看到字节码中方法的访问标记包括 ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java 虚拟机需要进行 monitorenter 操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java 虚拟机均需要进行 monitorexit 操作。</p><h2 id="java-语法糖与-java-编译器" tabindex="-1"><a class="header-anchor" href="#java-语法糖与-java-编译器" aria-hidden="true">#</a> Java 语法糖与 Java 编译器</h2><p>Java 程序中的泛型信息会被擦除。具体来说，Java 编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的具体类。</p><h2 id="即时编译-上" tabindex="-1"><a class="header-anchor" href="#即时编译-上" aria-hidden="true">#</a> 即时编译（上）</h2><p>从 Java 8 开始，Java 虚拟机默认采用分层编译的方式。它将执行分为五个层次，分为为 0 层解释执行，1 层执行没有 profiling 的 C1 代码，2 层执行部分 profiling 的 C1 代码，3 层执行全部 profiling 的 C1 代码，和 4 层执行 C2 代码。</p><p>通常情况下，方法会首先被解释执行，然后被 3 层的 C1 编译，最后被 4 层的 C2 编译。</p><p>即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈值是根据当前待编译的方法数目动态调整的。</p><p>OSR 是一种能够在非方法入口处进行解释执行和编译后代码之间切换的技术。OSR 编译可以用来解决单次调用方法包含热循环的性能优化问题。</p><h2 id="即时编译-下" tabindex="-1"><a class="header-anchor" href="#即时编译-下" aria-hidden="true">#</a> 即时编译（下）</h2><p>通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。</p><p>当方法被 3 层 C1 所编译时，生成的 C1 代码将收集条件跳转指令的分支 profile，以及类型相关指令的类型 profile。在部分极端情况下，Java 虚拟机也会在解释执行过程中收集这些 profile。</p><p>基于分支 profile 的优化以及基于类型 profile 的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java 虚拟机将采取去优化，退回至解释执行并重新收集相关的 profile。</p><h2 id="即时编译器的中间表达形式" tabindex="-1"><a class="header-anchor" href="#即时编译器的中间表达形式" aria-hidden="true">#</a> 即时编译器的中间表达形式</h2><p>即时编译器将所输入的 Java 字节码转换成 SSA IR，以便更好地进行优化。</p><h2 id="java-字节码-基础篇" tabindex="-1"><a class="header-anchor" href="#java-字节码-基础篇" aria-hidden="true">#</a> Java 字节码（基础篇）</h2><p>Java 方法的栈桢分为操作数栈和局部变量区。通常来说，程序需要将变量从局部变量区加载至操作数栈中，进行一番运算之后再存储回局部变量区中。</p><p>Java 字节码可以划分为很多种类型，如加载常量指令，操作数栈专用指令，局部变量区访问指令，Java 相关指令，方法调用指令，数组相关指令，控制流指令，以及计算相关指令。</p><h2 id="方法内联-上" tabindex="-1"><a class="header-anchor" href="#方法内联-上" aria-hidden="true">#</a> 方法内联（上）</h2><p>方法内联是指，在编译过程中，当遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。</p><p>即时编译器既可以在解析过程中替换方法调用字节码，也可以在 IR 图中替换方法调用 IR 节点。这两者都需要将目标方法的参数以及返回值映射到当前方法来。</p><p>方法内联有许多规则。除了一些强制内联以及强制不内联的规则外，即时编译器会根据方法调用的层数、方法调用指令所在的程序路径的热度、目标方法的调用次数及大小，以及当前 IR 图的大小来决定方法调用能否被内联。</p><h2 id="方法内联-下" tabindex="-1"><a class="header-anchor" href="#方法内联-下" aria-hidden="true">#</a> 方法内联（下）</h2><p>完全去虚化通过类型推导或者类层次分析，将虚方法调用转换为直接调用。它的关键在于证明虚方法调用的目标方法是唯一的。</p><p>条件去虚化通过向代码中增添类型比较，将虚方法调用转换为一个个的类型测试以及对应该类型的直接调用。它将借助 Java 虚拟机所收集的类型 Profile。</p><h2 id="hotspot-虚拟机的-intrinsic" tabindex="-1"><a class="header-anchor" href="#hotspot-虚拟机的-intrinsic" aria-hidden="true">#</a> HotSpot 虚拟机的 intrinsic</h2><p>HotSpot 虚拟机将对标注了<code>@HotSpotIntrinsicCandidate</code>注解的方法的调用，替换为直接使用基于特定 CPU 指令的高效实现。这些方法我们便称之为 intrinsic。</p><p>具体来说，intrinsic 的实现有两种。一是不大常见的桩程序，可以在解释执行或者即时编译生成的代码中使用。二是特殊的 IR 节点。即时编译器将在方法内联过程中，将对 intrinsic 的调用替换为这些特殊的 IR 节点，并最终生成指定的 CPU 指令。</p><p>HotSpot 虚拟机定义了三百多个 intrinsic。其中比较特殊的有<code>Unsafe</code>类的方法，基本上使用 java.util.concurrent 包便会间接使用到<code>Unsafe</code>类的 intrinsic。除此之外，<code>String</code>类和<code>Arrays</code>类中的 intrinsic 也比较特殊。即时编译器将为之生成非常高效的 SIMD 指令。</p><h2 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h2><p>Java 中<code>Iterable</code>对象的 foreach 循环遍历是一个语法糖，Java 编译器会将该语法糖编译为调用<code>Iterable</code>对象的<code>iterator</code>方法，并用所返回的<code>Iterator</code>对象的<code>hasNext</code>以及<code>next</code>方法，来完成遍历。</p><p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。</p><p>在 Java 虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否会逃逸。即时编译器判断对象逃逸的依据有两个：一是看对象是否被存入堆中，二是看对象是否作为方法调用的调用者或者参数。</p><p>即时编译器会根据逃逸分析的结果进行优化，如锁消除以及标量替换。后者指的是将原本连续分配的对象拆散为一个个单独的字段，分布在栈上或者寄存器中。</p><p>部分逃逸分析是一种附带了控制流信息的逃逸分析。它将判断新建对象真正逃逸的分支，并且支持将新建操作推延至逃逸分支。</p><h2 id="字段访问相关优化" tabindex="-1"><a class="header-anchor" href="#字段访问相关优化" aria-hidden="true">#</a> 字段访问相关优化</h2><p>即时编译器将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值。</p><p>这要求生成缓存值的访问以及使用缓存值的读取之间没有方法调用、内存屏障，或者其他可能存储该字段的节点。</p><p>即时编译器还会优化冗余的字段存储操作。如果一个字段的两次存储之间没有对该字段的读取操作、方法调用以及内存屏障，那么即时编译器可以将第一个冗余的存储操作给消除掉。</p><h2 id="循环优化" tabindex="-1"><a class="header-anchor" href="#循环优化" aria-hidden="true">#</a> 循环优化</h2><p>循环无关代码外提将循环中值不变的表达式，或者循环无关检测外提至循环之前，以避免在循环中重复进行冗余计算。前者是通过 Sea-of-Nodes IR 以及节点调度来共同完成的，而后者则是通过一个独立优化 —— 循环预测来完成的。循环预测还可以外提循环有关的数组下标范围检测。</p><p>循环展开是一种在循环中重复多次迭代，并且相应地减少循环次数的优化方式。它是一种以空间换时间的优化方式，通过增大循环体来获取更多的优化机会。循环展开的特殊形式是完全展开，将原本的循环转换成若干个循环体的顺序执行。</p><h2 id="向量化" tabindex="-1"><a class="header-anchor" href="#向量化" aria-hidden="true">#</a> 向量化</h2><p>向量化优化借助的是 CPU 的 SIMD 指令，即通过单条指令控制多组数据的运算。它被称为 CPU 指令级别的并行。</p><p>HotSpot 虚拟机运用向量化优化的方式有两种。第一种是使用 HotSpot intrinsic，在调用特定方法的时候替换为使用了 SIMD 指令的高效实现。Intrinsic 属于点覆盖，只有当应用程序明确需要这些 intrinsic 的语义，才能够获得由它带来的性能提升。</p><h2 id="注解处理器" tabindex="-1"><a class="header-anchor" href="#注解处理器" aria-hidden="true">#</a> 注解处理器</h2><h2 id="基准测试框架-jmh-上" tabindex="-1"><a class="header-anchor" href="#基准测试框架-jmh-上" aria-hidden="true">#</a> 基准测试框架 JMH（上）</h2><p>性能基准测试框架 JMH 是 OpenJDK 中的其中一个开源项目。它内置了许多功能，来规避由 Java 虚拟机中的即时编译器或者其他优化对性能测试造成的影响。此外，它还提供了不少策略来降低来自操作系统以及硬件系统的影响。</p><p>开发人员仅需将所要测试的业务逻辑通过<code>@Benchmark</code>注解，便可以让 JMH 的注解处理器自动生成真正的性能测试代码，以及相应的性能测试配置文件。</p><h2 id="基准测试框架-jmh-下" tabindex="-1"><a class="header-anchor" href="#基准测试框架-jmh-下" aria-hidden="true">#</a> 基准测试框架 JMH（下）</h2><ul><li><code>@Fork</code>允许开发人员指定所要 Fork 出的 Java 虚拟机的数目。</li><li><code>@BenchmarkMode</code>允许指定性能数据的格式。</li><li><code>@Warmup</code>和<code>@Measurement</code>允许配置预热迭代或者测试迭代的数目，每个迭代的时间以及每个操作包含多少次对测试方法的调用。</li><li><code>@State</code>允许配置测试程序的状态。测试前对程序状态的初始化以及测试后对程序状态的恢复或者校验可分别通过<code>@Setup</code>和<code>@TearDown</code>来实现。</li></ul><h2 id="java-虚拟机的监控及诊断工具-命令行篇" tabindex="-1"><a class="header-anchor" href="#java-虚拟机的监控及诊断工具-命令行篇" aria-hidden="true">#</a> Java 虚拟机的监控及诊断工具（命令行篇）</h2><ul><li><code>jps</code>将打印所有正在运行的 Java 进程。</li><li><code>jstat</code>允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</li><li><code>jmap</code>允许用户统计目标 Java 进程的堆中存放的 Java 对象，并将它们导出成二进制文件。</li><li><code>jinfo</code>将打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。</li><li><code>jstack</code>将打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。</li><li><code>jcmd</code>则是一把瑞士军刀，可以用来实现前面除了<code>jstat</code>之外所有命令的功能。</li></ul><h2 id="java-虚拟机的监控及诊断工具-gui-篇" tabindex="-1"><a class="header-anchor" href="#java-虚拟机的监控及诊断工具-gui-篇" aria-hidden="true">#</a> Java 虚拟机的监控及诊断工具（GUI 篇）</h2><p>Eclipse MAT 可用于分析由<code>jmap</code>命令导出的 Java 堆快照。它包括两个相对比较重要的视图，分别为直方图和支配树。直方图展示了各个类的实例数目以及这些实例的 Shallow heap 或 Retained heap 的总和。支配树则展示了快照中每个对象所直接支配的对象。</p><p>Java Mission Control 是 Java 虚拟机平台上的性能监控工具。Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。</p><h2 id="jni-的运行机制" tabindex="-1"><a class="header-anchor" href="#jni-的运行机制" aria-hidden="true">#</a> JNI 的运行机制</h2><p>Java 中的 native 方法的链接方式主要有两种。一是按照 JNI 的默认规范命名所要链接的 C 函数，并依赖于 Java 虚拟机自动链接。另一种则是在 C 代码中主动链接。</p><p>JNI 提供了一系列 API 来允许 C 代码使用 Java 语言特性。这些 API 不仅使用了特殊的数据结构来表示 Java 类，还拥有特殊的异常处理模式。</p><p>JNI 中的引用可分为局部引用和全局引用。这两者都可以阻止垃圾回收器回收被引用的 Java 对象。不同的是，局部引用在 native 方法调用返回之后便会失效。传入参数以及大部分 JNI API 函数的返回值都属于局部引用。</p><h2 id="javaagent-与字节码注入" tabindex="-1"><a class="header-anchor" href="#javaagent-与字节码注入" aria-hidden="true">#</a> JavaAgent 与字节码注入</h2><h2 id="graal-用-java-编译-java" tabindex="-1"><a class="header-anchor" href="#graal-用-java-编译-java" aria-hidden="true">#</a> Graal：用 Java 编译 Java</h2><p>Graal 是一个用 Java 写就的、并能够将 Java 字节码转换成二进制码的即时编译器。它通过 JVMCI 与 Java 虚拟机交互，响应由后者发出的编译请求、完成编译并部署编译结果。</p><p>对 Java 程序而言，Graal 编译结果的性能略优于 OpenJDK 中的 C2；对 Scala 程序而言，它的性能优势可达到 10%（企业版甚至可以达到 20%！）。这背后离不开 Graal 所采用的激进优化方式。</p><h2 id="truffle-语言实现框架" tabindex="-1"><a class="header-anchor" href="#truffle-语言实现框架" aria-hidden="true">#</a> Truffle：语言实现框架</h2><p>Truffle 是一个语言实现框架，允许语言开发者在仅实现词法解析、语法解析以及 AST 解释器的情况下，达到极佳的性能。目前 Oracle Labs 已经实现并维护了 JavaScript、Ruby、R、Python 以及可用于解析 LLVM bitcode 的 Sulong。后者将支持在 GraalVM 上运行 C/C++ 代码。</p><p>Truffle 背后所依赖的技术是 Partial Evaluation 以及节点重写。Partial Evaluation 指的是将所要编译的目标程序解析生成的抽象语法树当做编译时常量，特化该 Truffle 语言的解释器，从而得到指代这段程序解释执行过程的 Java 代码。然后，我们可以借助 Graal 编译器将这段 Java 代码即时编译为机器码。</p><p>节点重写则是收集 AST 节点的类型，根据所收集的类型 profile 进行的特化，并在节点类型不匹配时进行去优化并重新收集、编译的一项技术。</p><p>Truffle 的 Polyglot 特性支持在一段代码中混用多种不同的语言。与其他 Polyglot 框架相比，它支持在不同的 Truffle 语言中复用内存中存储的同一个对象。</p><h2 id="substratevm-aot-编译框架" tabindex="-1"><a class="header-anchor" href="#substratevm-aot-编译框架" aria-hidden="true">#</a> SubstrateVM：AOT 编译框架</h2><p>SubstrateVM 的设计初衷是提供一个高启动性能、低内存开销，和能够无缝衔接 C 代码的 Java 运行时。它是一个独立的运行时，拥有自己的内存管理等组件。</p><p>SubstrateVM 要求所要 AOT 编译的目标程序是封闭的，即不能动态加载其他类库等。在进行 AOT 编译时，它会探索所有可能运行到的方法，并全部纳入编译范围之内。</p><p>SubstrateVM 的启动时间和内存开销都非常少，这主要得益于在 AOT 编译时便已保存了已初始化好的堆快照，并支持从程序入口直接开始运行。作为对比，HotSpot 虚拟机在执行 main 方法前需要执行一系列的初始化操作，因此启动时间和内存开销都要远大于运行在 SubstrateVM 上的程序。</p><p>Metropolis 项目将运用 SubstrateVM 项目，逐步地将 HotSpot 虚拟机中的 C++ 代码替换成 Java 代码，从而提升 HotSpot 虚拟机的可维护性，也加快新 Java 功能的开发效率。</p><h2 id="尾声丨道阻且长-努力加餐。html" tabindex="-1"><a class="header-anchor" href="#尾声丨道阻且长-努力加餐。html" aria-hidden="true">#</a> 尾声丨道阻且长，努力加餐。html</h2><h2 id="工具篇-常用工具介绍" tabindex="-1"><a class="header-anchor" href="#工具篇-常用工具介绍" aria-hidden="true">#</a> 工具篇 常用工具介绍</h2>',158),h=[n];function t(o,p){return e(),i("div",null,h)}const s=a(d,[["render",t],["__file","index.html.vue"]]);export{s as default};
