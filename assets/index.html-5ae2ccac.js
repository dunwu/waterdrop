const e=JSON.parse('{"key":"v-0f0b0b76","path":"/pages/e987a43b/","title":"Java 并发之容器","lang":"zh-CN","frontmatter":{"title":"Java 并发之容器","date":"2020-02-02T17:54:36.000Z","permalink":"/pages/e987a43b/","category":["Java","JavaCore","并发"],"tag":["Java","JavaCore","并发","容器","synchronized","AQS"],"description":"Java 并发之容器 同步容器 同步容器简介 在 Java 中，同步容器主要包括 2 类： Vector、Stack、Hashtable Vector - Vector 实现了 List 接口。Vector 实际上就是一个数组，和 ArrayList 类似。但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施。 Stack - Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。 Hashtable- Hashtable 实现了 Map 接口，它和 HashMap 很相似，但是 Hashtable 进行了同步处理，而 HashMap 没有。 Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXXX 等方法）","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/e987a43b/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 并发之容器"}],["meta",{"property":"og:description","content":"Java 并发之容器 同步容器 同步容器简介 在 Java 中，同步容器主要包括 2 类： Vector、Stack、Hashtable Vector - Vector 实现了 List 接口。Vector 实际上就是一个数组，和 ArrayList 类似。但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施。 Stack - Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。 Hashtable- Hashtable 实现了 Map 接口，它和 HashMap 很相似，但是 Hashtable 进行了同步处理，而 HashMap 没有。 Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXXX 等方法）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-15T23:50:15.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"容器"}],["meta",{"property":"article:tag","content":"synchronized"}],["meta",{"property":"article:tag","content":"AQS"}],["meta",{"property":"article:published_time","content":"2020-02-02T17:54:36.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-15T23:50:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 并发之容器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-02-02T17:54:36.000Z\\",\\"dateModified\\":\\"2025-09-15T23:50:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"同步容器","slug":"同步容器","link":"#同步容器","children":[{"level":3,"title":"同步容器简介","slug":"同步容器简介","link":"#同步容器简介","children":[]},{"level":3,"title":"同步容器的问题","slug":"同步容器的问题","link":"#同步容器的问题","children":[]}]},{"level":2,"title":"并发容器简介","slug":"并发容器简介","link":"#并发容器简介","children":[{"level":3,"title":"并发场景下的 Map","slug":"并发场景下的-map","link":"#并发场景下的-map","children":[]},{"level":3,"title":"并发场景下的 List","slug":"并发场景下的-list","link":"#并发场景下的-list","children":[]}]},{"level":2,"title":"Map","slug":"map","link":"#map","children":[{"level":3,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]}]},{"level":2,"title":"List","slug":"list","link":"#list","children":[{"level":3,"title":"CopyOnWriteArrayList","slug":"copyonwritearraylist","link":"#copyonwritearraylist","children":[]}]},{"level":2,"title":"Set","slug":"set","link":"#set","children":[]},{"level":2,"title":"Queue","slug":"queue","link":"#queue","children":[{"level":3,"title":"BlockingQueue","slug":"blockingqueue","link":"#blockingqueue","children":[]},{"level":3,"title":"PriorityBlockingQueue 类","slug":"priorityblockingqueue-类","link":"#priorityblockingqueue-类","children":[]},{"level":3,"title":"ArrayBlockingQueue 类","slug":"arrayblockingqueue-类","link":"#arrayblockingqueue-类","children":[]},{"level":3,"title":"LinkedBlockingQueue 类","slug":"linkedblockingqueue-类","link":"#linkedblockingqueue-类","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1757980215000,"updatedTime":1757980215000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":23.41,"words":7022},"filePathRelative":"01.Java/JavaCore/并发/Java_并发_容器.md","localizedDate":"2020年2月2日","excerpt":"<h1> Java 并发之容器</h1>\\n<h2> 同步容器</h2>\\n<h3> 同步容器简介</h3>\\n<p>在 Java 中，同步容器主要包括 2 类：</p>\\n<ul>\\n<li><code>Vector</code>、<code>Stack</code>、<code>Hashtable</code>\\n<ul>\\n<li><code>Vector</code> - <code>Vector</code> 实现了 <code>List</code> 接口。<code>Vector</code> 实际上就是一个数组，和 <code>ArrayList</code> 类似。但是 <code>Vector</code> 中的方法都是 <code>synchronized</code> 方法，即进行了同步措施。</li>\\n<li><code>Stack</code> - <code>Stack</code> 也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步，它实际上是继承于 <code>Vector</code> 类。</li>\\n<li><code>Hashtable</code>- <code>Hashtable</code> 实现了 <code>Map</code> 接口，它和 <code>HashMap</code> 很相似，但是 <code>Hashtable</code> 进行了同步处理，而 <code>HashMap</code> 没有。</li>\\n</ul>\\n</li>\\n<li><code>Collections</code> 类中提供的静态工厂方法创建的类（由 <code>Collections.synchronizedXXX</code> 等方法）</li>\\n</ul>","autoDesc":true}');export{e as data};
