const e=JSON.parse('{"key":"v-5dd94883","path":"/pages/e162d7d1/","title":"RocketMQ 面试","lang":"zh-CN","frontmatter":{"icon":"simple-icons:apacherocketmq","title":"RocketMQ 面试","date":"2022-07-12T07:49:48.000Z","order":99,"permalink":"/pages/e162d7d1/","category":["分布式","分布式通信","MQ","RocketMQ"],"tag":["分布式","通信","MQ","RocketMQ","面试"],"description":"RocketMQ 面试 RocketMQ 简介 【简单】RocketMQ 是什么？⭐ RocketMQ 是一个开源分布式消息中间件。最初由阿里巴巴开发，现在是 Apache 顶级项目。 RocketMQ 的核心概念 核心组件 生产者（Producer）：从 NameServer 获取路由信息后，将消息发送到 Broker。 消费者（Consumer）：从 NameServer 获取路由信息后，从 Broker 拉取并消费消息。 代理（Broker）：负责消息的存储、投递和查询。采用主从结构保证高可用。 命名服务（NameServer）：管理所有 Broker 的地址列表。无状态，简单高效。 逻辑存储 主题（Topic）：消息的一级分类，生产者和消费者操作的逻辑对象。 标签（Tag）：Topic 下的二级分类，用于对消息进行过滤。 消息（Message）：包含 Body（消息体）、Topic、Tags（标签）、Keys（唯一键）等属性。 消息队列（Message Queue）：Topic 在物理上的分区，是负载均衡和并行处理的最小单位。 物理存储 提交日志（Commit Log）：所有 Topic 的消息都顺序追加到这一个文件中。这是实现高吞吐写入的关键。 消费队列（Consume Queue）：作为 CommitLog 的索引文件。每个 Queue 对应一个，记录消息在 CommitLog 中的位置，实现高效的读取。 索引文件（Index File）：提供按 Message Key 或时间范围查询消息的能力。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/e162d7d1/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"RocketMQ 面试"}],["meta",{"property":"og:description","content":"RocketMQ 面试 RocketMQ 简介 【简单】RocketMQ 是什么？⭐ RocketMQ 是一个开源分布式消息中间件。最初由阿里巴巴开发，现在是 Apache 顶级项目。 RocketMQ 的核心概念 核心组件 生产者（Producer）：从 NameServer 获取路由信息后，将消息发送到 Broker。 消费者（Consumer）：从 NameServer 获取路由信息后，从 Broker 拉取并消费消息。 代理（Broker）：负责消息的存储、投递和查询。采用主从结构保证高可用。 命名服务（NameServer）：管理所有 Broker 的地址列表。无状态，简单高效。 逻辑存储 主题（Topic）：消息的一级分类，生产者和消费者操作的逻辑对象。 标签（Tag）：Topic 下的二级分类，用于对消息进行过滤。 消息（Message）：包含 Body（消息体）、Topic、Tags（标签）、Keys（唯一键）等属性。 消息队列（Message Queue）：Topic 在物理上的分区，是负载均衡和并行处理的最小单位。 物理存储 提交日志（Commit Log）：所有 Topic 的消息都顺序追加到这一个文件中。这是实现高吞吐写入的关键。 消费队列（Consume Queue）：作为 CommitLog 的索引文件。每个 Queue 对应一个，记录消息在 CommitLog 中的位置，实现高效的读取。 索引文件（Index File）：提供按 Message Key 或时间范围查询消息的能力。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-30T15:19:51.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"通信"}],["meta",{"property":"article:tag","content":"MQ"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:published_time","content":"2022-07-12T07:49:48.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-30T15:19:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 面试\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-07-12T07:49:48.000Z\\",\\"dateModified\\":\\"2025-12-30T15:19:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"RocketMQ 简介","slug":"rocketmq-简介","link":"#rocketmq-简介","children":[{"level":3,"title":"【简单】RocketMQ 是什么？⭐","slug":"【简单】rocketmq-是什么-⭐","link":"#【简单】rocketmq-是什么-⭐","children":[]},{"level":3,"title":"【简单】RocketMQ 有哪些核心组件？⭐","slug":"【简单】rocketmq-有哪些核心组件-⭐","link":"#【简单】rocketmq-有哪些核心组件-⭐","children":[]}]},{"level":2,"title":"RocketMQ 存储","slug":"rocketmq-存储","link":"#rocketmq-存储","children":[{"level":3,"title":"【中等】RocketMQ 如何存储数据？⭐⭐","slug":"【中等】rocketmq-如何存储数据-⭐⭐","link":"#【中等】rocketmq-如何存储数据-⭐⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 如何持久化？⭐⭐","slug":"【中等】rocketmq-如何持久化-⭐⭐","link":"#【中等】rocketmq-如何持久化-⭐⭐","children":[]},{"level":3,"title":"【困难】RocketMQ 如何实现内存映射机制？","slug":"【困难】rocketmq-如何实现内存映射机制","link":"#【困难】rocketmq-如何实现内存映射机制","children":[]}]},{"level":2,"title":"RocketMQ 生产消费","slug":"rocketmq-生产消费","link":"#rocketmq-生产消费","children":[{"level":3,"title":"【中等】RocketMQ 发送消息的工作流程是怎样的？⭐⭐","slug":"【中等】rocketmq-发送消息的工作流程是怎样的-⭐⭐","link":"#【中等】rocketmq-发送消息的工作流程是怎样的-⭐⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 有几种发送消息方式？⭐","slug":"【中等】rocketmq-有几种发送消息方式-⭐","link":"#【中等】rocketmq-有几种发送消息方式-⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 消费消息的工作流程是怎样的？⭐⭐","slug":"【中等】rocketmq-消费消息的工作流程是怎样的-⭐⭐","link":"#【中等】rocketmq-消费消息的工作流程是怎样的-⭐⭐","children":[]},{"level":3,"title":"【简单】RocketMQ 支持哪几种消费方式？⭐","slug":"【简单】rocketmq-支持哪几种消费方式-⭐","link":"#【简单】rocketmq-支持哪几种消费方式-⭐","children":[]},{"level":3,"title":"【简单】RocketMQ 如何实现批量消息？","slug":"【简单】rocketmq-如何实现批量消息","link":"#【简单】rocketmq-如何实现批量消息","children":[]}]},{"level":2,"title":"RocketMQ 集群","slug":"rocketmq-集群","link":"#rocketmq-集群","children":[{"level":3,"title":"【中等】RocketMQ 如何实现主从复制？⭐⭐","slug":"【中等】rocketmq-如何实现主从复制-⭐⭐","link":"#【中等】rocketmq-如何实现主从复制-⭐⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 如何实现故障转移？⭐⭐","slug":"【中等】rocketmq-如何实现故障转移-⭐⭐","link":"#【中等】rocketmq-如何实现故障转移-⭐⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 如何实现负载均衡？⭐⭐⭐","slug":"【中等】rocketmq-如何实现负载均衡-⭐⭐⭐","link":"#【中等】rocketmq-如何实现负载均衡-⭐⭐⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 的 NameServer 有什么作用？⭐⭐","slug":"【中等】rocketmq-的-nameserver-有什么作用-⭐⭐","link":"#【中等】rocketmq-的-nameserver-有什么作用-⭐⭐","children":[]},{"level":3,"title":"【中等】为什么 RocketMQ 不用 ZooKeeper，而是自己开发 NameServer？⭐⭐","slug":"【中等】为什么-rocketmq-不用-zookeeper-而是自己开发-nameserver-⭐⭐","link":"#【中等】为什么-rocketmq-不用-zookeeper-而是自己开发-nameserver-⭐⭐","children":[]}]},{"level":2,"title":"RocketMQ 可靠传输","slug":"rocketmq-可靠传输","link":"#rocketmq-可靠传输","children":[{"level":3,"title":"【困难】如何保证 RocketMQ 消息不丢失？⭐⭐⭐","slug":"【困难】如何保证-rocketmq-消息不丢失-⭐⭐⭐","link":"#【困难】如何保证-rocketmq-消息不丢失-⭐⭐⭐","children":[]},{"level":3,"title":"【困难】如何保证 RocketMQ 消息不重复？⭐⭐⭐","slug":"【困难】如何保证-rocketmq-消息不重复-⭐⭐⭐","link":"#【困难】如何保证-rocketmq-消息不重复-⭐⭐⭐","children":[]},{"level":3,"title":"【困难】如何保证 RocketMQ 消息有序？⭐⭐⭐","slug":"【困难】如何保证-rocketmq-消息有序-⭐⭐⭐","link":"#【困难】如何保证-rocketmq-消息有序-⭐⭐⭐","children":[]},{"level":3,"title":"【困难】如何处理 RocketMQ 消息积压？⭐⭐","slug":"【困难】如何处理-rocketmq-消息积压-⭐⭐","link":"#【困难】如何处理-rocketmq-消息积压-⭐⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 中如何配置并发消费和顺序消费？⭐","slug":"【中等】rocketmq-中如何配置并发消费和顺序消费-⭐","link":"#【中等】rocketmq-中如何配置并发消费和顺序消费-⭐","children":[]}]},{"level":2,"title":"RocketMQ 架构","slug":"rocketmq-架构","link":"#rocketmq-架构","children":[{"level":3,"title":"【简单】RocketMQ 如何实现消息过滤？⭐","slug":"【简单】rocketmq-如何实现消息过滤-⭐","link":"#【简单】rocketmq-如何实现消息过滤-⭐","children":[]},{"level":3,"title":"【简单】RocketMQ 支持哪几种消息传输模式？⭐","slug":"【简单】rocketmq-支持哪几种消息传输模式-⭐","link":"#【简单】rocketmq-支持哪几种消息传输模式-⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 如何实现延迟消息？⭐","slug":"【中等】rocketmq-如何实现延迟消息-⭐","link":"#【中等】rocketmq-如何实现延迟消息-⭐","children":[]},{"level":3,"title":"【中等】RocketMQ 的消息轨迹如何启用？","slug":"【中等】rocketmq-的消息轨迹如何启用","link":"#【中等】rocketmq-的消息轨迹如何启用","children":[]}]},{"level":2,"title":"RocketMQ 事务","slug":"rocketmq-事务","link":"#rocketmq-事务","children":[{"level":3,"title":"【中等】RocketMQ 如何实现幂等性？⭐","slug":"【中等】rocketmq-如何实现幂等性-⭐","link":"#【中等】rocketmq-如何实现幂等性-⭐","children":[]},{"level":3,"title":"【困难】事务消息是如何工作的？⭐⭐⭐","slug":"【困难】事务消息是如何工作的-⭐⭐⭐","link":"#【困难】事务消息是如何工作的-⭐⭐⭐","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1758642828000,"updatedTime":1767107991000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":4}]},"readingTime":{"minutes":31.9,"words":9569},"filePathRelative":"15.分布式/分布式通信/MQ/RocketMQ/RocketMQ_面试.md","localizedDate":"2022年7月12日","excerpt":"<h1> RocketMQ 面试</h1>\\n<h2> RocketMQ 简介</h2>\\n<h3> 【简单】RocketMQ 是什么？⭐</h3>\\n<p><strong>RocketMQ 是一个开源分布式消息中间件</strong>。最初由阿里巴巴开发，现在是 Apache 顶级项目。</p>\\n<p><strong>RocketMQ 的核心概念</strong></p>\\n<ul>\\n<li><strong>核心组件</strong>\\n<ul>\\n<li><strong>生产者（Producer）</strong>：从 NameServer 获取路由信息后，将消息发送到 Broker。</li>\\n<li><strong>消费者（Consumer）</strong>：从 NameServer 获取路由信息后，从 Broker 拉取并消费消息。</li>\\n<li><strong>代理（Broker）</strong>：负责消息的存储、投递和查询。采用主从结构保证高可用。</li>\\n<li><strong>命名服务（NameServer）</strong>：管理所有 Broker 的地址列表。无状态，简单高效。</li>\\n</ul>\\n</li>\\n<li><strong>逻辑存储</strong>\\n<ul>\\n<li><strong>主题（Topic）</strong>：消息的一级分类，生产者和消费者操作的逻辑对象。</li>\\n<li><strong>标签（Tag）</strong>：Topic 下的二级分类，用于对消息进行过滤。</li>\\n<li><strong>消息（Message）</strong>：包含 Body（消息体）、Topic、Tags（标签）、Keys（唯一键）等属性。</li>\\n<li><strong>消息队列（Message Queue）</strong>：Topic 在物理上的分区，是负载均衡和并行处理的最小单位。</li>\\n</ul>\\n</li>\\n<li><strong>物理存储</strong>\\n<ul>\\n<li><strong>提交日志（Commit Log）</strong>：所有 Topic 的消息都<strong>顺序追加</strong>到这一个文件中。这是实现高吞吐写入的关键。</li>\\n<li><strong>消费队列（Consume Queue）</strong>：作为 CommitLog 的<strong>索引文件</strong>。每个 Queue 对应一个，记录消息在 CommitLog 中的位置，实现高效的读取。</li>\\n<li><strong>索引文件（Index File）</strong>：提供按 <strong>Message Key</strong> 或时间范围查询消息的能力。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
