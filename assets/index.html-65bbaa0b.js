import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,e as t}from"./app-7555fb14.js";const e={},o=t(`<h1 id="mybatis-面试" tabindex="-1"><a class="header-anchor" href="#mybatis-面试" aria-hidden="true">#</a> MyBatis 面试</h1><h3 id="【简单】mybatis-中-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#【简单】mybatis-中-和-的区别是什么" aria-hidden="true">#</a> 【简单】MyBatis 中 #{} 和 \${} 的区别是什么？</h3><p><strong>MyBatis 中 <code>#{}</code> 和 <code>\${}</code> 的区别对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong><code>#{}</code>（预编译占位符）</strong></th><th><strong><code>\${}</code>（字符串拼接）</strong></th></tr></thead><tbody><tr><td><strong>底层原理</strong></td><td>使用 <code>PreparedStatement</code>，生成带 <code>?</code> 的 SQL，预编译防止注入。</td><td>直接拼接字符串到 SQL 中，无参数化处理。</td></tr><tr><td><strong>SQL 注入风险</strong></td><td>❌ 安全（自动转义特殊字符）。</td><td>✔️ 高风险（需手动过滤参数）。</td></tr><tr><td><strong>适用场景</strong></td><td>动态条件值（如 <code>WHERE id = #{value}</code>）。</td><td>动态表名、列名（如 <code>ORDER BY \${column}</code>）。</td></tr><tr><td><strong>数据类型处理</strong></td><td>自动识别 Java 类型，匹配 JDBC 类型（如 <code>Date</code>→<code>TIMESTAMP</code>）。</td><td>原样替换，可能导致语法错误（如字符串未加引号）。</td></tr><tr><td><strong>性能</strong></td><td>预编译 SQL 可复用，高效。</td><td>每次生成新 SQL，效率较低。</td></tr><tr><td><strong>示例</strong></td><td><code>xml SELECT * FROM user WHERE name = #{name}</code></td><td><code>xml SELECT * FROM \${tableName}</code></td></tr></tbody></table><p><strong>关键结论</strong></p><ul><li><strong>优先用 <code>#{}</code></strong>：处理用户输入或条件值，确保安全。</li><li><strong>谨慎用 <code>\${}</code></strong>：仅用于非用户输入的动态 SQL 部分（如动态表名），需手动过滤参数。</li><li><strong>常见错误</strong>： <ul><li>错误：<code>ORDER BY #{column}</code>（预编译后引号包裹列名，语法错误）。</li><li>正确：<code>ORDER BY \${column} LIMIT #{limit}</code>（混合使用）。</li></ul></li></ul><p><strong>底层机制对比</strong></p><p><strong><code>#{}</code> 的执行流程（安全）</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 生成的 SQL（预编译）</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> ?<span class="token punctuation">;</span>

<span class="token comment">-- 参数值通过 PreparedStatement 安全传递</span>
pstmt<span class="token punctuation">.</span>setInt<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>\${}</code> 的执行流程（风险）</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 生成的 SQL（直接拼接）</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Alice&#39;</span> <span class="token operator">OR</span> <span class="token string">&#39;1&#39;</span><span class="token operator">=</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span>  <span class="token comment">-- 注入攻击示例</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>何时必须使用 <code>\${}</code>？</strong></p><ol><li><p><strong>动态表名/列名</strong>：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>SELECT * FROM \${tableName} WHERE \${column} = #{value}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>SQL 函数或关键字</strong>：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>ORDER BY \${sortField} \${sortOrder}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p><strong>安全建议</strong></p><ul><li>使用 <code>\${}</code> 时，用 <code>@Param</code> 注解白名单校验：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByTable</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">&quot;tableName&quot;</span><span class="token punctuation">)</span> <span class="token class-name">String</span> tableName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 手动校验表名合法性 --&gt;</span>
SELECT * FROM \${tableName}
WHERE 1=1
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>tableName in {&#39;user&#39;, &#39;order&#39;}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  AND status = #{status}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="【简单】mybatis-如何实现一对一、一对多的关联查询" tabindex="-1"><a class="header-anchor" href="#【简单】mybatis-如何实现一对一、一对多的关联查询" aria-hidden="true">#</a> 【简单】MyBatis 如何实现一对一、一对多的关联查询 ？</h3><h3 id="【简单】使用-mybatis-的-mapper-接口调用时有哪些要求" tabindex="-1"><a class="header-anchor" href="#【简单】使用-mybatis-的-mapper-接口调用时有哪些要求" aria-hidden="true">#</a> 【简单】使用 MyBatis 的 mapper 接口调用时有哪些要求？</h3><h3 id="【简单】mybatis-自带的连接池有了解过吗" tabindex="-1"><a class="header-anchor" href="#【简单】mybatis-自带的连接池有了解过吗" aria-hidden="true">#</a> 【简单】MyBatis 自带的连接池有了解过吗？</h3><h3 id="【简单】mybatis-和-hibernate-有哪些差异" tabindex="-1"><a class="header-anchor" href="#【简单】mybatis-和-hibernate-有哪些差异" aria-hidden="true">#</a> 【简单】MyBatis 和 Hibernate 有哪些差异？</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>MyBatis</strong></th><th><strong>Hibernate</strong></th></tr></thead><tbody><tr><td><strong>SQL 灵活性</strong></td><td>方便优化 SQL，<strong>灵活性高</strong></td><td>自动生成 SQL，复杂查询需 HQL 或原生 SQL，<strong>灵活性较低</strong></td></tr><tr><td><strong>学习成本</strong></td><td>需熟悉 SQL 和数据库特性，适合有 SQL 经验的团队。</td><td>面向对象思维，适合快速上手 ORM 的团队。</td></tr><tr><td><strong>开发效率</strong></td><td>需手动编写 SQL 和结果映射，适合定制化需求。</td><td>自动化 CRUD，快速开发简单应用。</td></tr><tr><td><strong>缓存机制</strong></td><td>提供一级/二级缓存，需手动管理。</td><td>内置多级缓存（查询缓存、集合缓存），自动化程度高。</td></tr><tr><td><strong>数据库兼容性</strong></td><td>SQL 依赖具体数据库语法，<strong>移植性较差</strong>。</td><td>通过方言（Dialect）适配多数据库，<strong>移植性好</strong>。</td></tr><tr><td><strong>关联映射</strong></td><td>需手动配置 <code>&lt;association&gt;</code>/<code>&lt;collection&gt;</code>。</td><td>自动管理对象关系（如 <code>@OneToMany</code>），配置简洁。</td></tr><tr><td><strong>适用场景</strong></td><td>复杂查询、高性能系统（如金融、电商）。</td><td>快速开发、对象模型复杂的应用（如管理后台）。</td></tr></tbody></table><p><strong>总结选择建议</strong></p><ul><li><p><strong>选择 MyBatis</strong>：</p><ul><li>需要精细控制 SQL，追求极致性能。</li><li>项目涉及多表复杂查询或数据库特性优化。</li></ul></li><li><p><strong>选择 Hibernate</strong>：</p><ul><li>快速开发，业务以简单 CRUD 为主。</li><li>团队熟悉 ORM，希望减少 SQL 编写。</li></ul></li></ul><p><strong>混合使用</strong>：部分项目用 MyBatis 处理复杂查询，Hibernate 处理简单模块。</p><h3 id="【中等】说说-mybatis-的缓存机制" tabindex="-1"><a class="header-anchor" href="#【中等】说说-mybatis-的缓存机制" aria-hidden="true">#</a> 【中等】说说 MyBatis 的缓存机制？</h3><h3 id="【中等】mybatis-写个-xml-映射文件-再写个-dao-接口就能执行-这个原理是什么" tabindex="-1"><a class="header-anchor" href="#【中等】mybatis-写个-xml-映射文件-再写个-dao-接口就能执行-这个原理是什么" aria-hidden="true">#</a> 【中等】MyBatis 写个 Xml 映射文件，再写个 DAO 接口就能执行，这个原理是什么？</h3><h3 id="【中等】mybatis-动态-sql-有什么用-执行原理-有哪些动态-sql" tabindex="-1"><a class="header-anchor" href="#【中等】mybatis-动态-sql-有什么用-执行原理-有哪些动态-sql" aria-hidden="true">#</a> 【中等】MyBatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</h3><h3 id="【中等】mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#【中等】mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" aria-hidden="true">#</a> 【中等】MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><h3 id="【中等】简述-mybatis-的插件运行原理-以及如何编写一个插件" tabindex="-1"><a class="header-anchor" href="#【中等】简述-mybatis-的插件运行原理-以及如何编写一个插件" aria-hidden="true">#</a> 【中等】简述 MyBatis 的插件运行原理，以及如何编写一个插件？</h3><h3 id="【中等】jdbc-编程有哪些不足之处-mybatis-是如何解决的" tabindex="-1"><a class="header-anchor" href="#【中等】jdbc-编程有哪些不足之处-mybatis-是如何解决的" aria-hidden="true">#</a> 【中等】JDBC 编程有哪些不足之处，MyBatis 是如何解决的？</h3><h3 id="【中等】mybatis-都有哪些-executor-执行器-它们之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#【中等】mybatis-都有哪些-executor-执行器-它们之间的区别是什么" aria-hidden="true">#</a> 【中等】MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><h3 id="【中等】mybatis-如何实现数据库类型和-java-类型的转换的" tabindex="-1"><a class="header-anchor" href="#【中等】mybatis-如何实现数据库类型和-java-类型的转换的" aria-hidden="true">#</a> 【中等】MyBatis 如何实现数据库类型和 Java 类型的转换的？</h3><h2 id="【中等】mybatis-有哪些核心组件" tabindex="-1"><a class="header-anchor" href="#【中等】mybatis-有哪些核心组件" aria-hidden="true">#</a> 【中等】MyBatis 有哪些核心组件？</h2><p>MyBatis 有以下核心组件：</p><ul><li><strong><code>SqlSessionFactoryBuilder</code></strong>：负责创建 <code>SqlSessionFactory</code> 实例。用完即弃。</li><li><strong><code>SqlSessionFactory</code></strong>：负责创建 <code>SqlSession</code> 实例。全局单例，配置中心。</li><li><strong><code>SqlSession</code></strong>：通过方法签名和 <code>Mapper</code> 相互映射。请求级核心，需及时关闭。</li><li><strong><code>Mapper</code></strong>：映射器是一些由用户创建的、绑定 SQL 语句的接口。轻量级对象，随用随建。</li></ul><p>下面是它们之间的关系：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SqlSessionFactoryBuilder → SqlSessionFactory → SqlSession → Mapper Proxy
       (方法级)               (应用级)           (请求级)        (方法级)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510113446.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="sqlsessionfactorybuilder" tabindex="-1"><a class="header-anchor" href="#sqlsessionfactorybuilder" aria-hidden="true">#</a> SqlSessionFactoryBuilder</h3><ul><li><strong>生命周期</strong>：<strong>方法级</strong>（最短）</li><li><strong>作用</strong>：用于构建 <code>SqlSessionFactory</code>，解析 XML 配置（如 <code>mybatis-config.xml</code>）。</li><li><strong>特点</strong>： <ul><li>构建完成后即可销毁，无状态，不占用资源。</li><li>通常作为局部变量使用。</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SqlSessionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="sqlsessionfactory" tabindex="-1"><a class="header-anchor" href="#sqlsessionfactory" aria-hidden="true">#</a> SqlSessionFactory</h3><ul><li><strong>生命周期</strong>：<strong>应用级</strong>（最长）</li><li><strong>作用</strong>：创建 <code>SqlSession</code>，全局唯一，线程安全。</li><li><strong>特点</strong>： <ul><li>通常作为单例存在于整个应用运行期间。</li><li>维护数据库连接池和全局配置（如缓存、别名）。</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 推荐通过单例管理</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisUtil</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SqlSessionFactory</span> factory<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">getFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sqlsession" tabindex="-1"><a class="header-anchor" href="#sqlsession" aria-hidden="true">#</a> SqlSession</h3><ul><li><strong>生命周期</strong>：<strong>请求/事务级</strong></li><li><strong>作用</strong>：执行 SQL、获取 Mapper 接口实例、管理事务。</li><li><strong>特点</strong>： <ul><li><strong>非线程安全</strong>，每次请求需创建新实例，用完后必须关闭（避免连接泄漏）。</li><li>默认不自动提交事务，需手动 <code>commit()</code> 或 <code>rollback()</code>。</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">SqlSession</span> session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 自动关闭</span>
    <span class="token class-name">UserMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    session<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 提交事务</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mapper" tabindex="-1"><a class="header-anchor" href="#mapper" aria-hidden="true">#</a> Mapper</h3><ul><li><strong>生命周期</strong>：<strong>方法级</strong>（与 <code>SqlSession</code> 绑定）</li><li><strong>作用</strong>：通过动态代理将接口方法调用转换为 SQL 执行。</li><li><strong>特点</strong>： <ul><li>由 <code>SqlSession</code> 创建，生命周期跟随 <code>SqlSession</code>。</li><li>无需手动实现，MyBatis 自动生成代理类。</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 代理对象随 SqlSession 销毁而失效</span>
<span class="token class-name">UserMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="【中等】能详细说说-mybatis-的执行流程吗" tabindex="-1"><a class="header-anchor" href="#【中等】能详细说说-mybatis-的执行流程吗" aria-hidden="true">#</a> 【中等】能详细说说 MyBatis 的执行流程吗？</h2><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512173437.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="【困难】mybatis-的架构是如何设计的" tabindex="-1"><a class="header-anchor" href="#【困难】mybatis-的架构是如何设计的" aria-hidden="true">#</a> 【困难】MyBatis 的架构是如何设计的？</h2><p>MyBatis 的架构设计通过 <strong>分层解耦</strong> 和 <strong>动态代理</strong> 实现了 SQL 与 Java 代码的分离，其核心在于：</p><ul><li><strong>配置驱动</strong>：集中管理 SQL 和映射规则。</li><li><strong>组件化</strong>：各层职责单一，易于扩展（如插件）。</li><li><strong>平衡灵活与易用</strong>：既保留 JDBC 的掌控力，又简化了重复操作。</li></ul><p>这种设计使其在需要高性能和灵活 SQL 的场景中表现优异，尤其适合中大型复杂业务系统。</p><p>MyBatis 的架构设计以 <strong>SQL 与 Java 对象的灵活映射</strong> 为核心，采用分层模块化设计，平衡了灵活性与易用性。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512114852.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>分层架构设计</strong></p><p>MyBatis 的架构分为四层，各层职责明确，通过接口解耦：</p><table><thead><tr><th><strong>层级</strong></th><th><strong>核心组件</strong></th><th><strong>职责</strong></th></tr></thead><tbody><tr><td><strong>接口层</strong></td><td><code>SqlSession</code>、<code>Mapper</code> 接口</td><td>提供开发者使用的 API（如 <code>selectOne</code>、<code>insert</code>），屏蔽底层实现细节。</td></tr><tr><td><strong>核心处理层</strong></td><td><code>Executor</code>、<code>StatementHandler</code></td><td>执行 SQL 语句、处理参数绑定和结果映射，实现插件拦截链。</td></tr><tr><td><strong>基础支撑层</strong></td><td><code>DataSource</code>、<code>Transaction</code></td><td>管理数据库连接池、事务，提供类型转换（<code>TypeHandler</code>）和缓存支持。</td></tr><tr><td><strong>扩展层</strong></td><td><code>Interceptor</code>（插件）</td><td>通过动态代理拦截核心组件，实现功能扩展（如分页、性能监控）。</td></tr></tbody></table><h3 id="基础支撑层" tabindex="-1"><a class="header-anchor" href="#基础支撑层" aria-hidden="true">#</a> 基础支撑层</h3><p><strong>功能</strong>：为上层提供通用能力支持</p><ul><li><strong>类型处理器 (TypeHandler)</strong>：处理 Java 类型与 JDBC 类型转换（如 <code>String</code> ↔ <code>VARCHAR</code>）。支持自定义扩展（如枚举类型转换）。</li><li><strong>连接管理</strong>：集成连接池（如 HikariCP、Druid），管理数据库连接。</li><li><strong>事务管理</strong>：提供 JDBC 和 Managed 两种事务模式（可集成 Spring 事务）。</li><li><strong>缓存管理</strong>：一级缓存（<code>SqlSession</code> 级别）、二级缓存（<code>Mapper</code> 级别）。支持 Redis、Ehcache 等第三方缓存集成。</li></ul><h3 id="核心处理层" tabindex="-1"><a class="header-anchor" href="#核心处理层" aria-hidden="true">#</a> 核心处理层</h3><p><strong>功能</strong>：执行 SQL 并处理结果映射</p><ul><li><strong>配置解析 (Configuration)</strong>：加载 <code>mybatis-config.xml</code> 和 <code>Mapper.xml</code>，存储所有配置信息（如别名、插件）。</li><li><strong>SQL 解析 (SqlSource &amp; BoundSql)</strong>：解析动态 SQL（<code>&lt;if&gt;</code>、<code>&lt;foreach&gt;</code>），生成可执行的 SQL 字符串和参数映射。</li><li><strong>执行器 (Executor)</strong><ul><li><strong>类型</strong>： <ul><li><code>SimpleExecutor</code>：默认执行器，每次执行新开 <code>PreparedStatement</code>。</li><li><code>ReuseExecutor</code>：复用 <code>Statement</code> 对象。</li><li><code>BatchExecutor</code>：批量操作优化。</li></ul></li><li><strong>职责</strong>：调用 JDBC 执行 SQL，触发插件拦截链。</li></ul></li><li><strong>结果集处理 (ResultSetHandler)</strong>：将 <code>ResultSet</code> 转换为 Java 对象（根据 <code>ResultMap</code> 或自动映射）。</li></ul>`,66),i=[o];function r(l,c){return n(),a("div",null,i)}const u=s(e,[["render",r],["__file","index.html.vue"]]);export{u as default};
