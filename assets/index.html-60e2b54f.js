const e=JSON.parse('{"key":"v-7215c62e","path":"/pages/ed3f0c85/","title":"《极客时间教程 - Java 并发编程实战》笔记一","lang":"zh-CN","frontmatter":{"title":"《极客时间教程 - Java 并发编程实战》笔记一","date":"2024-08-26T14:36:05.000Z","permalink":"/pages/ed3f0c85/","category":["笔记","Java"],"tag":["Java","并发"],"description":"《极客时间教程 - Java 并发编程实战》笔记一 学习攻略 如何才能学好并发编程？ 开篇词 你为什么需要学习并发编程？ 并发编程可以总结为三个核心问题：分工、同步、互斥。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/ed3f0c85/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"《极客时间教程 - Java 并发编程实战》笔记一"}],["meta",{"property":"og:description","content":"《极客时间教程 - Java 并发编程实战》笔记一 学习攻略 如何才能学好并发编程？ 开篇词 你为什么需要学习并发编程？ 并发编程可以总结为三个核心问题：分工、同步、互斥。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-27T13:28:08.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2024-08-26T14:36:05.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-27T13:28:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《极客时间教程 - Java 并发编程实战》笔记一\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-26T14:36:05.000Z\\",\\"dateModified\\":\\"2025-09-27T13:28:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"学习攻略 如何才能学好并发编程？","slug":"学习攻略-如何才能学好并发编程","link":"#学习攻略-如何才能学好并发编程","children":[]},{"level":2,"title":"开篇词 你为什么需要学习并发编程？","slug":"开篇词-你为什么需要学习并发编程","link":"#开篇词-你为什么需要学习并发编程","children":[]},{"level":2,"title":"可见性、原子性和有序性问题：并发编程 Bug 的源头","slug":"可见性、原子性和有序性问题-并发编程-bug-的源头","link":"#可见性、原子性和有序性问题-并发编程-bug-的源头","children":[{"level":3,"title":"缓存导致的可见性问题","slug":"缓存导致的可见性问题","link":"#缓存导致的可见性问题","children":[]},{"level":3,"title":"线程切换带来的原子性问题","slug":"线程切换带来的原子性问题","link":"#线程切换带来的原子性问题","children":[]},{"level":3,"title":"编译优化带来的有序性问题","slug":"编译优化带来的有序性问题","link":"#编译优化带来的有序性问题","children":[]}]},{"level":2,"title":"Java 内存模型：看 Java 如何解决可见性和有序性问题","slug":"java-内存模型-看-java-如何解决可见性和有序性问题","link":"#java-内存模型-看-java-如何解决可见性和有序性问题","children":[{"level":3,"title":"Happens-Before 规则","slug":"happens-before-规则","link":"#happens-before-规则","children":[]}]},{"level":2,"title":"互斥锁（上）：解决原子性问题","slug":"互斥锁-上-解决原子性问题","link":"#互斥锁-上-解决原子性问题","children":[{"level":3,"title":"简易锁模型","slug":"简易锁模型","link":"#简易锁模型","children":[]},{"level":3,"title":"改进后的锁模型","slug":"改进后的锁模型","link":"#改进后的锁模型","children":[]},{"level":3,"title":"Java 语言提供的锁技术：synchronized","slug":"java-语言提供的锁技术-synchronized","link":"#java-语言提供的锁技术-synchronized","children":[]},{"level":3,"title":"用 synchronized 解决 count+=1 问题","slug":"用-synchronized-解决-count-1-问题","link":"#用-synchronized-解决-count-1-问题","children":[]},{"level":3,"title":"锁和受保护资源的关系","slug":"锁和受保护资源的关系","link":"#锁和受保护资源的关系","children":[]}]},{"level":2,"title":"互斥锁（下）：如何用一把锁保护多个资源？","slug":"互斥锁-下-如何用一把锁保护多个资源","link":"#互斥锁-下-如何用一把锁保护多个资源","children":[{"level":3,"title":"保护没有关联关系的多个资源","slug":"保护没有关联关系的多个资源","link":"#保护没有关联关系的多个资源","children":[]},{"level":3,"title":"保护有关联关系的多个资源","slug":"保护有关联关系的多个资源","link":"#保护有关联关系的多个资源","children":[]},{"level":3,"title":"使用锁的正确姿势","slug":"使用锁的正确姿势","link":"#使用锁的正确姿势","children":[]}]},{"level":2,"title":"一不小心就死锁了，怎么办？","slug":"一不小心就死锁了-怎么办","link":"#一不小心就死锁了-怎么办","children":[{"level":3,"title":"如何预防死锁","slug":"如何预防死锁","link":"#如何预防死锁","children":[]}]},{"level":2,"title":"用“等待-通知”机制优化循环等待","slug":"用-等待-通知-机制优化循环等待","link":"#用-等待-通知-机制优化循环等待","children":[{"level":3,"title":"用 synchronized 实现等待-通知机制","slug":"用-synchronized-实现等待-通知机制","link":"#用-synchronized-实现等待-通知机制","children":[]},{"level":3,"title":"小试牛刀：一个更好地资源分配器","slug":"小试牛刀-一个更好地资源分配器","link":"#小试牛刀-一个更好地资源分配器","children":[]},{"level":3,"title":"尽量使用 notifyAll()","slug":"尽量使用-notifyall","link":"#尽量使用-notifyall","children":[]}]},{"level":2,"title":"安全性、活跃性以及性能问题","slug":"安全性、活跃性以及性能问题","link":"#安全性、活跃性以及性能问题","children":[{"level":3,"title":"安全性问题","slug":"安全性问题","link":"#安全性问题","children":[]},{"level":3,"title":"活跃性问题","slug":"活跃性问题","link":"#活跃性问题","children":[]},{"level":3,"title":"性能问题","slug":"性能问题","link":"#性能问题","children":[]}]},{"level":2,"title":"管程：并发编程的万能钥匙","slug":"管程-并发编程的万能钥匙","link":"#管程-并发编程的万能钥匙","children":[{"level":3,"title":"什么是管程","slug":"什么是管程","link":"#什么是管程","children":[]},{"level":3,"title":"MESA 模型","slug":"mesa-模型","link":"#mesa-模型","children":[]}]},{"level":2,"title":"Java 线程（上）：Java 线程的生命周期","slug":"java-线程-上-java-线程的生命周期","link":"#java-线程-上-java-线程的生命周期","children":[{"level":3,"title":"通用的线程生命周期","slug":"通用的线程生命周期","link":"#通用的线程生命周期","children":[]},{"level":3,"title":"Java 中线程的生命周期","slug":"java-中线程的生命周期","link":"#java-中线程的生命周期","children":[]}]},{"level":2,"title":"Java 线程（中）：创建多少线程才是合适的？","slug":"java-线程-中-创建多少线程才是合适的","link":"#java-线程-中-创建多少线程才是合适的","children":[{"level":3,"title":"为什么要使用多线程？","slug":"为什么要使用多线程","link":"#为什么要使用多线程","children":[]},{"level":3,"title":"多线程的应用场景有哪些？","slug":"多线程的应用场景有哪些","link":"#多线程的应用场景有哪些","children":[]},{"level":3,"title":"创建多少线程合适？","slug":"创建多少线程合适","link":"#创建多少线程合适","children":[]}]},{"level":2,"title":"Java 线程（下）：为什么局部变量是线程安全的？","slug":"java-线程-下-为什么局部变量是线程安全的","link":"#java-线程-下-为什么局部变量是线程安全的","children":[{"level":3,"title":"方法是如何被执行的","slug":"方法是如何被执行的","link":"#方法是如何被执行的","children":[]},{"level":3,"title":"局部变量存哪里？","slug":"局部变量存哪里","link":"#局部变量存哪里","children":[]},{"level":3,"title":"调用栈与线程","slug":"调用栈与线程","link":"#调用栈与线程","children":[]},{"level":3,"title":"线程封闭","slug":"线程封闭","link":"#线程封闭","children":[]}]},{"level":2,"title":"如何用面向对象思想写好并发程序？","slug":"如何用面向对象思想写好并发程序","link":"#如何用面向对象思想写好并发程序","children":[{"level":3,"title":"一、封装共享变量","slug":"一、封装共享变量","link":"#一、封装共享变量","children":[]},{"level":3,"title":"二、识别共享变量间的约束条件","slug":"二、识别共享变量间的约束条件","link":"#二、识别共享变量间的约束条件","children":[]},{"level":3,"title":"三、制定并发访问策略","slug":"三、制定并发访问策略","link":"#三、制定并发访问策略","children":[]}]},{"level":2,"title":"理论基础模块热点问题答疑","slug":"理论基础模块热点问题答疑","link":"#理论基础模块热点问题答疑","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1758979688000,"updatedTime":1758979688000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":25.66,"words":7699},"filePathRelative":"00.笔记/Java/极客时间教程-Java并发编程实战笔记一.md","localizedDate":"2024年8月26日","excerpt":"<h1> 《极客时间教程 - Java 并发编程实战》笔记一</h1>\\n<h2> 学习攻略 如何才能学好并发编程？</h2>\\n<figure><img src=\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202408261435639.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<h2> 开篇词 你为什么需要学习并发编程？</h2>\\n<p><strong>并发编程可以总结为三个核心问题：分工、同步、互斥。</strong></p>","autoDesc":true}');export{e as data};
