const e=JSON.parse('{"key":"v-908a2912","path":"/pages/667f5956/","title":"Java 虚拟机面试二","lang":"zh-CN","frontmatter":{"title":"Java 虚拟机面试二","date":"2025-04-30T06:33:26.000Z","order":11,"permalink":"/pages/667f5956/","category":["Java","JavaCore","面试"],"tag":["Java","JavaCore","面试","JVM"],"description":"Java 虚拟机面试二 垃圾收集 【困难】如何判断 Java 对象是否可以被回收？⭐⭐⭐ 判断 Java 对象是否可以被回收有两种方法： 引用计数法 可达性分析法 引用计数法 引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 引用计数算法简单高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/667f5956/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 虚拟机面试二"}],["meta",{"property":"og:description","content":"Java 虚拟机面试二 垃圾收集 【困难】如何判断 Java 对象是否可以被回收？⭐⭐⭐ 判断 Java 对象是否可以被回收有两种方法： 引用计数法 可达性分析法 引用计数法 引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 引用计数算法简单高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-12T00:30:44.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2025-04-30T06:33:26.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-12T00:30:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 虚拟机面试二\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-30T06:33:26.000Z\\",\\"dateModified\\":\\"2026-01-12T00:30:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"垃圾收集","slug":"垃圾收集","link":"#垃圾收集","children":[{"level":3,"title":"【困难】如何判断 Java 对象是否可以被回收？⭐⭐⭐","slug":"【困难】如何判断-java-对象是否可以被回收-⭐⭐⭐","link":"#【困难】如何判断-java-对象是否可以被回收-⭐⭐⭐","children":[]},{"level":3,"title":"【中等】为什么不建议使用 finalize()？","slug":"【中等】为什么不建议使用-finalize","link":"#【中等】为什么不建议使用-finalize","children":[]},{"level":3,"title":"【中等】Java 对象有哪些引用类型？⭐⭐","slug":"【中等】java-对象有哪些引用类型-⭐⭐","link":"#【中等】java-对象有哪些引用类型-⭐⭐","children":[]},{"level":3,"title":"【中等】Java 中有哪些垃圾回收算法？⭐⭐⭐","slug":"【中等】java-中有哪些垃圾回收算法-⭐⭐⭐","link":"#【中等】java-中有哪些垃圾回收算法-⭐⭐⭐","children":[]},{"level":3,"title":"【中等】Java 中常见的垃圾收集器有哪些？⭐⭐⭐","slug":"【中等】java-中常见的垃圾收集器有哪些-⭐⭐⭐","link":"#【中等】java-中常见的垃圾收集器有哪些-⭐⭐⭐","children":[]},{"level":3,"title":"【困难】为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？⭐⭐","slug":"【困难】为什么-java-8-移除了永久代-permgen-并引入了元空间-metaspace-⭐⭐","link":"#【困难】为什么-java-8-移除了永久代-permgen-并引入了元空间-metaspace-⭐⭐","children":[]},{"level":3,"title":"【困难】Java 中的 Young GC、Old GC、Full GC 和 Mixed GC 的区别是什么？⭐⭐","slug":"【困难】java-中的-young-gc、old-gc、full-gc-和-mixed-gc-的区别是什么-⭐⭐","link":"#【困难】java-中的-young-gc、old-gc、full-gc-和-mixed-gc-的区别是什么-⭐⭐","children":[]},{"level":3,"title":"【困难】Java 的 CMS 垃圾回收流程是怎样的？⭐⭐","slug":"【困难】java-的-cms-垃圾回收流程是怎样的-⭐⭐","link":"#【困难】java-的-cms-垃圾回收流程是怎样的-⭐⭐","children":[]},{"level":3,"title":"【困难】Java 的 G1 垃圾回收流程是怎样的？⭐⭐","slug":"【困难】java-的-g1-垃圾回收流程是怎样的-⭐⭐","link":"#【困难】java-的-g1-垃圾回收流程是怎样的-⭐⭐","children":[]},{"level":3,"title":"【困难】Java 的 ZGC 垃圾回收流程是怎样的？","slug":"【困难】java-的-zgc-垃圾回收流程是怎样的","link":"#【困难】java-的-zgc-垃圾回收流程是怎样的","children":[]},{"level":3,"title":"【困难】JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？","slug":"【困难】jvm-垃圾回收时产生的-concurrent-mode-failure-的原因是什么","link":"#【困难】jvm-垃圾回收时产生的-concurrent-mode-failure-的原因是什么","children":[]}]},{"level":2,"title":"调优","slug":"调优","link":"#调优","children":[{"level":3,"title":"【简单】JDK 内置了哪些工具？⭐⭐","slug":"【简单】jdk-内置了哪些工具-⭐⭐","link":"#【简单】jdk-内置了哪些工具-⭐⭐","children":[]},{"level":3,"title":"【中等】常用的 JVM 配置参数有哪些？⭐⭐⭐","slug":"【中等】常用的-jvm-配置参数有哪些-⭐⭐⭐","link":"#【中等】常用的-jvm-配置参数有哪些-⭐⭐⭐","children":[]},{"level":3,"title":"【中等】如何在 Java 中进行内存泄漏分析？⭐⭐⭐","slug":"【中等】如何在-java-中进行内存泄漏分析-⭐⭐⭐","link":"#【中等】如何在-java-中进行内存泄漏分析-⭐⭐⭐","children":[]},{"level":3,"title":"【中等】如何对 Java 的垃圾回收进行调优？⭐⭐","slug":"【中等】如何对-java-的垃圾回收进行调优-⭐⭐","link":"#【中等】如何对-java-的垃圾回收进行调优-⭐⭐","children":[]}]}],"git":{"createdTime":1757980215000,"updatedTime":1768177844000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":4}]},"readingTime":{"minutes":30.24,"words":9073},"filePathRelative":"01.Java/JavaCore/面试/Java_面试_虚拟机（二）.md","localizedDate":"2025年4月30日","excerpt":"<h1> Java 虚拟机面试二</h1>\\n<h2> 垃圾收集</h2>\\n<h3> 【困难】如何判断 Java 对象是否可以被回收？⭐⭐⭐</h3>\\n<p>判断 Java 对象是否可以被回收有两种方法：</p>\\n<ul>\\n<li>引用计数法</li>\\n<li>可达性分析法</li>\\n</ul>\\n<h4> 引用计数法</h4>\\n<p>引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>\\n<p>引用计数算法<strong>简单高效</strong>，但是<strong>存在循环引用问题</strong>——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>","autoDesc":true}');export{e as data};
