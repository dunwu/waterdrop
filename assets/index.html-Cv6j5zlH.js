import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as i,f as a,a as t,o}from"./app-DVxB14Z_.js";const r={};function l(d,e){return o(),n("div",null,[e[0]||(e[0]=i("h1",{id:"mongodb-面试",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#mongodb-面试"},[i("span",null,"MongoDB 面试")])],-1)),a(" more "),e[1]||(e[1]=t(`<h2 id="mongodb-简介" tabindex="-1"><a class="header-anchor" href="#mongodb-简介"><span>MongoDB 简介</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://www.mongodb.com/zh-cn/docs/manual/introduction/" target="_blank" rel="noopener noreferrer">MongoDB 官方文档之 MongoDB 简介</a></li><li><a href="https://www.infoq.cn/article/3d4suwkc2fvikykemnvw" target="_blank" rel="noopener noreferrer">MongoDB 简史</a></li><li><a href="https://blog.csdn.net/JiekeXu/article/details/143670868" target="_blank" rel="noopener noreferrer">MongoDB 发展历史及各主要版本新特性概述</a></li></ul></div><h3 id="【简单】mongodb-是什么" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-是什么"><span>【简单】MongoDB 是什么？</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>文档数据库、C++、CRUD、聚合、文本搜索、地理空间搜索</p></div><p>MongoDB 是一个<strong>面向文档</strong>的开源 NoSQL 数据库系统，由 <strong>C++</strong> 编写的。MongoDB 支持“<strong>无模式</strong>”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 <strong>文档型数据库</strong> 。</p><p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。</p><p>MongoDB 提供了丰富的功能：</p><ul><li><a href="https://www.mongodb.com/zh-cn/docs/manual/crud/#std-label-crud" target="_blank" rel="noopener noreferrer"><strong>读写操作 (CRUD)</strong></a></li><li><a href="https://www.mongodb.com/zh-cn/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline" target="_blank" rel="noopener noreferrer"><strong>数据聚合</strong></a></li><li><a href="https://www.mongodb.com/zh-cn/docs/manual/text-search/#std-label-text-search" target="_blank" rel="noopener noreferrer"><strong>文本搜索</strong></a></li><li><a href="https://www.mongodb.com/zh-cn/docs/manual/tutorial/geospatial-tutorial/" target="_blank" rel="noopener noreferrer"><strong>地理空间搜索</strong></a></li><li>...</li></ul><h3 id="【简单】mongodb-有什么特性" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-有什么特性"><span>【简单】MongoDB 有什么特性？</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>面向文档、无模式、丰富的数据类型、丰富的查询方式、支持聚合、支持事务、支持压缩、分布式</p></div><p>MongoDB 主要有以下特性：</p><ul><li><strong>面向文档</strong>：MongoDB 将数据记录存储为 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/document/#std-label-bson-document-format" target="_blank" rel="noopener noreferrer">BSON 文档</a>。BSON 是 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-JSON" target="_blank" rel="noopener noreferrer">JSON</a> 文档的二进制表示形式，尽管它包含的数据类型比 JSON 多。最大 BSON 文档大小为 16 MB。</li><li><strong>无模式</strong>：MongoDB 中没有预定义模式（predefined schema），文档键值的类型和大小不是固定的。由于没有固定的模式，因此按需添加或删除字段变得更容易。</li><li><strong>丰富的查询方式</strong>：MongoDB 支持基本的 CRUD 以及数据聚合、文本搜索和地理空间查询。</li><li><strong>丰富的索引类型</strong>：MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li><li><strong>支持 ACID 事务</strong>：NoSQL 通常不支持事务，但 MongoDB 支持事务，且 MongoDB 支持 ACID。 <ul><li>MongoDB 单文档支持原子性，也具备事务的特性。</li><li>MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说事务的作用域限制为一个副本集内。</li><li>MongoDB 4.2 引入了分布式事务，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</li></ul></li><li><strong>支持压缩</strong>：存储同样的数据所需的资源更少。</li><li><strong>支持 map-reduce</strong>：通过分治的方式完成复杂的聚合任务。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 <a href="https://www.mongodb.com/docs/manual/core/aggregation-pipeline/" target="_blank" rel="noopener noreferrer">聚合管道</a>。聚合管道提供比 map-reduce 更好的性能和可用性。</li><li><strong>支持存储大文件</strong>：MongoDB 的单文档存储空间要求不超过 16MB。对于超过 16MB 的大文件，MongoDB 提供了 GridFS 来进行存储，通过 GridFS，可以将大型数据进行分块处理，然后将这些切分后的小文档保存在数据库中。</li></ul><p>MongoDB 作为分布式存储，自然也具备了分布式的一般特性：</p><ul><li><strong>高可用</strong>：通过<strong>复制</strong>机制实现<strong>高可用</strong>，提供<strong>数据冗余</strong>和<strong>自动故障转移</strong>能力。在 MongoDB 中，这种机制称为 <a href="https://www.mongodb.com/zh-cn/docs/manual/replication/" target="_blank" rel="noopener noreferrer"><strong>副本集</strong></a>。<a href="https://www.mongodb.com/zh-cn/docs/manual/replication/" target="_blank" rel="noopener noreferrer"><strong>副本集</strong></a> 是一组 MongoDB 服务器，它们维护相同的数据集，并可提供冗余和提高数据可用性。</li><li><strong>高性能</strong>：通过<strong>分片</strong>机制提供<strong>水平扩容</strong>能力，以支撑海量数据，海量并发。从 3.4 开始，MongoDB 支持基于 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/zone-sharding/#std-label-zone-sharding" target="_blank" rel="noopener noreferrer"><strong>分片键</strong></a> 创建数据的 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-shard-key" target="_blank" rel="noopener noreferrer"><strong>区域</strong></a>。在均衡的集群中，MongoDB 仅将区域覆盖的读写定向到区域内的那些分片。</li></ul><h3 id="【简单】mongodb-vs-rdbm" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-vs-rdbm"><span>【简单】MongoDB vs.RDBM？</span></a></h3><p>MongoDB vs.RDBM：</p><table><thead><tr><th>特性</th><th>MongoDB</th><th>RDBMS</th></tr></thead><tbody><tr><td>数据模型</td><td>文档模型</td><td>关系型</td></tr><tr><td>CRUD 操作</td><td>MQL/SQL</td><td>SQL</td></tr><tr><td>高可用</td><td>复制集</td><td>集群模式</td></tr><tr><td>扩展性</td><td>支持分片</td><td>数据分区</td></tr><tr><td>扩繁方式</td><td>垂直扩展+水平扩展</td><td>垂直扩展</td></tr><tr><td>索引类型</td><td>B 树、全文索引、地理位置索引、多键索引、TTL 索引</td><td>B 树</td></tr><tr><td>数据容量</td><td>没有理论上限</td><td>千万、亿</td></tr></tbody></table><h3 id="【简单】mongodb-有哪些里程碑版本" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-有哪些里程碑版本"><span>【简单】MongoDB 有哪些里程碑版本？</span></a></h3><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://www.infoq.cn/article/3d4suwkc2fvikykemnvw" target="_blank" rel="noopener noreferrer">MongoDB 简史</a></li><li><a href="https://blog.csdn.net/JiekeXu/article/details/143670868" target="_blank" rel="noopener noreferrer">MongoDB 发展历史及各主要版本新特性概述</a></li></ul></div><div class="hint-container important"><p class="hint-container-title">要点</p><p>核心特性版本：</p><ul><li><strong>1.0（2009 年）</strong>：MongoDB 发布第一版</li><li><strong>3.0（2015 年）</strong>：支持 <strong>WiredTiger</strong> 存储引擎</li><li><strong>4.0（2019 年）</strong>：支持 ACID 事务</li></ul></div><p>MongoDB 是由 <strong>10gen</strong> 开发的 NoSQL 数据库，该公司由 Dwight Merriman 和 Eliot Horowitz 于 2007 年创立。2013 年，<strong>10gen 更名为 MongoDB Inc</strong>.。以更好地反映其对 MongoDB 数据库开发的关注。2017 年，MongoDB 公司上市。</p><p>里程碑版本：</p><ul><li><strong>1.0（2009 年）</strong>：MongoDB 发布第一版。</li><li><strong>1.6（2010 年）</strong>：引入分片机制（Sharding），支持水平扩展。</li><li><strong>2.2（2012 年）</strong>：引入了聚合管道（Pipeline）。</li><li><strong>2.4（2013 年）</strong>：引入了全文搜索。</li><li><strong>3.0（2015 年）</strong>：全面支持 <strong>WiredTiger</strong> 存储引擎，并支持可插拔存储引擎。</li><li><strong>4.0（2019 年）</strong>：支持 ACID 事务。</li><li><strong>4.2（2020 年）</strong>：支持分布式事务。</li></ul><h3 id="【简单】bson-是什么-与-json-有何区别" tabindex="-1"><a class="header-anchor" href="#【简单】bson-是什么-与-json-有何区别"><span>【简单】BSON 是什么？与 JSON 有何区别？</span></a></h3><p>BSON 的英文全称是 <strong>Binary JSON</strong>，是 <a href="https://www.mongodb.com/zh-cn/docs/v8.0/reference/glossary/#std-term-JSON" target="_blank" rel="noopener noreferrer">JSON</a> 文档的二进制表示形式，但它包含的数据类型比 JSON 多。主要用于在 MongoDB 中存储文档和进行网络传输。</p><ul><li>最大 16MB</li><li>必须有唯一 _id 作为主键</li></ul><h2 id="mongodb-建模" tabindex="-1"><a class="header-anchor" href="#mongodb-建模"><span>MongoDB 建模</span></a></h2><h3 id="【简单】什么是主键-id-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】什么是主键-id-⭐"><span>【简单】什么是主键 <code>_id</code>？⭐</span></a></h3><p><code>_id</code> 是<strong>每个文档的唯一标识符</strong>，默认由系统自动生成，也可以自定义。</p><p>自动生成规则</p><ul><li>MongoDB 默认使用 ObjectId 作为 _id 的值</li><li>ObjectId 是一个 12 字节的 BSON 类型数据</li><li>_id 构成 <ul><li>时间戳：文档创建时的 Unix 时间戳（秒级）</li><li>机器标识：生成 ObjectId 的服务器唯一标识</li><li>进程 ID：MongoDB 进程的标识</li><li>计数器：同一秒内的自增序列（确保同一进程内不重复）</li></ul></li></ul><h3 id="【简单】mongodb-支持哪些数据类型-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-支持哪些数据类型-⭐⭐"><span>【简单】MongoDB 支持哪些数据类型？⭐⭐</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><ul><li><strong>基本类型</strong>：String、Integer、Boolean、Double、Decimal、Null</li><li><strong>时间类型</strong>：Date、Timestamp</li><li><strong>组合类型</strong>：Array、Embedded Document</li><li><strong>特殊类型</strong>：ObjectId、Binary、Regular、Script、GeoJSON</li></ul></div><div class="hint-container info"><p class="hint-container-title">基本类型</p></div><ul><li><strong>String</strong>：UTF-8 字符串</li><li><strong>Integer</strong>：整数（32 位或 64 位，取决于服务器架构）</li><li><strong>Boolean</strong>：true 或 false</li><li><strong>Double</strong>：双精度浮点数</li><li><strong>Decimal</strong>：高精度浮点数（适用于金融数据，避免精度丢失）</li><li><strong>Null</strong>：表示空值或缺失字段</li></ul><div class="hint-container info"><p class="hint-container-title">时间类型</p></div><ul><li><strong>Date</strong>：存储日期和时间（Unix 时间戳格式，毫秒精度）</li><li><strong>Timestamp</strong>：内部使用的时间戳（不同于 Date 类型）。示例：<code>Timestamp(1000, 1)</code></li></ul><div class="hint-container info"><p class="hint-container-title">组合类型</p></div><ul><li><strong>Array</strong>：有序的值列表，可包含不同类型。示例：<code>[&quot;apple&quot;, 42, true]</code></li><li><strong>Embedded Document</strong>：嵌套的 BSON 文档（子文档）。示例：<code>{ address: { city: &quot;Beijing&quot;, zip: &quot;100000&quot; } }</code></li></ul><div class="hint-container info"><p class="hint-container-title">特殊类型</p></div><ul><li><strong>ObjectId</strong>：文档的唯一标识（默认 _id 字段类型）。示例：ObjectId(&quot;507f1f77bcf86cd799439011&quot;)</li><li><strong>Binary Data</strong>：存储二进制数据（如图片、文件）</li><li><strong>Regular Expression</strong>：正则表达式。示例：<code>{ pattern: /^test/i }</code></li><li><strong>JavaScript Code</strong>：存储 JavaScript 代码（不推荐在服务端执行）。示例：<code>{ code: function() { return x + y; } }</code></li><li><strong>GeoJSON</strong>：支持地理坐标查询（点、线、多边形等）。示例：<code>{ location: { type: &quot;Point&quot;, coordinates: [116.4, 39.9] } }</code></li></ul><h2 id="mongodb-crud" tabindex="-1"><a class="header-anchor" href="#mongodb-crud"><span>MongoDB CRUD</span></a></h2><h3 id="【简单】如何进行分页查询-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】如何进行分页查询-⭐"><span>【简单】如何进行分页查询？⭐</span></a></h3><ul><li><code>skip()</code> + <code>limit()</code>：在大数据集中性能较差（需扫描跳过所有前置文档）</li><li>基于游标的分页（使用 <code>_id</code> 或时间戳）：记录上一页最后一条记录的 <code>_id</code>，下次查询直接定位</li></ul><h3 id="【简单】如何实现数据的增删改查操作-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】如何实现数据的增删改查操作-⭐"><span>【简单】如何实现数据的增删改查操作？⭐</span></a></h3><ul><li>插入 <ul><li><code>db.collection.insertOne()</code></li><li><code>db.collection.insertMany()</code></li></ul></li><li>更新 <ul><li><code>db.collection.updateOne()</code></li><li><code>db.collection.updateMany()</code></li><li><code>db.collection.replaceOne()</code></li></ul></li><li>删除 <ul><li><code>db.collection.deleteOne()</code></li><li><code>db.collection.deleteMany()</code></li></ul></li><li>查询 <ul><li><code>db.collection.find()</code></li></ul></li><li>批量 <ul><li><code>db.collection.bulkWrite()</code></li></ul></li></ul><h3 id="【简单】如何使用-find-方法查询文档-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】如何使用-find-方法查询文档-⭐"><span>【简单】如何使用 find() 方法查询文档？⭐</span></a></h3><p>语法：<code>db.collection.find(query, projection)</code></p><ul><li><strong><code>query</code></strong>：查询条件（可选，默认为空对象 {}，查询所有文档）</li><li><strong><code>projection</code></strong>：指定返回的字段（可选，默认为返回全部字段）</li></ul><h3 id="【简单】如何使用-gridfs-存储大文件" tabindex="-1"><a class="header-anchor" href="#【简单】如何使用-gridfs-存储大文件"><span>【简单】如何使用 GridFS 存储大文件？</span></a></h3><p>GridFS 是一种用于存储和检索大文件（超过 16MB BSON 文档限制）的规范，它将文件分块存储为多个文档</p><ul><li>文件拆分：将大文件分割为多个 256KB 的块（默认），存储到 <code>fs.chunks</code> 集合</li><li>元数据存储：文件信息（如文件名、大小、MD5）保存在 <code>fs.files</code> 集合</li><li>自动管理：通过 MongoDB 驱动程序或命令行工具透明地操作文件</li></ul><h3 id="【简单】如何实现全文检索" tabindex="-1"><a class="header-anchor" href="#【简单】如何实现全文检索"><span>【简单】如何实现全文检索？</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>创建文本索引 + 使用 <code>$text</code> 操作符进行搜索</p></div><p><strong>创建文本索引</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">articles</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">createIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  title</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;text&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  content</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;text&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  tags</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;text&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>全文搜索</strong></p><p>使用 <code>$text</code> 操作符进行搜索，支持关键词匹配和排序</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">articles</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">find</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  $text</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    $search</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;mongodb tutorial&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mongodb-聚合" tabindex="-1"><a class="header-anchor" href="#mongodb-聚合"><span>MongoDB 聚合</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><p><a href="https://www.mongodb.com/zh-cn/docs/manual/aggregation/" target="_blank" rel="noopener noreferrer">MongoDB 官方文档之聚合</a></p></div><h3 id="【简单】mongodb-支持哪些聚合方式-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-支持哪些聚合方式-⭐⭐"><span>【简单】MongoDB 支持哪些聚合方式？⭐⭐</span></a></h3><p>聚合操作处理多个文档并返回计算结果。可以使用聚合操作来：</p><ul><li>将多个文档中的值组合在一起。</li><li>对分组数据执行操作，返回单一结果。</li><li>分析一段时间内的数据变化。</li></ul><p>若要执行聚合操作，可以使用：</p><ul><li><a href="https://www.mongodb.com/zh-cn/docs/manual/aggregation/#std-label-aggregation-pipeline-intro" target="_blank" rel="noopener noreferrer">聚合管道</a>，这是执行聚合的首选方法。 <ul><li><code>$match</code>：过滤文档</li><li><code>$group</code>：分组聚合</li><li><code>$project</code>：指定返回字段</li><li><code>$sort</code>：排序</li><li><code>$limit/$skip</code>：限制/跳过结果</li><li><code>$unwind</code>：展开数组</li><li><code>$lookup</code>：关联查询（类似 SQL 的 JOIN)</li><li><code>$facet</code>：多分支聚合</li></ul></li><li><a href="https://www.mongodb.com/zh-cn/docs/manual/aggregation/#std-label-single-purpose-agg-methods" target="_blank" rel="noopener noreferrer">单一目的聚合方法</a>，这些方法很简单，但缺乏聚合管道的功能。 <ul><li><code>count()</code>：计数</li><li><code>distinct()</code>：去重</li><li><code>estimatedDocumentCount()</code>：快速计数（不精确）</li></ul></li><li><a href="https://www.mongodb.com/zh-cn/docs/manual/core/Map-Reduce/" target="_blank" rel="noopener noreferrer">Map-Reduce</a>，从 MongoDB 5.0 开始，<a href="https://www.mongodb.com/zh-cn/docs/manual/core/Map-Reduce/#std-label-Map-Reduce" target="_blank" rel="noopener noreferrer">Map-Reduce</a> 已被弃用。聚合管道提供的性能和可用性比 Map-Reduce 更优越。</li><li><strong>表达式</strong><ul><li>数学表达式：<code>$add</code>, <code>$subtract</code>, <code>$multiply</code>, <code>$divide</code></li><li>日期表达式：<code>$year</code>, <code>$month</code>, <code>$dayOfMonth</code></li><li>字符串表达式：<code>$concat</code>, <code>$substr</code>, <code>$toLower</code></li><li>逻辑表达式：<code>$and</code>, <code>$or</code>, <code>$not</code>, <code>$cond</code></li><li>数组表达式：<code>$arrayElemAt</code>, <code>$size</code>, <code>$slice</code></li></ul></li></ul><h3 id="【中等】什么是聚合管道-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】什么是聚合管道-⭐⭐"><span>【中等】什么是聚合管道？⭐⭐</span></a></h3><p>聚合管道由一个或多个处理文档的 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation-pipeline/#std-label-aggregation-pipeline-operator-reference" target="_blank" rel="noopener noreferrer">阶段</a> 组成：</p><ul><li>每个阶段对输入文档执行一个操作。例如，某个阶段可以过滤文档、对文档进行分组并计算值。</li><li>从一个阶段输出的文档将传递到下一阶段。</li><li>一个聚合管道可以返回针对文档组的结果。例如，返回总值、平均值、最大值和最小值。</li></ul><p>如使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/tutorial/update-documents-with-aggregation-pipeline/#std-label-updates-agg-pipeline" target="_blank" rel="noopener noreferrer">通过聚合管道更新</a> 中显示的阶段，则可以通过聚合管道更新文档。</p><blockquote><p>注意：使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.aggregate/#mongodb-method-db.collection.aggregate" target="_blank" rel="noopener noreferrer"><code>db.collection.aggregate()</code></a> 方法运行的聚合管道不会修改集合中的文档，除非管道包含 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/merge/#mongodb-pipeline-pipe.-merge" target="_blank" rel="noopener noreferrer"><code>$merge</code></a> 或 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/out/#mongodb-pipeline-pipe.-out" target="_blank" rel="noopener noreferrer"><code>$out</code></a> 阶段。</p></blockquote><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200921092725.png" alt="MongoDB 聚合" tabindex="0" loading="lazy"><figcaption>MongoDB 聚合</figcaption></figure><p><a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation-pipeline/#std-label-aggregation-pipeline-operator-reference" target="_blank" rel="noopener noreferrer">阶段</a> 的其他要点：</p><ul><li>阶段不必为每个输入文档输出一个文档。例如，某些阶段可能会产生新文档或过滤掉现有文档。</li><li>同一个阶段可以在管道中多次出现，但以下阶段例外：<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/out/#mongodb-pipeline-pipe.-out" target="_blank" rel="noopener noreferrer"><code>$out</code></a>、<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/merge/#mongodb-pipeline-pipe.-merge" target="_blank" rel="noopener noreferrer"><code>$merge</code></a> 和 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/geoNear/#mongodb-pipeline-pipe.-geoNear" target="_blank" rel="noopener noreferrer"><code>$geoNear</code></a>。</li><li>要在阶段中计算平均值和执行其他计算，请使用指定 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/#std-label-aggregation-expressions" target="_blank" rel="noopener noreferrer">聚合操作符</a> 的 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/#std-label-aggregation-expression-operators" target="_blank" rel="noopener noreferrer">聚合表达式</a>。</li></ul><p>MongoDB 聚合管道提供了许多等价于 SQL 中常见聚合语句的操作。 下表概述了常见的 SQL 聚合语句或函数和 MongoDB 聚合操作的映射表：</p><table><thead><tr><th style="text-align:left;">RDBM 操作</th><th style="text-align:left;">MongoDB 聚合操作</th></tr></thead><tbody><tr><td style="text-align:left;"><code>WHERE</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener noreferrer"><code>$match</code></a></td></tr><tr><td style="text-align:left;"><code>GROUP BY</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group" target="_blank" rel="noopener noreferrer"><code>$group</code></a></td></tr><tr><td style="text-align:left;"><code>HAVING</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener noreferrer"><code>$match</code></a></td></tr><tr><td style="text-align:left;"><code>SELECT</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#pipe._S_project" target="_blank" rel="noopener noreferrer"><code>$project</code></a></td></tr><tr><td style="text-align:left;"><code>ORDER BY</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sort/#pipe._S_sort" target="_blank" rel="noopener noreferrer"><code>$sort</code></a></td></tr><tr><td style="text-align:left;"><code>LIMIT</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/limit/#pipe._S_limit" target="_blank" rel="noopener noreferrer"><code>$limit</code></a></td></tr><tr><td style="text-align:left;"><code>SUM()</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a></td></tr><tr><td style="text-align:left;"><code>COUNT()</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/#pipe._S_sortByCount" target="_blank" rel="noopener noreferrer"><code>$sortByCount</code></a></td></tr><tr><td style="text-align:left;"><code>JOIN</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#pipe._S_lookup" target="_blank" rel="noopener noreferrer"><code>$lookup</code></a></td></tr><tr><td style="text-align:left;"><code>SELECT INTO NEW_TABLE</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#pipe._S_out" target="_blank" rel="noopener noreferrer"><code>$out</code></a></td></tr><tr><td style="text-align:left;"><code>MERGE INTO TABLE</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#pipe._S_merge" target="_blank" rel="noopener noreferrer"><code>$merge</code></a> (Available starting in MongoDB 4.2)</td></tr><tr><td style="text-align:left;"><code>UNION ALL</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith/#pipe._S_unionWith" target="_blank" rel="noopener noreferrer"><code>$unionWith</code></a> (Available starting in MongoDB 4.4)</td></tr></tbody></table><p>下面通过一个示例来展示，如何通过 MongoDB 聚合计算总订单数量：</p><p>以下聚合管道示例包含两个 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation-pipeline/#std-label-aggregation-pipeline-operator-reference" target="_blank" rel="noopener noreferrer">阶段</a>，并返回按披萨名称分组后，各款中号披萨的总订单数量：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">orders</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">aggregate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Stage 1: 根据 size 过滤订单</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    $match</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">size</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;medium&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  },</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Stage 2: 按名称对剩余文档进行分组，并计算总数量</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    $group</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;$name&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">totalQuantity</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$sum</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;$quantity&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])[</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 输出</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  ({ </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Cheese&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">totalQuantity</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Vegan&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">totalQuantity</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Pepperoni&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">totalQuantity</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> })</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/match/#mongodb-pipeline-pipe.-match" target="_blank" rel="noopener noreferrer"><code>$match</code></a> 阶段：</p><ul><li>从披萨订单文档过滤出 <code>size</code> 为 <code>medium</code> 的披萨。</li><li>将剩余文档传递到 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a> 阶段。</li></ul><p><a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a> 阶段：</p><ul><li>按披萨 <code>name</code> 对剩余文档进行分组。</li><li>使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/sum/#mongodb-group-grp.-sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a> 计算每种披萨 <code>name</code> 的总订单 <code>quantity</code>。总数存储在聚合管道返回的 <code>totalQuantity</code> 字段中。</li></ul><h3 id="【简单】rdbm-聚合-vs-mongodb-聚合-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】rdbm-聚合-vs-mongodb-聚合-⭐⭐"><span>【简单】RDBM 聚合 vs. MongoDB 聚合？⭐⭐</span></a></h3><p>MongoDB pipeline 提供了许多等价于 SQL 中常见聚合语句的操作。 下表概述了常见的 SQL 聚合语句或函数和 MongoDB 聚合操作的映射表：</p><table><thead><tr><th style="text-align:left;">RDBM 操作</th><th style="text-align:left;">MongoDB 聚合操作</th></tr></thead><tbody><tr><td style="text-align:left;"><code>WHERE</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener noreferrer"><code>$match</code></a></td></tr><tr><td style="text-align:left;"><code>GROUP BY</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group" target="_blank" rel="noopener noreferrer"><code>$group</code></a></td></tr><tr><td style="text-align:left;"><code>HAVING</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener noreferrer"><code>$match</code></a></td></tr><tr><td style="text-align:left;"><code>SELECT</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#pipe._S_project" target="_blank" rel="noopener noreferrer"><code>$project</code></a></td></tr><tr><td style="text-align:left;"><code>ORDER BY</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sort/#pipe._S_sort" target="_blank" rel="noopener noreferrer"><code>$sort</code></a></td></tr><tr><td style="text-align:left;"><code>LIMIT</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/limit/#pipe._S_limit" target="_blank" rel="noopener noreferrer"><code>$limit</code></a></td></tr><tr><td style="text-align:left;"><code>SUM()</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a></td></tr><tr><td style="text-align:left;"><code>COUNT()</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/#pipe._S_sortByCount" target="_blank" rel="noopener noreferrer"><code>$sortByCount</code></a></td></tr><tr><td style="text-align:left;"><code>JOIN</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#pipe._S_lookup" target="_blank" rel="noopener noreferrer"><code>$lookup</code></a></td></tr><tr><td style="text-align:left;"><code>SELECT INTO NEW_TABLE</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#pipe._S_out" target="_blank" rel="noopener noreferrer"><code>$out</code></a></td></tr><tr><td style="text-align:left;"><code>MERGE INTO TABLE</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#pipe._S_merge" target="_blank" rel="noopener noreferrer"><code>$merge</code></a> (Available starting in MongoDB 4.2)</td></tr><tr><td style="text-align:left;"><code>UNION ALL</code></td><td style="text-align:left;"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith/#pipe._S_unionWith" target="_blank" rel="noopener noreferrer"><code>$unionWith</code></a> (Available starting in MongoDB 4.4)</td></tr></tbody></table><p>RDBM 聚合 vs. MongoDB 聚合：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200921200556.png" alt="SQL 聚合 vs. MongoDB 聚合" tabindex="0" loading="lazy"><figcaption>SQL 聚合 vs. MongoDB 聚合</figcaption></figure><h3 id="【中等】mongodb-map-reduce-有什么用" tabindex="-1"><a class="header-anchor" href="#【中等】mongodb-map-reduce-有什么用"><span>【中等】MongoDB Map-Reduce 有什么用？</span></a></h3><blockquote><p>从 MongoDB 5.0 开始，<a href="https://www.mongodb.com/zh-cn/docs/manual/core/Map-Reduce/#std-label-Map-Reduce" target="_blank" rel="noopener noreferrer">Map-Reduce</a> 已被弃用。聚合管道提供的性能和可用性比 Map-Reduce 更优越。</p></blockquote><p>Map-Reduce 是一种数据处理范式，用于将大量数据汇总为有用的聚合结果。为了执行 Map-Reduce 操作，MongoDB 提供了 <a href="https://docs.mongodb.com/manual/reference/command/mapReduce/#dbcmd.mapReduce" target="_blank" rel="noopener noreferrer"><code>mapReduce</code></a> 数据库命令。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200921155546.svg" alt="Map-Reduce" tabindex="0" loading="lazy"><figcaption>Map-Reduce</figcaption></figure><p>在上面的操作中，MongoDB 将 map 阶段应用于每个输入 document（即 collection 中与查询条件匹配的 document）。 map 函数分发出多个键 - 值对。对于具有多个值的那些键，MongoDB 应用 reduce 阶段，该阶段收集并汇总聚合的数据。然后，MongoDB 将结果存储在 collection 中。可选地，reduce 函数的输出可以通过 finalize 函数来进一步汇总聚合结果。</p><p>MongoDB 中的所有 Map-Reduce 函数都是 JavaScript，并在 mongod 进程中运行。 Map-Reduce 操作将单个 collection 的 document 作为输入，并且可以在开始 map 阶段之前执行任意排序和限制。 mapReduce 可以将 Map-Reduce 操作的结果作为 document 返回，也可以将结果写入 collection。</p><h2 id="mongodb-存储" tabindex="-1"><a class="header-anchor" href="#mongodb-存储"><span>MongoDB 存储</span></a></h2><h3 id="【简单】mongodb-的逻辑存储是怎样设计的-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-的逻辑存储是怎样设计的-⭐⭐⭐"><span>【简单】MongoDB 的逻辑存储是怎样设计的？⭐⭐⭐</span></a></h3><p>MongoDB 将数据记录存储为 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/document/#std-label-bson-document-format" target="_blank" rel="noopener noreferrer">BSON 文档</a>。BSON 是 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-JSON" target="_blank" rel="noopener noreferrer">JSON</a> 文档的二进制表示形式，尽管它包含的数据类型比 JSON 多。最大 BSON 文档大小为 16 MB。</p><p>每个 MongoDB 文档都需要一个唯一的 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-_id" target="_blank" rel="noopener noreferrer"><code>_id</code></a> 字段作为 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-primary-key" target="_blank" rel="noopener noreferrer">主键</a>。如果插入的文档省略了 <code>_id</code> 字段，则 MongoDB 驱动程序会自动为 <code>_id</code> 字段生成 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/bson-types/#std-label-objectid" target="_blank" rel="noopener noreferrer">ObjectId</a>。</p><p>这些 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-document" target="_blank" rel="noopener noreferrer">MongoDB 文档</a> 收集在 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-collection" target="_blank" rel="noopener noreferrer">集合</a> 中。<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-database" target="_blank" rel="noopener noreferrer">数据库</a> 存储一个或多个文档集合。</p><p>为了方便理解 MongoDB 概念，下面将 MongoDB 概念和 RDBM 概念进行对比：</p><table><thead><tr><th style="text-align:left;">RDBM 概念</th><th style="text-align:left;">MongoDB 概念</th></tr></thead><tbody><tr><td style="text-align:left;">database（数据库）</td><td style="text-align:left;">database（数据库）</td></tr><tr><td style="text-align:left;">table（表）</td><td style="text-align:left;">collection（集合）</td></tr><tr><td style="text-align:left;">row（行）</td><td style="text-align:left;">document（文档）</td></tr><tr><td style="text-align:left;">column（列）</td><td style="text-align:left;">field（字段）</td></tr><tr><td style="text-align:left;">index（索引）</td><td style="text-align:left;">index（索引）</td></tr><tr><td style="text-align:left;">primary key</td><td style="text-align:left;"><a href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-_id" target="_blank" rel="noopener noreferrer"><code>_id</code></a></td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">文档</p></div><p>文档是 MongoDB 中的<strong>基本数据单元</strong>。<strong>文档是一组有序键值对（即 BSON）</strong>。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503041024526.png" alt="MongoDB Document" tabindex="0" loading="lazy"><figcaption>MongoDB Document</figcaption></figure><p>需要注意的是：</p><ul><li><p><strong>文档中的键/值对是有序的</strong>。</p></li><li><p>文档的键是字符串。除了少数例外情况，<strong>键可以使用任意 UTF-8 字符</strong>。</p></li><li><p>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档）。</p></li><li><p><strong>MongoDB 区分类型和大小写</strong>。例如，下面这两对文档是不同的：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;count&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;count&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;5&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;count&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;Count&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>MongoDB 的文档不能有重复的键。例如，下面这个文档是不合法的</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;greeting&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;greeting&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, MongoDB!&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><p>文档键命名规范：</p><ul><li>键不能含有 <code>\\0</code> （空字符）。这个字符用来表示键的结尾。</li><li><code>.</code> 和 <code>$</code> 有特别的意义，只有在特定环境下才能使用。</li><li>以下划线 <code>_</code> 开头的键是保留的（不是严格要求的）。</li></ul><div class="hint-container info"><p class="hint-container-title">集合</p></div><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System) 中的表（Table）。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503041024137.png" alt="MongoDB Collection" tabindex="0" loading="lazy"><figcaption>MongoDB Collection</figcaption></figure><p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。使用 <code>.</code> 字符分隔不同命名空间的子集合是一种组织集合的惯例。例如，有一个具有博客功能的应用程序，可能包含名为 <code>blog.posts</code> 和名为 <code>blog.authors</code> 的集合。</p><p>合法的集合名：</p><ul><li>集合名称不能是空字符串（&quot;&quot;）。</li><li>集合名称不能含有 <code>\\0</code>（空字符），因为这个字符用于表示一个集合名称的结束。</li><li>集合名称不能以 <code>system.</code> 开头，该前缀是为内部集合保留的。例如，<code>system.users</code> 集合中保存着数据库的用户，<code>system.namespaces</code> 集合中保存着有关数据库所有集合的信息。</li><li>用户创建的集合名称中不应包含保留字符 <code>$</code>。许多驱动程序确实支持在集合名称中使用 <code>$</code>，这是因为某些由系统生成的集合会包含它，但除非你要访问的是这些集合之一，否则不应在名称中使用 <code>$</code> 字符。</li></ul><div class="hint-container info"><p class="hint-container-title">数据库</p></div><p>数据库用于存储所有集合，而集合又用于存储所有文档。一个 MongoDB 中可以创建多个数据库，每一个数据库都有自己的集合和权限。MongoDB 的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p><p>MongoDB 的默认数据库为&quot;db&quot;，该数据库存储在 data 目录中。</p><p><strong>&quot;show dbs&quot;</strong> 命令可以显示所有数据的列表。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./mongo</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MongoDBshell</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> version:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3.0.6</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">connecting</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> test</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; show dbs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">078GB</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">test</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">   0.078GB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行 <strong>&quot;db&quot;</strong> 命令可以显示当前数据库对象或集合。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./mongo</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MongoDBshell</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> version:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3.0.6</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">connecting</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> test</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; db</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">test</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行&quot;use&quot;命令，可以连接到一个指定的数据库。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; use </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">switched</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> db</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> local</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; db</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据库按照名称进行标识的。数据库名称可以是任意 UTF-8 字符串，但有以下限制：</p><ul><li>数据库名称不能是空字符串（&quot;&quot;）。</li><li>数据库名称不能包含 <code>/</code>、<code>\\</code>、<code>.</code>、<code>&quot;</code>、<code>*</code>、<code>&lt;</code>、<code>&gt;</code>、<code>:</code>、<code>|</code>、<code>?</code>、<code>$</code>、单一的空格以及 <code>\\0</code>（空字符），基本上只能使用 ASCII 字母和数字。</li><li>数据库名称区分大小写。</li><li>数据库名称的长度限制为 64 字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li><strong>admin</strong>：admin 数据库会在身份验证和授权时被使用。此外，某些管理操作需要访问此数据库。</li><li><strong>local</strong>：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li><strong>config</strong>：当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片的相关信息。</li></ul><div class="hint-container info"><p class="hint-container-title">元数据</p></div><p>数据库的信息是存储在集合中。它们使用了系统的命名空间：<code>dbname.system.*</code></p><p>在 MongoDB 数据库中命名空间 <code>&lt;dbname&gt;.system.*</code> 是包含多种系统信息的特殊集合 (Collection)，如下：</p><table><thead><tr><th style="text-align:left;">集合命名空间</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>dbname.system.namespaces</code></td><td style="text-align:left;">列出所有名字空间。</td></tr><tr><td style="text-align:left;"><code>dbname.system.indexes</code></td><td style="text-align:left;">列出所有索引。</td></tr><tr><td style="text-align:left;"><code>dbname.system.profile</code></td><td style="text-align:left;">包含数据库概要 (profile) 信息。</td></tr><tr><td style="text-align:left;"><code>dbname.system.users</code></td><td style="text-align:left;">列出所有可访问数据库的用户。</td></tr><tr><td style="text-align:left;"><code>dbname.local.sources</code></td><td style="text-align:left;">包含复制对端（slave）的服务器信息和状态。</td></tr></tbody></table><p>对于修改系统集合中的对象有如下限制。</p><p>在 <code>system.indexes</code> 插入数据，可以创建索引。但除此之外该表信息是不可变的（特殊的 drop index 命令将自动更新相关信息）。<code>system.users</code> 是可修改的。<code>system.profile</code> 是可删除的。</p><h3 id="【中等】mongodb-支持哪些存储引擎-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】mongodb-支持哪些存储引擎-⭐⭐"><span>【中等】MongoDB 支持哪些存储引擎？⭐⭐</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><ul><li><strong>MMAPV1</strong>：MongoDB 早期版本的默认存储引擎为 MMAPV1，已废弃</li><li><strong>WiredTiger</strong>：MongoDB 3.2 后，默认的存储引擎为 <a href="https://www.mongodb.com/docs/manual/core/wiredtiger/" target="_blank" rel="noopener noreferrer">WiredTiger 存储引擎</a>，支持 ACID 事务</li><li><strong>In-Memory</strong>：数据存储在内存中</li></ul></div><p>存储引擎（Storage Engine）是数据库的核心组件，负责管理数据在内存和磁盘中的存储方式。</p><p>与 MySQL 一样，MongoDB 采用的也是 <strong>插件式的存储引擎架构</strong> ，支持不同类型的存储引擎，不同的存储引擎解决不同场景的问题。在创建数据库或集合时，可以指定存储引擎。</p><blockquote><p>插件式的存储引擎架构可以实现 Server 层和存储引擎层的解耦，可以支持多种存储引擎，如 MySQL 既可以支持 B-Tree 结构的 InnoDB 存储引擎，还可以支持 LSM 结构的 RocksDB 存储引擎。</p></blockquote><p>在存储引擎刚出来的时候，默认是使用 MMAPV1 存储引擎，MongoDB4.x 版本不再支持 MMAPv1 存储引擎。</p><p>现在主要有下面这两种存储引擎：</p><ul><li><strong>WiredTiger 存储引擎</strong>：自 MongoDB 3.2 以后，默认的存储引擎为 <a href="https://www.mongodb.com/docs/manual/core/wiredtiger/" target="_blank" rel="noopener noreferrer">WiredTiger 存储引擎</a> 。非常适合大多数工作负载，建议用于新部署。WiredTiger 提供文档级并发模型、检查点和数据压缩（后文会介绍到）等功能。</li><li><strong>In-Memory 存储引擎</strong>：<a href="https://www.mongodb.com/docs/manual/core/inmemory/" target="_blank" rel="noopener noreferrer">In-Memory 存储引擎</a> 在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是将它们保留在内存中以获得更可预测的数据延迟。</li></ul><p>此外，MongoDB 3.0 提供了 <strong>可插拔的存储引擎 API</strong> ，允许第三方为 MongoDB 开发存储引擎，这点和 MySQL 也比较类似。</p><h3 id="【中等】mongodb-支持哪些压缩算法" tabindex="-1"><a class="header-anchor" href="#【中等】mongodb-支持哪些压缩算法"><span>【中等】MongoDB 支持哪些压缩算法？</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>MongoDB 支持的压缩算法：<strong><a href="https://github.com/google/snappy" target="_blank" rel="noopener noreferrer">Snappy</a></strong>、<strong><a href="https://github.com/madler/zlib" target="_blank" rel="noopener noreferrer">zlib</a></strong>、<strong><a href="https://github.com/facebook/zstd" target="_blank" rel="noopener noreferrer">zstd</a></strong></p></div><p>借助 WiredTiger 存储引擎（ MongoDB 3.2 后的默认存储引擎），MongoDB 支持对所有集合和索引进行压缩。压缩以额外的 CPU 为代价最大限度地减少存储使用。</p><p>默认情况下，WiredTiger 使用 <a href="https://github.com/google/snappy" target="_blank" rel="noopener noreferrer">Snappy</a> 压缩算法（谷歌开源，旨在实现非常高的速度和合理的压缩，压缩比 3 ～ 5 倍）对所有集合使用块压缩，对所有索引使用前缀压缩。</p><p>除了 Snappy 之外，对于集合还有下面这些压缩算法：</p><ul><li><a href="https://github.com/madler/zlib" target="_blank" rel="noopener noreferrer">zlib</a>：高度压缩算法，压缩比 5 ～ 7 倍</li><li><a href="https://github.com/facebook/zstd" target="_blank" rel="noopener noreferrer">zstd</a>：Facebook 开源的一种快速无损压缩算法，针对 zlib 级别的实时压缩场景和更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li></ul><p>WiredTiger 日志也会被压缩，默认使用的也是 Snappy 压缩算法。如果日志记录小于或等于 128 字节，WiredTiger 不会压缩该记录。</p><h3 id="【中等】wiredtiger-数据结构采用-lsm-tree-还是-b-tree-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】wiredtiger-数据结构采用-lsm-tree-还是-b-tree-⭐⭐"><span>【中等】WiredTiger 数据结构采用 LSM Tree 还是 B+ Tree？⭐⭐</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>WiredTiger 采用 B+ 树，因为其很适合以页为单位存储于磁盘空间。</p></div><p>目前绝大部分流行的数据库存储引擎都是基于 B/B+ Tree 或者 LSM(Log Structured Merge) Tree 来实现的。对于 NoSQL 数据库来说，绝大部分（比如 HBase、Cassandra、RocksDB）都是基于 LSM 树，MongoDB 不太一样。</p><p>上面也说了，自 MongoDB 3.2 以后，默认的存储引擎为 WiredTiger 存储引擎。在 WiredTiger 引擎官网上，我们发现 WiredTiger 使用的是 B+ 树作为其存储结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>WiredTiger maintains a table&#39;s data in memory using a data structure called a B-Tree ( B+ Tree to be specific), referring to the nodes of a B-Tree as pages. Internal pages carry only keys. The leaf pages store both keys and values.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，WiredTiger 还支持 <a href="https://source.wiredtiger.com/3.1.0/lsm.html" target="_blank" rel="noopener noreferrer">LSM(Log Structured Merge)</a> 树作为存储结构，MongoDB 在使用 WiredTiger 作为存储引擎时，默认使用的是 B+ 树。</p><p>如果想要了解 MongoDB 使用 B+ 树的原因，可以看看这篇文章：<a href="https://zhuanlan.zhihu.com/p/519658576" target="_blank" rel="noopener noreferrer">【驳斥八股文系列】别瞎分析了，MongoDB 使用的是 B+ 树，不是你们以为的 B 树</a>。</p><p>使用 B+ 树时，WiredTiger 以 <strong>page</strong> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 page，共有三种类型的 page：</p><ul><li><strong>root page（根节点）</strong>：B+ 树的根节点。</li><li><strong>internal page（内部节点）</strong>：不实际存储数据的中间索引节点。</li><li><strong>leaf page（叶子节点）</strong>：真正存储数据的叶子节点，包含一个页头（page header）、块头（block header）和真正的数据（key/value），其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 checksum、块在磁盘上的寻址位置等信息。</li></ul><p>其整体结构如下图所示：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503041050392.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果想要深入研究学习 WiredTiger 存储引擎，推荐阅读 MongoDB 中文社区的 [WiredTiger 存储引擎系列](<a href="https://mongoing.com/archives/category/wiredtiger" target="_blank" rel="noopener noreferrer">https://mongoing.com/archives/category/wiredtiger</a> 存储引擎系列)。</p><h2 id="mongodb-索引" tabindex="-1"><a class="header-anchor" href="#mongodb-索引"><span>MongoDB 索引</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://www.mongodb.com/zh-cn/docs/manual/indexes/" target="_blank" rel="noopener noreferrer">MongoDB 官方文档之索引</a></li><li><a href="https://zhuanlan.zhihu.com/p/77971681" target="_blank" rel="noopener noreferrer">你真的会用索引么？[Mongo]</a></li></ul></div><h3 id="【简单】mongodb-索引有什么用" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-索引有什么用"><span>【简单】MongoDB 索引有什么用？</span></a></h3><p><strong>MongoDB 在 collection 数据级别上定义索引</strong>。</p><p>索引通常能够极大的提高查询的效率。如果<strong>没有索引</strong>，MongoDB 在读取数据时<strong>必须扫描 collection 中的每个 document</strong> 并选取那些符合查询条件的记录。这种扫描全集合的查询是非常低效的，特别是在处理大量的数据时。查询可能要花费几十秒甚至几分钟，这种性能开销是不可接受的。索引可提高查询性能，但<strong>添加索引会影响写入操作的性能</strong>。对于写入读取率高的集合，由于每次插入操作都必须同时更新所有索引，因此会带来较高的索引成本。</p><p>索引是一种特殊的数据结构，它以易于遍历的形式存储一小部分集合数据集。<strong>MongoDB 索引使用 <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener noreferrer">B-tree</a> 数据结构</strong>。索引可存储某个特定字段或多个字段的值，并按字段的值进行排序。索引条目的排序支持高效的相等匹配和基于范围的查询操作。此外，<strong>MongoDB 还可使用索引中的顺序来返回排序后的结果</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200921210621.svg" alt="MongoDB 索引" tabindex="0" loading="lazy"><figcaption>MongoDB 索引</figcaption></figure><h3 id="【简单】mongodb-支持哪些类型的索引-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-支持哪些类型的索引-⭐⭐⭐"><span>【简单】MongoDB 支持哪些类型的索引？⭐⭐⭐</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p><strong>MongoDB 支持索引类型：单字段索引、复合索引、多键索引、文本索引、地理空间索引</strong></p></div><p>MongoDB 支持多种类型的索引，适用于不同的场景。</p><div class="hint-container info"><p class="hint-container-title">单字段索引</p></div><p>单个字段索引收集集合内每个文档中单个字段的数据，并对其排序。</p><p>下图显示了单个字段 <code>score</code> 上的一个索引：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503052211281.svg" alt="单字段索引" tabindex="0" loading="lazy"><figcaption>单字段索引</figcaption></figure><blockquote><p>要了解详情，请参阅 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/index-single/#std-label-indexes-single-field" target="_blank" rel="noopener noreferrer">单字段索引</a>。</p></blockquote><div class="hint-container info"><p class="hint-container-title">复合索引</p></div><p>复合索引从集合中每个文档的两个或多个字段收集数据并对其排序。数据先按索引中的第一个字段分组，再按每个后续字段分组。</p><p>例如，下图显示了一个复合索引，其中文档首先按 <code>userid</code> 分组并以升序（按字母顺序）排序。然后，每个 <code>userid</code> 的 <code>scores</code> 按降序排序：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503052213721.svg" alt="复合索引" tabindex="0" loading="lazy"><figcaption>复合索引</figcaption></figure><blockquote><p>要了解详情，请参阅 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/index-compound/#std-label-index-type-compound" target="_blank" rel="noopener noreferrer">复合索引</a>。</p></blockquote><div class="hint-container info"><p class="hint-container-title">多键索引</p></div><p>多键索引收集数组中存储的数据并进行排序。</p><p>无需显式指定多键类型。对包含数组值的字段创建索引时，MongoDB 会自动将该索引设为多键索引。</p><p>下图显示了 <code>addr.zip</code> 字段的多键索引：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503052214522.svg" alt="多键索引" tabindex="0" loading="lazy"><figcaption>多键索引</figcaption></figure><blockquote><p>要了解详情，请参阅 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/index-multikey/#std-label-index-type-multikey" target="_blank" rel="noopener noreferrer">多键索引</a>。</p></blockquote><div class="hint-container info"><p class="hint-container-title">文本索引</p></div><p>文本索引支持对包含字符串内容的字段进行文本搜索查询。</p><blockquote><p>要了解详情，请参阅 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/index-text/#std-label-index-type-text" target="_blank" rel="noopener noreferrer">自管理部署上的文本索引。</a></p></blockquote><div class="hint-container info"><p class="hint-container-title">地理空间索引</p></div><p>地理空间索引可提高对地理空间坐标数据进行查询的性能。</p><p>MongoDB 提供两种类型的地理空间索引：</p><ul><li>使用平面几何返回结果的 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/geospatial/2d/#std-label-2d-index" target="_blank" rel="noopener noreferrer">2d 索引</a>。</li><li>使用球面几何返回结果的 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/geospatial/2dsphere/#std-label-2dsphere-index" target="_blank" rel="noopener noreferrer">2dsphere 索引</a>。</li></ul><blockquote><p>要了解详情，请参阅 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/index-geospatial/#std-label-geospatial-index" target="_blank" rel="noopener noreferrer">地理空间索引</a>。</p></blockquote><div class="hint-container info"><p class="hint-container-title">哈希索引</p></div><p>哈希索引支持 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/hashed-sharding/#std-label-sharding-hashed-sharding" target="_blank" rel="noopener noreferrer">哈希分片</a>。哈希索引对字段值的哈希值进行索引。</p><blockquote><p>要了解详情，请参阅 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/index-types/index-hashed/#std-label-index-type-hashed" target="_blank" rel="noopener noreferrer">哈希索引</a>。</p></blockquote><h3 id="【简单】复合索引中字段的顺序有影响吗-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】复合索引中字段的顺序有影响吗-⭐⭐⭐"><span>【简单】复合索引中字段的顺序有影响吗？⭐⭐⭐</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>MongoDB 复合索引类似 MySQL，遵循最左匹配原则</p></div><p><strong>排序键的排列顺序必须与其在索引中出现的顺序相同</strong>。例如，索引键模式 <code>{ a: 1, b: 1 }</code> 可以支持对 <code>{ a: 1, b: 1 }</code> 排序，但不支持对 <code>{ b: 1, a: 1 }</code> 排序。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503041116883.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。</p><p>走复合索引的排序：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>不走复合索引的排序：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以通过 explain 进行分析：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find().sort({</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;score&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userid&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}).explain()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>MongoDB 的复合索引遵循左前缀原则</strong>：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 <code>{a: 1, b: 1, c: 1, ..., z: 1}</code> 这样的索引，那么实际上也等于有了 <code>{a: 1}</code>、<code>{a: 1, b: 1}</code>、<code>{a: 1, b: 1, c: 1}</code> 等一系列索引，但是不会有 <code>{b: 1}</code> 这样的非左前缀的索引。</p><h3 id="【中等】什么是覆盖索引查询" tabindex="-1"><a class="header-anchor" href="#【中等】什么是覆盖索引查询"><span>【中等】什么是覆盖索引查询？</span></a></h3><div class="hint-container important"><p class="hint-container-title">要点</p><p>索引覆盖查询所需的所有字段，可以避免回表</p></div><p>根据官方文档介绍，覆盖查询是以下的查询：</p><ul><li>所有的查询字段是索引的一部分。</li><li>结果中返回的所有字段都在同一索引中。</li><li>查询中没有字段等于<code>null</code>。</li></ul><p>由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。因为索引存在于内存中，从索引中获取数据比通过扫描文档读取数据要快得多。</p><p>举个例子：我们有如下 <code>users</code> 集合：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   &quot;_id&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">ObjectId(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;53402597d852426020000002&quot;</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   &quot;contact&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;987654321&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   &quot;dob&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;01-01-1991&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   &quot;gender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;M&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   &quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Tom Benzamin&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   &quot;user_name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;tombenzamin&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在 <code>users</code> 集合中创建联合索引，字段为 <code>gender</code> 和 <code>user_name</code> :</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">users</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.ensureIndex({gender:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,user_name:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在，该索引会覆盖以下查询：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">users</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.find({gender:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;M&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">},{user_name:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,_id:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为了让指定的索引覆盖查询，必须显式地指定 <code>_id: 0</code> 来从结果中排除 <code>_id</code> 字段，因为索引不包括 <code>_id</code> 字段。</p><h2 id="mongodb-事务" tabindex="-1"><a class="header-anchor" href="#mongodb-事务"><span>MongoDB 事务</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions/" target="_blank" rel="noopener noreferrer">MongoDB 官方文档之事务</a></li><li><a href="https://mongoing.com/archives/82187" target="_blank" rel="noopener noreferrer">技术干货| MongoDB 事务原理</a></li><li><a href="https://developer.aliyun.com/article/782494" target="_blank" rel="noopener noreferrer">MongoDB 一致性模型设计与实现</a></li></ul></div><h3 id="【简单】mongodb-中如何使用事务-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】mongodb-中如何使用事务-⭐"><span>【简单】MongoDB 中如何使用事务？⭐</span></a></h3><p>MongoDB 从 4.0 版本开始支持多文档事务。</p><p>MongoDB 事务操作步骤：</p><ul><li>创建会话：<code>startSession</code></li><li>开始事务：<code>startTransaction</code></li><li>在事务中执行操作</li><li>提交或回滚事务：<code>commitTransaction</code> / <code>abortTransaction</code></li><li>关闭会话：<code>session.close</code></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ClientSession</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> session </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> mongoClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">startSession</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 1. 显式开始事务</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    session</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">startTransaction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(txnOptions);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 可以传入事务选项</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 2. 执行数据库操作（必须传入 session）</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    accountsCollection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">updateOne</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(session, filterAlice, updateAlice);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    accountsCollection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">updateOne</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(session, filterBob, updateBob);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    auditCollection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">insertOne</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(session, auditLog);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 3. 如果所有操作成功，提交事务</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    session</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">commitTransaction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;事务已提交。&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Exception</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">err</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;事务执行失败，正在回滚：&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 4. 如果发生任何异常，中止事务</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    session</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">abortTransaction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 5. 确保会话被关闭</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    session</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="【中等】mongodb-事务支持哪些操作-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】mongodb-事务支持哪些操作-⭐⭐⭐"><span>【中等】MongoDB 事务支持哪些操作？⭐⭐⭐</span></a></h3><p>可以跨多个操作、集合、数据库、文档和分片使用分布式事务。</p><p>对于事务：</p><ul><li>可以在事务中创建集合和索引。</li><li>事务中使用的集合可以位于不同的数据库中。</li></ul><div class="hint-container info"><p class="hint-container-title">在事务中创建集合和索引</p></div><p>如果事务不是跨分片写入事务，则可以在 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions/#std-label-transactions" target="_blank" rel="noopener noreferrer">分布式事务</a> 中执行以下操作：</p><ul><li>创建集合。</li><li>在先前同一事务中创建的新空集合上创建索引。</li></ul><p>在事务中创建集合时：</p><ul><li>可以 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions-operations/#std-label-transactions-operations-ddl-implicit" target="_blank" rel="noopener noreferrer">隐式创建一个集合</a>，例如： <ul><li>对不存在的集合进行 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions-operations/#std-label-transactions-operations-ddl-implicit" target="_blank" rel="noopener noreferrer">插入操作</a></li><li>对不存在的集合使用 <code>upsert: true</code> 进行 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions-operations/#std-label-transactions-operations-ddl-implicit" target="_blank" rel="noopener noreferrer">update/findAndModify 操作</a>。</li></ul></li><li>可以使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/create/#mongodb-dbcommand-dbcmd.create" target="_blank" rel="noopener noreferrer"><code>create</code></a> 命令或其辅助程序 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/create/#mongodb-dbcommand-dbcmd.create" target="_blank" rel="noopener noreferrer"><code>db.createCollection()</code></a><a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions-operations/#std-label-transactions-operations-ddl-explicit" target="_blank" rel="noopener noreferrer">显式创建集合</a>。</li></ul><p><a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions-operations/#std-label-transactions-operations-ddl-explicit" target="_blank" rel="noopener noreferrer">在事务内创建索引</a> 时，要创建的索引必须位于以下位置之一：</p><ul><li>不存在的集合。集合作为操作的一部分创建。</li><li>先前在同一事务中创建的新空集合。</li></ul><div class="hint-container info"><p class="hint-container-title">计数操作</p></div><p>要在事务内执行计数操作，请使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/count/#mongodb-pipeline-pipe.-count" target="_blank" rel="noopener noreferrer"><code>$count</code></a> 聚合阶段或 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a>（带有 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/sum/#mongodb-group-grp.-sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a> 表达式）聚合阶段。</p><p>MongoDB 驱动程序提供集合级 API <code>countDocuments(filter, options)</code> 作为辅助方法，该方法使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a> 和 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/sum/#mongodb-group-grp.-sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a> 表达式来执行计数。</p><p><a href="https://www.mongodb.com/zh-cn/docs/mongodb-shell/#mongodb-binary-bin.mongosh" target="_blank" rel="noopener noreferrer"><code>mongosh</code></a> 提供 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.countDocuments/#mongodb-method-db.collection.countDocuments" target="_blank" rel="noopener noreferrer"><code>db.collection.countDocuments()</code></a> 辅助方法，该方法使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a> 和 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/sum/#mongodb-group-grp.-sum" target="_blank" rel="noopener noreferrer"><code>$sum</code></a> 表达式进行计数。</p><div class="hint-container info"><p class="hint-container-title">去重操作</p></div><p>如要在事务中执行不同的操作：</p><ul><li><p>对于未分片的集合，可以使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.distinct/#mongodb-method-db.collection.distinct" target="_blank" rel="noopener noreferrer"><code>db.collection.distinct()</code></a> 方法 /<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/distinct/#mongodb-dbcommand-dbcmd.distinct" target="_blank" rel="noopener noreferrer"><code>distinct</code></a> 命令以及带有 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a> 阶段的聚合管道。</p></li><li><p>对于分片集合，不能使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.distinct/#mongodb-method-db.collection.distinct" target="_blank" rel="noopener noreferrer"><code>db.collection.distinct()</code></a> 方法或 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/distinct/#mongodb-dbcommand-dbcmd.distinct" target="_blank" rel="noopener noreferrer"><code>distinct</code></a> 命令。</p><p>要查找分片集合的不同值，请改用带有 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group" target="_blank" rel="noopener noreferrer"><code>$group</code></a> 阶段的 aggregation pipeline。例如：</p><ul><li><p>不使用 <code>db.coll.distinct(&quot;x&quot;)</code>，而是使用</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">coll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">aggregate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$group</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">distinctValues</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$addToSet</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;$x&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } } },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$project</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>不使用 <code>db.coll.distinct(&quot;x&quot;, { status: &quot;A&quot; })</code>，而是使用</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">coll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">aggregate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$match</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">status</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;A&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$group</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">distinctValues</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$addToSet</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;$x&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } } },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$project</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_id</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>管道返回一个指向文档的游标：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;distinctValues&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : [ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ] }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>迭代游标以访问结果文档。</p></li></ul><div class="hint-container info"><p class="hint-container-title">信息操作</p></div><p>事务中允许使用诸如 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/hello/#mongodb-dbcommand-dbcmd.hello" target="_blank" rel="noopener noreferrer"><code>hello</code></a>、<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/buildInfo/#mongodb-dbcommand-dbcmd.buildInfo" target="_blank" rel="noopener noreferrer"><code>buildInfo</code></a>、<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/connectionStatus/#mongodb-dbcommand-dbcmd.connectionStatus" target="_blank" rel="noopener noreferrer"><code>connectionStatus</code></a>（及其辅助方法）之类的信息命令，但它们不能是事务中的第一项操作。</p><div class="hint-container info"><p class="hint-container-title">事务操作限制</p></div><p>事务中不允许执行以下操作：</p><ul><li>在跨分片写事务中创建新集合。例如，如果在一个分片中写入一个现有集合，并在另一个分片中隐式创建一个集合，那么 MongoDB 将无法在同一事务中执行这两项操作。</li><li>使用 <a href="https://www.mongodb.com/zh-cn/docs/manual/core/transactions-operations/#std-label-transactions-operations-ddl-explicit" target="_blank" rel="noopener noreferrer"><code>&quot;local&quot;</code></a> 以外的读关注级别时，<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.createCollection/#mongodb-method-db.createCollection" target="_blank" rel="noopener noreferrer">显式创建集合</a>（例如 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.createIndexes/#mongodb-method-db.collection.createIndexes" target="_blank" rel="noopener noreferrer"><code>db.createCollection()</code></a> 方法）和索引（例如 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.createIndex/#mongodb-method-db.collection.createIndex" target="_blank" rel="noopener noreferrer"><code>db.collection.createIndexes()</code></a> 和 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/read-concern-local/#mongodb-readconcern-readconcern.-local-" target="_blank" rel="noopener noreferrer"><code>db.collection.createIndex()</code></a> 方法）。</li><li><a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/listCollections/#mongodb-dbcommand-dbcmd.listCollections" target="_blank" rel="noopener noreferrer"><code>listCollections</code></a> 和 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/listIndexes/#mongodb-dbcommand-dbcmd.listIndexes" target="_blank" rel="noopener noreferrer"><code>listIndexes</code></a> 命令及其辅助方法。</li><li>其他非 CRUD 和非信息性操作（例如 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/createUser/#mongodb-dbcommand-dbcmd.createUser" target="_blank" rel="noopener noreferrer"><code>createUser</code></a>、<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/getParameter/#mongodb-dbcommand-dbcmd.getParameter" target="_blank" rel="noopener noreferrer"><code>getParameter</code></a> 和 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/count/#mongodb-dbcommand-dbcmd.count" target="_blank" rel="noopener noreferrer"><code>count</code></a>）及其辅助程序。</li><li>并行操作。要同时更新多个命名空间，请考虑改用 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/command/bulkWrite/#mongodb-dbcommand-dbcmd.bulkWrite" target="_blank" rel="noopener noreferrer"><code>bulkWrite</code></a> 命令。</li></ul><h2 id="mongodb-集群" tabindex="-1"><a class="header-anchor" href="#mongodb-集群"><span>MongoDB 集群</span></a></h2><h3 id="【中等】mongodb-的副本机制是怎样的-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】mongodb-的副本机制是怎样的-⭐⭐⭐"><span>【中等】MongoDB 的副本机制是怎样的？⭐⭐⭐</span></a></h3><p>MongoDB 的复制集群又称为副本集群，是一组维护相同数据集合的 mongod 进程。</p><p>客户端连接到整个 Mongodb 复制集群，主节点机负责整个复制集群的写，从节点可以进行读操作，但默认还是主节点负责整个复制集群的读。主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p><p>通常来说，一个复制集群包含 1 个主节点（Primary），多个从节点（Secondary）以及零个或 1 个仲裁节点（Arbiter）。</p><ul><li><strong>主节点</strong>：整个集群的写操作入口，接收所有的写操作，并将集合所有的变化记录到操作日志中，即 oplog。主节点挂掉之后会自动选出新的主节点。</li><li><strong>从节点</strong>：从主节点同步数据，在主节点挂掉之后选举新节点。不过，从节点可以配置成 0 优先级，阻止它在选举中成为主节点。</li><li><strong>仲裁节点</strong>：这个是为了节约资源或者多机房容灾用，只负责主节点选举时投票不存数据，保证能有节点获得多数赞成票。</li></ul><p>下图是一个典型的三成员副本集群：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503042030712.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>主节点与备节点之间是通过 <strong>oplog（操作日志）</strong> 来同步数据的。oplog 是 local 库下的一个特殊的 <strong>上限集合 (Capped Collection)</strong> ，用来保存写操作所产生的增量日志，类似于 MySQL 中 的 Binlog。</p><blockquote><p>上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I/O 速度非常快，如果不建立索引，性能更好。</p></blockquote><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503042030639.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</p><p>副本集最多有一个主节点。 如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p><p>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</p><p>副本集最多有一个主节点。 如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p><p>为什么要用复制集群？</p><ul><li><strong>实现 failover</strong>：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li><li><strong>实现读写分离</strong>：我们可以设置从节点上可以读取数据，主节点负责写入数据，这样的话就实现了读写分离，减轻了主节点读写压力过大的问题。MongoDB 4.0 之前版本如果主库压力不大，不建议读写分离，因为写会阻塞读，除非业务对响应时间不是非常关注以及读取历史数据接受一定时间延迟。</li></ul><h3 id="【中等】什么是分片集群" tabindex="-1"><a class="header-anchor" href="#【中等】什么是分片集群"><span>【中等】什么是分片集群？</span></a></h3><p>分片集群是 MongoDB 的分布式版本，相较副本集，分片集群数据被均衡的分布在不同分片中， 不仅大幅提升了整个集群的数据容量上限，也将读写的压力分散到不同分片，以解决副本集性能瓶颈的难题。</p><p>MongoDB 的分片集群由如下三个部分组成（下图来源于 <a href="https://www.mongodb.com/docs/manual/sharding/" target="_blank" rel="noopener noreferrer">官方文档对分片集群的介绍</a>）：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503042043821.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p><strong>Config Servers</strong>：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</p></li><li><p><strong>Mongos</strong>：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</p></li><li><p><strong>Shard</strong>：每个分片是整体数据的一部分子集，从 MongoDB3.6 版本开始，每个 Shard 必须部署为副本集（replica set）架构</p></li></ul><h3 id="【简单】为什么要用分片集群" tabindex="-1"><a class="header-anchor" href="#【简单】为什么要用分片集群"><span>【简单】为什么要用分片集群？</span></a></h3><p>随着系统数据量以及吞吐量的增长，常见的解决办法有两种：垂直扩展和水平扩展。</p><p>垂直扩展通过增加单个服务器的能力来实现，比如磁盘空间、内存容量、CPU 数量等；水平扩展则通过将数据存储到多个服务器上来实现，根据需要添加额外的服务器以增加容量。</p><p>类似于 Redis Cluster，MongoDB 也可以通过分片实现 <strong>水平扩展</strong> 。水平扩展这种方式更灵活，可以满足更大数据量的存储需求，支持更高吞吐量。并且，水平扩展所需的整体成本更低，仅仅需要相对较低配置的单机服务器即可，代价是增加了部署的基础设施和维护的复杂性。</p><p>也就是说当你遇到如下问题时，可以使用分片集群解决：</p><ul><li>存储容量受单机限制，即磁盘资源遭遇瓶颈。</li><li>读写能力受单机限制，可能是 CPU、内存或者网卡等资源遭遇瓶颈，导致读写能力无法扩展。</li></ul><h3 id="【简单】如何选择分片键" tabindex="-1"><a class="header-anchor" href="#【简单】如何选择分片键"><span>【简单】如何选择分片键？</span></a></h3><p>选择合适的片键对 sharding 效率影响很大，主要基于如下四个因素（摘自 <a href="https://cloud.tencent.com/document/product/240/44611" target="_blank" rel="noopener noreferrer">分片集群使用注意事项 - - 腾讯云文档</a>）：</p><ul><li><strong>取值基数</strong> 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。 例如：选择年龄做一个基数，范围最多只有 100 个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li><li><strong>取值分布</strong> 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li><li><strong>查询带分片</strong> 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li><li><strong>避免单调递增或递减</strong> 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li></ul><p>综上，在选择片键时要考虑以上 4 个条件，尽可能满足更多的条件，才能降低 MoveChunks 对性能的影响，从而获得最优的性能体验。</p><h3 id="【中等】分片策略有哪些-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】分片策略有哪些-⭐⭐⭐"><span>【中等】分片策略有哪些？⭐⭐⭐</span></a></h3><p>MongoDB 支持两种分片算法来满足不同的查询需求（摘自 <a href="https://help.aliyun.com/document_detail/64561.html?spm=a2c4g.11186623.0.0.3121565eQhUGGB#h2--shard-key-3" target="_blank" rel="noopener noreferrer">MongoDB 分片集群介绍 - 阿里云文档</a>）：</p><p><strong>1、基于范围的分片</strong>：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503042049549.png" alt="基于范围的分片" tabindex="0" loading="lazy"><figcaption>基于范围的分片</figcaption></figure><p>MongoDB 按照分片键（Shard Key）的值的范围将数据拆分为不同的块（Chunk），每个块包含了一段范围内的数据。当分片键的基数大、频率低且值非单调变更时，范围分片更高效。</p><ul><li>优点：Mongos 可以快速定位请求需要的数据，并将请求转发到相应的 Shard 节点中。</li><li>缺点：可能导致数据在 Shard 节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li><li>适用场景：分片键的值不是单调递增或单调递减、分片键的值基数大且重复的频率低、需要范围查询等业务场景。</li></ul><p><strong>2、基于 Hash 值的分片</strong></p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503052222683.png" alt="基于 Hash 值的分片" tabindex="0" loading="lazy"><figcaption>基于 Hash 值的分片</figcaption></figure><p>MongoDB 计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块（Chunk）。</p><ul><li>优点：可以将数据更加均衡地分布在各 Shard 节点中，具备写分散性。</li><li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的 Shard 节点。</li><li>适用场景：分片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li></ul><p>除了上述两种分片策略，您还可以配置 <strong>复合片键</strong> ，例如由一个低基数的键和一个单调递增的键组成。</p><h3 id="【中等】分片数据如何存储-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】分片数据如何存储-⭐⭐⭐"><span>【中等】分片数据如何存储？⭐⭐⭐</span></a></h3><p><strong>Chunk（块）</strong> 是 MongoDB 分片集群的一个核心概念，其本质上就是由一组 Document 组成的逻辑数据单元。每个 Chunk 包含一定范围片键的数据，互不相交且并集为全部数据，即离散数学中<strong>划分</strong>的概念。</p><p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上以及这个 Chunk 包含哪些数据。</p><p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 <strong>Chunk 分裂</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503042053916.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 <strong>均衡器 (Balancer)</strong> 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 <strong>再平衡（Rebalance）</strong>。默认情况下，数据库和集合的 Rebalance 是开启的。</p><p>如下图所示，随着数据插入，导致 Chunk 分裂，让 AB 两个分片有 3 个 Chunk，C 分片只有一个，这个时候就会把 B 分配的迁移一个到 C 分片实现集群数据均衡。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503042054456.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>Balancer 是 MongoDB 的一个运行在 Config Server 的 Primary 节点上（自 MongoDB 3.4 版本起）的后台进程，它监控每个分片上 Chunk 数量，并在某个分片上 Chunk 数量达到阈值进行迁移。</p></blockquote><p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p><p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p>`,306))])}const g=s(r,[["render",l]]),c=JSON.parse('{"path":"/pages/cae9f346/","title":"MongoDB 面试","lang":"zh-CN","frontmatter":{"icon":"logos:mongodb","title":"MongoDB 面试","cover":"https://raw.githubusercontent.com/dunwu/images/master/snap/202503062328094.jpg","date":"2025-03-04T21:03:08.000Z","categories":["数据库","文档数据库","MongoDB"],"tags":["数据库","文档数据库","MongoDB","面试"],"permalink":"/pages/cae9f346/","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MongoDB 面试\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200921092725.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200921200556.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200921155546.svg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503041024526.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503041024137.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503041050392.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200921210621.svg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503052211281.svg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503052213721.svg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503052214522.svg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503041116883.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503042030712.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503042030639.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503042043821.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503042049549.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503052222683.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503042053916.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/202503042054456.png\\"],\\"datePublished\\":\\"2025-03-04T21:03:08.000Z\\",\\"dateModified\\":\\"2026-01-28T13:53:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/cae9f346/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"MongoDB 面试"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/snap/202503062328094.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-28T13:53:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://raw.githubusercontent.com/dunwu/images/master/snap/202503062328094.jpg"}],["meta",{"name":"twitter:image:alt","content":"MongoDB 面试"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"MongoDB"}],["meta",{"property":"article:tag","content":"文档数据库"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2025-03-04T21:03:08.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-28T13:53:35.000Z"}]]},"git":{"createdTime":1741093684000,"updatedTime":1769608415000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":14,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":40.88,"words":12265},"filePathRelative":"12.数据库/文档数据库/MongoDB/MongoDB_面试.md","excerpt":"\\n"}');export{g as comp,c as data};
