import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as r}from"./app-BovpQKqx.js";const i={};function p(o,e){return r(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="面向对象设计六大原则" tabindex="-1"><a class="header-anchor" href="#面向对象设计六大原则"><span>面向对象设计六大原则</span></a></h1><h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h2><p>单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。</p><p>简单点说，<strong>一个类，最好只负责一件事。</strong></p><h2 id="开放-封闭原则" tabindex="-1"><a class="header-anchor" href="#开放-封闭原则"><span>开放-封闭原则</span></a></h2><p>开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。</p><p>对于扩展是开放的；对于更改是封闭的。</p><h2 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则"><span>里氏替换原则</span></a></h2><p>里氏替换原则（Liskov Substitution Principle），子类可以替换父类。</p><h2 id="依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则"><span>依赖倒置原则</span></a></h2><p>依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p><p>关键点：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><h2 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h2><p>接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><ul><li>客户端不应依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ul><h2 id="迪米特原则" tabindex="-1"><a class="header-anchor" href="#迪米特原则"><span>迪米特原则</span></a></h2><p>迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p>一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener noreferrer">《Head First 设计模式》</a></li><li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener noreferrer">《大话设计模式》</a></li></ul>',21)])])}const c=t(i,[["render",p]]),d=JSON.parse('{"path":"/pages/5acdf542/","title":"面向对象原则","lang":"zh-CN","frontmatter":{"title":"面向对象原则","date":"2021-05-19T09:49:05.000Z","order":25,"categories":["设计","设计模式"],"tags":["设计","设计模式"],"permalink":"/pages/5acdf542/","description":"面向对象设计六大原则 单一职责原则 单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。 简单点说，一个类，最好只负责一件事。 开放-封闭原则 开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。 对于扩展是开放的；对于更改是封...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-05-19T09:49:05.000Z\\",\\"dateModified\\":\\"2025-09-15T00:29:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/5acdf542/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"面向对象原则"}],["meta",{"property":"og:description","content":"面向对象设计六大原则 单一职责原则 单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。 简单点说，一个类，最好只负责一件事。 开放-封闭原则 开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。 对于扩展是开放的；对于更改是封..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-15T00:29:21.000Z"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:tag","content":"设计"}],["meta",{"property":"article:published_time","content":"2021-05-19T09:49:05.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-15T00:29:21.000Z"}]]},"git":{"createdTime":1651071272000,"updatedTime":1757896161000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":6,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"03.设计/设计模式/面向对象原则.md","excerpt":"\\n<h2>单一职责原则</h2>\\n<p>单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。</p>\\n<p>简单点说，<strong>一个类，最好只负责一件事。</strong></p>\\n<h2>开放-封闭原则</h2>\\n<p>开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。</p>\\n<p>对于扩展是开放的；对于更改是封闭的。</p>\\n<h2>里氏替换原则</h2>\\n<p>里氏替换原则（Liskov Substitution Principle），子类可以替换父类。</p>","autoDesc":true}');export{c as comp,d as data};
