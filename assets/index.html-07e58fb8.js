import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as l,a as t,b as e,d as n,e as d}from"./app-f3a321ac.js";const r={},c=d('<h1 id="redis-面试之数据类型篇" tabindex="-1"><a class="header-anchor" href="#redis-面试之数据类型篇" aria-hidden="true">#</a> Redis 面试之数据类型篇</h1><h2 id="redis-数据类型" tabindex="-1"><a class="header-anchor" href="#redis-数据类型" aria-hidden="true">#</a> Redis 数据类型</h2><h3 id="【简单】redis-支持哪些数据类型" tabindex="-1"><a class="header-anchor" href="#【简单】redis-支持哪些数据类型" aria-hidden="true">#</a> 【简单】Redis 支持哪些数据类型？</h3><ul><li>Redis 支持五种基本数据类型：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。</li><li>随着 Redis 版本升级，又陆续支持以下数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/202506152022430.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',5),p=t("strong",null,"扩展",-1),u={href:"https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/",target:"_blank",rel:"noopener noreferrer"},g=d('<h3 id="【简单】redis-基础数据类型的常见命令有哪些" tabindex="-1"><a class="header-anchor" href="#【简单】redis-基础数据类型的常见命令有哪些" aria-hidden="true">#</a> 【简单】Redis 基础数据类型的常见命令有哪些？</h3><h4 id="string-命令" tabindex="-1"><a class="header-anchor" href="#string-命令" aria-hidden="true">#</a> String 命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>SET</code></td><td>存储一个字符串值</td></tr><tr><td><code>SETNX</code></td><td>仅当键不存在时，才存储字符串值</td></tr><tr><td><code>GET</code></td><td>获取指定 key 的值</td></tr><tr><td><code>MGET</code></td><td>获取一个或多个指定 key 的值</td></tr><tr><td><code>INCRBY</code></td><td>将 key 中储存的数字加上指定的增量值</td></tr><tr><td><code>DECRBY</code></td><td>将 key 中储存的数字减去指定的减量值</td></tr></tbody></table>',3),h=t("strong",null,"扩展",-1),b={href:"https://redis.io/commands#string",target:"_blank",rel:"noopener noreferrer"},m=d('<h4 id="hash-命令" tabindex="-1"><a class="header-anchor" href="#hash-命令" aria-hidden="true">#</a> Hash 命令</h4><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>HSET</code></td><td>将指定字段的值设为 value</td></tr><tr><td><code>HGET</code></td><td>获取指定字段的值</td></tr><tr><td><code>HGETALL</code></td><td>获取所有键值对</td></tr><tr><td><code>HMSET</code></td><td>设置多个键值对</td></tr><tr><td><code>HMGET</code></td><td>获取所有指定字段的值</td></tr><tr><td><code>HDEL</code></td><td>删除指定字段</td></tr><tr><td><code>HINCRBY</code></td><td>为指定字段的整数值加上增量</td></tr><tr><td><code>HKEYS</code></td><td>获取所有字段</td></tr></tbody></table>',2),v=t("strong",null,"扩展",-1),k={href:"https://redis.io/commands#hash",target:"_blank",rel:"noopener noreferrer"},f=d('<h4 id="list-命令" tabindex="-1"><a class="header-anchor" href="#list-命令" aria-hidden="true">#</a> List 命令</h4><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>LPUSH</code></td><td>将给定值推入列表的右端。</td></tr><tr><td><code>RPUSH</code></td><td>将给定值推入列表的右端。</td></tr><tr><td><code>LPOP</code></td><td>从列表的左端弹出一个值，并返回被弹出的值。</td></tr><tr><td><code>RPOP</code></td><td>从列表的右端弹出一个值，并返回被弹出的值。</td></tr><tr><td><code>LRANGE</code></td><td>获取列表在给定范围上的所有值。</td></tr><tr><td><code>LINDEX</code></td><td>获取列表在给定位置上的单个元素。</td></tr><tr><td><code>LREM</code></td><td>从列表的左端弹出一个值，并返回被弹出的值。</td></tr><tr><td><code>LTRIM</code></td><td>只保留指定区间内的元素，删除其他元素。</td></tr></tbody></table>',2),R=t("strong",null,"扩展",-1),y={href:"https://redis.io/commands#list",target:"_blank",rel:"noopener noreferrer"},x=d('<h4 id="set-命令" tabindex="-1"><a class="header-anchor" href="#set-命令" aria-hidden="true">#</a> Set 命令</h4><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>SADD</code></td><td>将给定元素添加到集合。</td></tr><tr><td><code>SMEMBERS</code></td><td>返回集合包含的所有元素。</td></tr><tr><td><code>SISMEMBER</code></td><td>检查给定元素是否存在于集合中。</td></tr><tr><td><code>SREM</code></td><td>如果给定的元素存在于集合中，那么移除这个元素。</td></tr></tbody></table>',2),E=t("strong",null,"扩展",-1),S={href:"https://redis.io/commands#set",target:"_blank",rel:"noopener noreferrer"},_=d('<h4 id="zset-命令" tabindex="-1"><a class="header-anchor" href="#zset-命令" aria-hidden="true">#</a> Zset 命令</h4><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>ZADD</code></td><td>将一个带有给定分值的成员添加到有序集合里面</td></tr><tr><td><code>ZRANGE</code></td><td>顺序排序，并返回指定排名区间的成员</td></tr><tr><td><code>ZREVRANGE</code></td><td>反序排序，并返回指定排名区间的成员</td></tr><tr><td><code>ZRANGEBYSCORE</code></td><td>顺序排序，并返回指定排名区间的成员及其分值</td></tr><tr><td><code>ZREVRANGEBYSCORE</code></td><td>反序排序，并返回指定排名区间的成员及其分值</td></tr><tr><td><code>ZREM</code></td><td>移除指定的成员</td></tr><tr><td><code>ZSCORE</code></td><td>返回指定成员的分值</td></tr><tr><td><code>ZCARD</code></td><td>返回所有成员数</td></tr></tbody></table>',2),I=t("strong",null,"扩展",-1),D={href:"https://redis.io/commands#sorted_set",target:"_blank",rel:"noopener noreferrer"},q=d(`<h3 id="【中等】redis-各数据类型的应用场景" tabindex="-1"><a class="header-anchor" href="#【中等】redis-各数据类型的应用场景" aria-hidden="true">#</a> 【中等】Redis 各数据类型的应用场景？</h3><ul><li><strong>String（字符串）</strong> - 缓存对象、分布式 Session、分布式锁、计数器、限流器、分布式 ID 等。</li><li><strong>Hash（哈希）</strong> - 缓存对象、购物车等。</li><li><strong>List（列表）</strong> - 消息队列</li><li><strong>Set（集合）</strong> - 聚合计算（并集、交集、差集），如点赞、共同关注、抽奖活动等。</li><li><strong>Zset（有序集合）</strong> - 排序场景，如排行榜、电话和姓名排序等。</li><li><strong>BitMap</strong>（2.2 版新增） - 二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li><strong>HyperLogLog</strong>（2.8 版新增） - 海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li><strong>GEO</strong>（3.2 版新增） - 存储地理位置信息的场景，比如滴滴叫车；</li><li><strong>Stream</strong>（5.0 版新增） - 消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309232144470.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【困难】redis-基础数据类型的底层实现是怎样的" tabindex="-1"><a class="header-anchor" href="#【困难】redis-基础数据类型的底层实现是怎样的" aria-hidden="true">#</a> 【困难】Redis 基础数据类型的底层实现是怎样的？</h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/202506152022257.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>String 类型</strong> - String 类型的底层数据结构是 SDS。SDS 是 Redis 针对字符串类型的优化，具有以下特性： <ul><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串长度时所需的内存重分配次数</li></ul></li><li><strong>List 类型</strong> - 列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code>。当列表对象可以同时满足以下两个条件时，列表对象使用 <code>ziplist</code> 编码；否则，使用 <code>linkedlist</code> 编码。 <ul><li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li><li>列表对象保存的元素数量小于 <code>512</code> 个；</li></ul></li><li><strong>Hash 类型</strong> - 哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code>。当哈希对象同时满足以下两个条件时，使用 <code>ziplist</code> 编码；否则，使用 <code>hashtable</code> 编码。 <ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li><li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li></ul></li><li><strong>Set 类型</strong> - 集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code>。当集合对象可以同时满足以下两个条件时，集合对象使用 <code>intset</code> 编码；否则，使用 <code>hashtable</code> 编码。 <ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 <code>512</code> 个；</li></ul></li><li><strong>Zset 类型</strong> - 有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code>。当有序集合对象可以同时满足以下两个条件时，有序集合对象使用 <code>ziplist</code> 编码；否则，使用 <code>skiplist</code> 编码。 <ul><li>有序集合保存的元素数量小于 <code>128</code> 个；</li><li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li></ul></li></ul><h3 id="【困难】redis-为什么用-listpack-替代-ziplist" tabindex="-1"><a class="header-anchor" href="#【困难】redis-为什么用-listpack-替代-ziplist" aria-hidden="true">#</a> 【困难】Redis 为什么用 <code>listpack</code> 替代 <code>ziplist</code>？</h3><p><strong><code>listpack</code> 是 Redis 5.0 引入的优化结构，用来替代 <code>ziplist</code></strong>，作为 <code>hash</code>、<code>list</code>、<code>zset</code> 数据类型的实现编码之一。</p><p>二者对比如下：</p><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;"><code>ziplist</code></th><th style="text-align:left;"><code>listpack</code></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>级联更新</strong></td><td style="text-align:left;">可能发生（最坏 <code>O(n)</code>）</td><td style="text-align:left;">完全避免（稳定 <code>O(1)</code>）</td></tr><tr><td style="text-align:left;"><strong>内存占用</strong></td><td style="text-align:left;">预留空间可能浪费</td><td style="text-align:left;">按需分配，更紧凑</td></tr><tr><td style="text-align:left;"><strong>安全性</strong></td><td style="text-align:left;">需手动校验边界</td><td style="text-align:left;">内置长度校验，防溢出</td></tr><tr><td style="text-align:left;"><strong>版本</strong></td><td style="text-align:left;">Redis 旧版本</td><td style="text-align:left;">Redis 5.0+ 的 Hash、ZSet 等</td></tr></tbody></table><p><strong><code>ziplist</code> 的缺陷</strong></p><ul><li><strong>级联更新问题</strong> - 当修改或删除中间某个元素时，可能引发后续所有节点的内存重分配（因为 <code>ziplist</code> 用 <strong>前驱节点长度</strong> 定位数据）。最坏情况下时间复杂度从 <code>O(1)</code> 退化到 <code>O(n)</code>，影响性能。</li><li><strong>内存浪费</strong> - <code>ziplist</code> 为每个节点预留 <strong>1~5 字节</strong> 存储前驱节点长度（即使实际不需要这么多空间）。对于短小的数据（如小整数），存储开销比例过高。</li><li><strong>安全性风险</strong> - <code>ziplist</code> 对内存布局的强依赖可能导致 <strong>缓冲区溢出</strong>（需严格校验边界）。</li></ul><p><strong><code>listpack</code> 的改进</strong></p><ul><li><strong>消除级联更新</strong> - 每个节点 <strong>独立存储自身长度</strong>（不再依赖前驱节点）。修改任意节点仅影响当前节点，时间复杂度稳定为 <code>O(1)</code>。</li><li><strong>更紧凑的内存布局</strong> - 节点长度字段采用 <strong>变长编码</strong>（类似 Protobuf 的 Varint），根据实际需求分配 1~5 字节。存储小整数时，长度字段仅需 1 字节。</li><li><strong>更强的安全性</strong> - 每个节点记录 <strong>总长度</strong> 和 <strong>校验字段</strong>，避免解析越界。</li><li><strong>兼容性与平滑替换</strong> - <code>listpack</code> 的 API 设计兼容 <code>ziplist</code>，Redis 内部可无缝迁移（如 Hash、ZSet 的底层实现）。</li></ul><h3 id="【困难】为什么-zset-用跳表实现而不是红黑树、b-树" tabindex="-1"><a class="header-anchor" href="#【困难】为什么-zset-用跳表实现而不是红黑树、b-树" aria-hidden="true">#</a> 【困难】为什么 Zset 用跳表实现而不是红黑树、B+树？</h3><ul><li><strong>实现简单性</strong><ul><li>跳表的实现比红黑树简单得多，代码更易于维护和调试。</li><li>红黑树需要处理复杂的旋转和重新平衡操作，而跳表的平衡是通过概率实现的。</li></ul></li><li><strong>范围查询效率</strong><ul><li>跳表在范围查询（如 <code>zrange</code>）上表现优异，因为它是基于链表的结构，可以线性遍历。</li><li>红黑树进行范围查询需要中序遍历，相对复杂。</li><li>B+树虽然也擅长范围查询，但实现复杂度更高。</li></ul></li><li><strong>并发性能</strong><ul><li>跳表更容易实现<strong>无锁并发</strong>操作 (Redis 虽然是单线程，但考虑未来扩展）</li><li>红黑树的平衡操作涉及大量指针修改，难以实现高效的并发控制</li></ul></li><li><strong>内存效率</strong><ul><li>跳表不需要像 B+ 树那样维护严格的树形结构，内存使用更灵活</li><li>B+树的节点通常设计为填满一定比例，可能造成内存浪费</li></ul></li><li><strong>性能平衡</strong><ul><li>跳表的查询、插入、删除操作时间复杂度都是 O(logN)，与红黑树相当</li><li>跳表的实际性能在实践中表现良好，特别是对于内存数据结构</li></ul></li><li>Redis 的特殊需求 <ul><li>Redis 的 Zset 需要同时支持按 score 和按 member 查询，跳表+哈希表的组合完美满足这一需求</li><li>Redis 是内存数据库，不需要考虑 B+树针对磁盘 I/O 优化的特性</li></ul></li></ul><h3 id="【困难】跳表的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#【困难】跳表的实现原理是什么" aria-hidden="true">#</a> 【困难】跳表的实现原理是什么？</h3><p>跳表是一种可以实现二分查找的有序链表，通过多级索引提升查找效率。跳表的查找、插入、删除操作的时间复杂度均为 O(log n)，与平衡二叉树（如红黑树）接近。</p><p>对于一个有序数组，可以使用高效的二分查找法，其时间复杂度为 <code>O(log n)</code>。</p><p>但是，即使是有序的链表，也只能使用低效的顺序查找，其时间复杂度为 <code>O(n)</code>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323113532.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如何提高链表的查找效率呢？</p><p>我们可以对链表加一层索引。具体来说，可以每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作<strong>索引</strong>或<strong>索引层</strong>。索引节点中通过一个 down 指针，指向下一级结点。通过这样的改造，就可以支持类似二分查找的算法。我们把改造之后的数据结构叫作<strong>跳表</strong>（Skip list）。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155309.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>随着数据的不断增长，一级索引层也变得越来越长。此时，我们可以为一级索引再增加一层索引层：二级索引层。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155346.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>随着数据的膨胀，当二级索引层也变得很长时，我们可以继续为其添加新的索引层。<strong>这种链表加多级索引的结构，就是跳表</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323114408.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>跳表的时间复杂度</strong></p><ul><li><strong>查找</strong>：从最高级索引开始逐层下沉，每层最多遍历 3 个节点，时间复杂度为 <code>O(log n)</code>。</li><li><strong>插入</strong>：先查找插入位置（<code>O(log n)</code>），再随机生成索引层级（<code>O(log n)</code>），总时间复杂度为 <code>O(log n)</code>。</li><li><strong>删除</strong>：类似查找过程，删除节点及其索引（<code>O(log n)</code>）。</li></ul><p><strong>跳表的空间复杂度</strong></p><ul><li>索引节点总数为 <code>n/2 + n/4 + n/8 + … ≈ n</code>，空间复杂度为 <strong>O(n)</strong>。</li><li>可通过调整索引密度（如每 3 个节点抽 1 个）减少空间占用，但会牺牲部分查找效率。</li></ul><h3 id="【困难】redis-利用什么机制来实现各种数据结构" tabindex="-1"><a class="header-anchor" href="#【困难】redis-利用什么机制来实现各种数据结构" aria-hidden="true">#</a> 【困难】Redis 利用什么机制来实现各种数据结构？</h3><p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。</p><p>Redis 数据库中的每个键值对的键和值都是一个对象。Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</p><p>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</p><h4 id="对象的类型" tabindex="-1"><a class="header-anchor" href="#对象的类型" aria-hidden="true">#</a> 对象的类型</h4><p><strong>Redis 使用对象来表示数据库中的键和值</strong>。每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p><p>Redis 中的每个对象都由一个 <code>redisObject</code> 结构表示， 该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>

    <span class="token comment">// 类型</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment">// 编码</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment">// 指向底层实现数据结构的指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>

    <span class="token comment">// ...</span>

<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对象的 <code>type</code> 属性记录了对象的类型，有以下类型：</p><table><thead><tr><th style="text-align:left;">对象</th><th style="text-align:left;">对象 <code>type</code> 属性的值</th><th style="text-align:left;">TYPE 命令的输出</th></tr></thead><tbody><tr><td style="text-align:left;">字符串对象</td><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>&quot;string&quot;</code></td></tr><tr><td style="text-align:left;">列表对象</td><td style="text-align:left;"><code>REDIS_LIST</code></td><td style="text-align:left;"><code>&quot;list&quot;</code></td></tr><tr><td style="text-align:left;">哈希对象</td><td style="text-align:left;"><code>REDIS_HASH</code></td><td style="text-align:left;"><code>&quot;hash&quot;</code></td></tr><tr><td style="text-align:left;">集合对象</td><td style="text-align:left;"><code>REDIS_SET</code></td><td style="text-align:left;"><code>&quot;set&quot;</code></td></tr><tr><td style="text-align:left;">有序集合对象</td><td style="text-align:left;"><code>REDIS_ZSET</code></td><td style="text-align:left;"><code>&quot;zset&quot;</code></td></tr></tbody></table><p>Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p><h4 id="对象的编码" tabindex="-1"><a class="header-anchor" href="#对象的编码" aria-hidden="true">#</a> 对象的编码</h4><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 <code>encoding</code> 属性决定。</p><p><code>encoding</code> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现。</p><p>Redis 中每种类型的对象都至少使用了两种不同的编码，<strong>不同的编码可以在不同的使用场景上优化对象的使用效率</strong>。</p><p>Redis 支持的编码如下所示：</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">编码</th><th style="text-align:left;">对象</th><th><strong>OBJECT ENCODING</strong> <strong>命令输出</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>REDIS_ENCODING_INT</code></td><td style="text-align:left;">使用整数值实现的字符串对象。</td><td>&quot;int&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>REDIS_ENCODING_EMBSTR</code></td><td style="text-align:left;">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td><td>&quot;embstr&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_STRING</code></td><td style="text-align:left;"><code>REDIS_ENCODING_RAW</code></td><td style="text-align:left;">使用简单动态字符串实现的字符串对象。</td><td>&quot;raw&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_LIST</code></td><td style="text-align:left;"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left;">使用压缩列表实现的列表对象。</td><td>&quot;ziplist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_LIST</code></td><td style="text-align:left;"><code>REDIS_ENCODING_LINKEDLIST</code></td><td style="text-align:left;">使用双端链表实现的列表对象。</td><td>&quot;linkedlist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_HASH</code></td><td style="text-align:left;"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left;">使用压缩列表实现的哈希对象。</td><td>&quot;ziplist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_HASH</code></td><td style="text-align:left;"><code>REDIS_ENCODING_HT</code></td><td style="text-align:left;">使用字典实现的哈希对象。</td><td>&quot;hashtable&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_SET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_INTSET</code></td><td style="text-align:left;">使用整数集合实现的集合对象。</td><td>&quot;intset&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_SET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_HT</code></td><td style="text-align:left;">使用字典实现的集合对象。</td><td>&quot;hashtable&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_ZSET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left;">使用压缩列表实现的有序集合对象。</td><td>&quot;ziplist&quot;</td></tr><tr><td style="text-align:left;"><code>REDIS_ZSET</code></td><td style="text-align:left;"><code>REDIS_ENCODING_SKIPLIST</code></td><td style="text-align:left;">使用跳表和字典实现的有序集合对象。</td><td>&quot;skiplist&quot;</td></tr></tbody></table><h4 id="内存回收" tabindex="-1"><a class="header-anchor" href="#内存回收" aria-hidden="true">#</a> 内存回收</h4><p>由于 C 语言不支持内存回收，Redis 内部实现了一套基于引用计数的内存回收机制。</p><p>每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录。当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</p><h4 id="对象共享" tabindex="-1"><a class="header-anchor" href="#对象共享" aria-hidden="true">#</a> 对象共享</h4><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p><p>Redis 会在初始化服务器时， 共享值为 <code>0</code> 到 <code>9999</code></p><h4 id="对象的空转时长" tabindex="-1"><a class="header-anchor" href="#对象的空转时长" aria-hidden="true">#</a> 对象的空转时长</h4><p><code>redisObject</code> 的 <code>lru</code> 属性记录了对象最后一次被命令程序访问的时间。</p><p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p><h3 id="【中等】如何使用-redis-实现排行榜" tabindex="-1"><a class="header-anchor" href="#【中等】如何使用-redis-实现排行榜" aria-hidden="true">#</a> 【中等】如何使用 Redis 实现排行榜？</h3><p>各种排行榜，如：内容平台（视频、歌曲、文章）的播放量/收藏量/评分排行榜；电商网站的销售排行榜等等，都可以基于 Redis zset 类型来实现。</p><p>我们以博文点赞排名为例，dunwu 发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># article:1 文章获得了 200 个赞</span>
<span class="token operator">&gt;</span> ZADD user:dunwu:ranking <span class="token number">200</span> article:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># article:2 文章获得了 40 个赞</span>
<span class="token operator">&gt;</span> ZADD user:dunwu:ranking <span class="token number">40</span> article:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># article:3 文章获得了 100 个赞</span>
<span class="token operator">&gt;</span> ZADD user:dunwu:ranking <span class="token number">100</span> article:3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># article:4 文章获得了 50 个赞</span>
<span class="token operator">&gt;</span> ZADD user:dunwu:ranking <span class="token number">50</span> article:4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># article:5 文章获得了 150 个赞</span>
<span class="token operator">&gt;</span> ZADD user:dunwu:ranking <span class="token number">150</span> article:5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文章 article:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合 key 中元素 member 的分值加上 increment）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZINCRBY user:dunwu:ranking <span class="token number">1</span> article:4
<span class="token string">&quot;51&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合 key 中元素个数）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZSCORE user:dunwu:ranking article:4
<span class="token string">&quot;50&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 dunwu 文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从 start 下标到 stop 下标的元素）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># WITHSCORES 表示把 score 也显示出来</span>
<span class="token operator">&gt;</span> ZREVRANGE user:dunwu:ranking <span class="token number">0</span> <span class="token number">2</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;article:1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;article:5&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;150&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;article:3&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;100&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 dunwu 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYSCORE user:dunwu:ranking <span class="token number">100</span> <span class="token number">200</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;article:3&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;100&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;article:5&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;150&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;article:1&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="【中等】如何使用-redis-实现百万级网页-uv-计数" tabindex="-1"><a class="header-anchor" href="#【中等】如何使用-redis-实现百万级网页-uv-计数" aria-hidden="true">#</a> 【中等】如何使用 Redis 实现百万级网页 UV 计数？</h3><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种<strong>用于“统计基数”的数据集合类型</strong>，基数统计就是指统计一个集合中不重复的元素个数。但要注意，<strong>HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%</strong>（统计结果为 100 万时，实际可能在 99.19 万~100.81 万之间）。</p><p><strong>核心优势</strong></p><ul><li><strong>极低内存占用</strong>：仅需 <strong>12 KB</strong> 内存，即可统计接近 <strong>2^64</strong> 个元素的基数（如 UV 统计）。</li><li><strong>适合海量数据</strong>：相比 <code>Set</code>/<code>Hash</code>（元素越多内存消耗越大），HyperLogLog 在<strong>百万级以上数据</strong>场景中优势显著。</li></ul><p><strong>适用场景</strong></p><ul><li><strong>网页 UV 统计</strong>：统计独立访客数（如 <code>page1:uv</code>），尤其适合高并发、大数据量场景。</li><li><strong>容忍误差的基数统计</strong>：如热门活动页面访问量、广告点击去重等。</li></ul><p>如果需要精确统计，则需要转用 <code>Set</code> / <code>Hash</code>，并且不得不消耗</p><p><strong>基本命令</strong></p><ul><li><p><strong>添加元素</strong>：<code>PFADD key element [element...]</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PFADD page1:uv user1 user2 user3  <span class="token comment"># 将用户添加到 UV 统计</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>获取统计值</strong>：<code>PFCOUNT key</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PFCOUNT page1:uv  <span class="token comment"># 返回近似 UV 数（如 100 万）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="【中等】如何使用-redis-实现布隆过滤器" tabindex="-1"><a class="header-anchor" href="#【中等】如何使用-redis-实现布隆过滤器" aria-hidden="true">#</a> 【中等】如何使用 Redis 实现布隆过滤器？</h3><p>布隆过滤器是一种高效的概率数据结构，常用于检测一个元素是否在一个集合中，可以有效减少数据库的查询次数，解决缓存穿透等问题。</p><p>可以通过以下两种方式实现布隆过滤器：</p><p><strong>使用位图（Bitmap）实现布隆过滤器：</strong></p><ul><li>使用 Redis 的位图结构 <code>SETBIT</code> 和 <code>GETBIT</code> 操作来实现布隆过滤器。位图本质上是一个比特数组，用于标识元素是否存在。</li><li>对于给定的数据，通过多个哈希函数计算位置索引，将位图中的相应位置设置为 1，表示该元素可能存在。</li></ul><p><strong>使用 RedisBloom 模块：</strong></p><ul><li>Redis 提供了一个官方模块 RedisBloom，封装了哈希函数、位图大小等操作，可以直接用于创建和管理布隆过滤器。</li><li>使用 <code>BF.ADD</code> 来向布隆过滤器添加元素，使用 <code>BF.EXISTS</code> 来检查某个元素是否可能存在。</li></ul><h4 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap" aria-hidden="true">#</a> BitMap</h4><p>Bitmap，<strong>即位图，是一串连续的二进制数组（0 和 1）</strong>，可以通过偏移量（offset）定位元素。由于 bit 是计算机中最小的单位，使用它进行储存将<strong>非常节省空间</strong>，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。例如在一个系统中，不同的用户使用单调递增的用户 ID 表示。40 亿（$$2^{32}$$ = $$4<em>1024</em>1024*1024$$ ≈ 40 亿）用户只需要 512M 内存就能记住某种状态，例如用户是否已登录。</p><p>实际上，<strong>BitMap 不是真实的数据结构，而是针对 String 实现的一组位操作</strong>。</p><p>由于 STRING 是二进制安全的，并且其最大长度是 512 MB，所以 BitMap 能最大设置 $$2^{32}$$ 个不同的 bit。</p><p>【示例】判断用户是否登录</p><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p><p>只需要一个 key = login_status 表示存储用户登陆状态集合数据，将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。50000 万 用户只需要 6 MB 的空间。</p><p>假如我们要判断 ID = 10086 的用户的登陆情况：</p><p>第一步，执行以下指令，表示用户已登录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GETBIT login_status <span class="token number">10086</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步，登出，将 offset 对应的 value 设置成 0。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="redisbloom" tabindex="-1"><a class="header-anchor" href="#redisbloom" aria-hidden="true">#</a> RedisBloom</h4><p>RedisBloom 是 Redis 官方提供的模块，是一种简化的布隆过滤器实现。它提供了<strong>更高性能</strong>和<strong>更低误判率</strong>控制。</p><p><strong>RedisBloom 常用命令</strong></p><ul><li><code>BF.RESERVE key error_rate capacity</code>：创建布隆过滤器（指定误判率、容量）</li><li><code>BF.ADD key item</code>：添加元素</li><li><code>BF.EXISTS key item</code>：检查元素是否存在（可能误判）</li><li><strong>自动扩容</strong>：可动态调整数据结构以适应数据增长</li></ul><p><strong>RedisBloom 操作示例</strong></p><p><strong>创建</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BF.RESERVE myBloomFilter <span class="token number">0.01</span> <span class="token number">1000000</span>  <span class="token comment"># 误判率 1%，容量 100 万</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>添加元素</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BF.ADD myBloomFilter <span class="token string">&quot;item1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>检查元素</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BF.EXISTS myBloomFilter <span class="token string">&quot;item1&quot;</span>  <span class="token comment"># 返回 1（可能存在）</span>
BF.EXISTS myBloomFilter <span class="token string">&quot;item2&quot;</span>  <span class="token comment"># 返回 0（一定不存在）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>适用场景</strong></p><p>RedisBloom 适合<strong>海量数据判断</strong>，且<strong>允许误判</strong>的场景：</p><ol><li><strong>爬虫</strong>：URL 去重</li><li><strong>黑名单</strong>：反垃圾邮件（可能误杀）</li><li><strong>分布式系统</strong>：优化数据查找（如 Hadoop、Cassandra）</li><li><strong>推荐系统</strong>：避免重复推荐</li></ol><p><strong>核心特点</strong></p><ul><li><strong>空间高效</strong>：节省存储空间</li><li><strong>快速查询</strong>：O(1) 时间复杂度</li><li><strong>误判率可控</strong>：通过参数调整</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,119),T={href:"https://juejin.im/post/5ad6e4066fb9a028d82c4b66",target:"_blank",rel:"noopener noreferrer"},B={href:"https://github.com/doocs/advanced-java#%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"},N={href:"https://xiaolincoding.com/redis/base/redis_interview.html",target:"_blank",rel:"noopener noreferrer"};function O(G,L){const s=o("ExternalLinkIcon");return i(),l("div",null,[c,t("blockquote",null,[t("p",null,[p,e("："),t("a",u,[e("What Redis data structures look like"),n(s)])])]),g,t("blockquote",null,[t("p",null,[h,e("；"),t("a",b,[e("Redis String 类型官方命令文档"),n(s)])])]),m,t("blockquote",null,[t("p",null,[v,e("；"),t("a",k,[e("Redis Hash 类型官方命令文档"),n(s)])])]),f,t("blockquote",null,[t("p",null,[R,e("；"),t("a",y,[e("Redis List 类型官方命令文档"),n(s)])])]),x,t("blockquote",null,[t("p",null,[E,e("；"),t("a",S,[e("Redis Set 类型官方命令文档"),n(s)])])]),_,t("blockquote",null,[t("p",null,[I,e("；"),t("a",D,[e("Redis ZSet 类型官方命令文档"),n(s)])])]),q,t("ul",null,[t("li",null,[t("a",T,[e("面试中关于 Redis 的问题看这篇就够了"),n(s)])]),t("li",null,[t("a",B,[e("advanced-java"),n(s)])]),t("li",null,[t("a",N,[e("Redis 常见面试题"),n(s)])])])])}const Z=a(r,[["render",O],["__file","index.html.vue"]]);export{Z as default};
