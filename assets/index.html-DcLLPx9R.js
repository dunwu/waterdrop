import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as r}from"./app-W6ac-OwH.js";const n={};function c(o,e){return r(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="字典树" tabindex="-1"><a class="header-anchor" href="#字典树"><span>字典树</span></a></h1><h2 id="什么是字典树" tabindex="-1"><a class="header-anchor" href="#什么是字典树"><span>什么是字典树</span></a></h2><p>Trie 树（又叫“前缀树”或“字典树”）是一种用于快速查询“某个字符串/字符前缀”是否存在的数据结构。</p><ul><li>根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；</li><li>从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；</li><li>任意节点的所有子节点所包含的字符都不相同；</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/8fd65539c45f4262bf46cb458446d4a6.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="字典树的构造" tabindex="-1"><a class="header-anchor" href="#字典树的构造"><span>字典树的构造</span></a></h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/70f8c5b68d2d4b09b3e82fc2e76e7c52.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/0ffcfdae0fbf441fb8ee25972bdefa1f.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。</p><p><strong>字典树非常耗费内存</strong>。</p><p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><h3 id="字典树的查找" tabindex="-1"><a class="header-anchor" href="#字典树的查找"><span>字典树的查找</span></a></h3><ol><li>每次从根结点开始搜索；</li><li>获取关键词的第一个字符，根据该字符选择对应的子节点，转到该子节点继续检索；</li><li>在相应的子节点上，获取关键词的第二个字符，进一步选择对应的子节点进行检索；</li><li>以此类推，进行迭代过程；</li><li>在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，查找完成。</li></ol><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/2e8b777aef4f4ed3a5f16667ebe73eb2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p><h2 id="字典树的应用场景" tabindex="-1"><a class="header-anchor" href="#字典树的应用场景"><span>字典树的应用场景</span></a></h2><p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p><p>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p><p>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p><p>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p><p>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p><p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p><p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p><p>（1）自动补全</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/cb8e349e280a48b1bfe24af2316842a2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）拼写检查</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/63f63c9cb62a49aaac1608043c02e156.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）IP 路由 (最长前缀匹配)</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/304cf4ed54304b71b450888f736dada1.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图 3. 使用 Trie 树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</p><p>（4）T9 (九宫格) 打字预测</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/00820cd854d94271936b0b12939a1de9.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（5）单词游戏</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/ee86be5a8a1b48579794e9e6bf697ea9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Trie 树可通过剪枝搜索空间来高效解决 Boggle 单词游戏</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://time.geekbang.org/column/intro/100017301" target="_blank" rel="noopener noreferrer">数据结构与算法之美</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/</a></li></ul>',39)])])}const g=t(n,[["render",c]]),u=JSON.parse('{"path":"/pages/0b76f5e5/","title":"字典树","lang":"zh-CN","frontmatter":{"title":"字典树","date":"2022-03-13T22:37:27.000Z","order":5,"categories":["算法"],"tags":["数据结构","树","字典树"],"permalink":"/pages/0b76f5e5/","description":"字典树 什么是字典树 Trie 树（又叫“前缀树”或“字典树”）是一种用于快速查询“某个字符串/字符前缀”是否存在的数据结构。 根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符； 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串； 任意节点的所有子节点所包含的字符都不相同； 字典树的构造 构建 Trie 树的过程...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"字典树\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/8fd65539c45f4262bf46cb458446d4a6.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/70f8c5b68d2d4b09b3e82fc2e76e7c52.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/0ffcfdae0fbf441fb8ee25972bdefa1f.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/2e8b777aef4f4ed3a5f16667ebe73eb2.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/cb8e349e280a48b1bfe24af2316842a2.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/63f63c9cb62a49aaac1608043c02e156.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/304cf4ed54304b71b450888f736dada1.gif\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/00820cd854d94271936b0b12939a1de9.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2020/03/ee86be5a8a1b48579794e9e6bf697ea9.png\\"],\\"datePublished\\":\\"2022-03-13T22:37:27.000Z\\",\\"dateModified\\":\\"2026-02-11T15:41:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/0b76f5e5/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"字典树"}],["meta",{"property":"og:description","content":"字典树 什么是字典树 Trie 树（又叫“前缀树”或“字典树”）是一种用于快速查询“某个字符串/字符前缀”是否存在的数据结构。 根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符； 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串； 任意节点的所有子节点所包含的字符都不相同； 字典树的构造 构建 Trie 树的过程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/8fd65539c45f4262bf46cb458446d4a6.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-11T15:41:54.000Z"}],["meta",{"property":"article:tag","content":"字典树"}],["meta",{"property":"article:tag","content":"树"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2022-03-13T22:37:27.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-11T15:41:54.000Z"}]]},"git":{"createdTime":1651071272000,"updatedTime":1770824514000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":11,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":4.3,"words":1291},"filePathRelative":"11.算法/字典树.md","excerpt":"\\n<h2>什么是字典树</h2>\\n<p>Trie 树（又叫“前缀树”或“字典树”）是一种用于快速查询“某个字符串/字符前缀”是否存在的数据结构。</p>\\n<ul>\\n<li>根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；</li>\\n<li>从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；</li>\\n<li>任意节点的所有子节点所包含的字符都不相同；</li>\\n</ul>\\n<figure><img src=\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/03/8fd65539c45f4262bf46cb458446d4a6.jpg\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>","autoDesc":true}');export{g as comp,u as data};
