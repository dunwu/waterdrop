import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as l,c as a,a as e,b as o,d as s,e as i}from"./app-e7b0ac47.js";const d={},c=i(`<h1 id="mysql-面试之索引篇" tabindex="-1"><a class="header-anchor" href="#mysql-面试之索引篇" aria-hidden="true">#</a> MySQL 面试之索引篇</h1><h2 id="综合" tabindex="-1"><a class="header-anchor" href="#综合" aria-hidden="true">#</a> 综合</h2><h3 id="【简单】什么是索引-为什么要使用索引" tabindex="-1"><a class="header-anchor" href="#【简单】什么是索引-为什么要使用索引" aria-hidden="true">#</a> 【简单】什么是索引？为什么要使用索引？</h3><p><strong>“索引”是数据库为了提高查找效率的一种数据结构</strong>。</p><p>日常生活中，我们可以通过检索目录，来快速定位书本中的内容。索引和数据表，就好比目录和书，想要高效查询数据表，索引至关重要。在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，<strong>设置合理的索引是数据库查询性能优化的最有效手段</strong>。</p><h3 id="【简单】索引的优点和缺点是什么" tabindex="-1"><a class="header-anchor" href="#【简单】索引的优点和缺点是什么" aria-hidden="true">#</a> 【简单】索引的优点和缺点是什么？</h3><p>✅️️️️️️️ 索引的优点：</p><ul><li><strong>索引大大减少了服务器需要扫描的数据量</strong>，从而加快检索速度。</li><li><strong>索引可以帮助服务器避免排序和临时表</strong>。</li><li><strong>索引可以将随机 I/O 变为顺序 I/O</strong>。</li><li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。<strong>使用索引可以减少访问的行数，从而减少锁的竞争，提高并发</strong>。</li><li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li></ul><p>❌ 索引的缺点：</p><ul><li><strong>创建和维护索引要耗费时间</strong>，这会随着数据量的增加而增加。</li><li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立联合索引那么需要的空间就会更大。</li><li><strong>写操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低</strong>。</li></ul><h3 id="【中等】何时适用索引-何时不适用索引" tabindex="-1"><a class="header-anchor" href="#【中等】何时适用索引-何时不适用索引" aria-hidden="true">#</a> 【中等】何时适用索引？何时不适用索引？</h3><ul><li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li><li>要<strong>考虑删除未使用的索引</strong>。</li><li><strong>尽量的扩展索引，不要新建索引</strong>。索引需要占用额外的存储空间；此外，表更新时，需要同步维护索引。索引越多，意味着维护所付出的成本越高，因此，应尽量扩展已有索引，而不是不假思索的新建索引。</li></ul><blockquote><p>✅️️️️ 什么情况<strong>适用</strong>索引？</p></blockquote><ul><li><strong>高频查询的字段</strong>：频繁作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，应考虑设为索引。</li><li><strong>频繁用于 <code>ORDER BY</code>、<code>GROUP BY</code>、<code>DISTINCT</code> 的列</strong>。将该列作为索引，可以帮助加快这些操作。</li></ul><blockquote><p>❌ 什么情况<strong>不适用</strong>索引？</p></blockquote><ul><li><strong>非常小的表</strong>：对于非常小的表，大部分情况下简单的全表扫描更高效。</li><li><strong>特大型的表</strong>：建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li><li><strong>高频更新的表</strong>：表更新时，需要同步维护索引，有额外的开销，会影响性能。</li><li><strong>低频查询的字段</strong>：很少作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，建立索引而带来的空间开销和维护成本可能超过查询性能提升所带来的收益。</li><li><strong>高度重复的字段</strong>：若索引字段的重复度高，意味着选择性低（如性别字段只有男和女），索引的效果不明显，且会增加额外的存储空间。</li><li><strong>长文本的字段</strong>：如 TEXT、BLOB 或非常长的 VARCHAR 类型，字段常包含大量数据。 <ul><li>数据量大时，无法用内存排序，只能利用磁盘文件排序，速度很慢。</li><li>数据页默认 16KB，存储数据有限，超出范围，需要扫描多次 I/O。</li><li>这种类型的数据如果有查询需求，应考虑使用 ES 来进行全文检索。</li></ul></li></ul><h3 id="【中等】哪些情况下-索引会失效" tabindex="-1"><a class="header-anchor" href="#【中等】哪些情况下-索引会失效" aria-hidden="true">#</a> 【中等】哪些情况下，索引会失效？</h3><p>导致索引失效的情况有：</p><ul><li><strong>违反最左前缀原则</strong><ul><li>❌跳过了最左列（如索引 <code>(a,b,c)</code>，但查询 <code>WHERE b=1</code>）</li><li>❌中间列被跳过（如 <code>WHERE a=1 AND c=3</code>，<code>c</code> 无法使用索引）</li></ul></li><li><strong>对索引使用函数或计算</strong><ul><li>❌ <code>WHERE YEAR(date_column) = 2023</code></li><li>❌ <code>WHERE column * 2 = 10</code></li><li>❌ <code>WHERE SUBSTRING(name, 1, 3) = &#39;Tom&#39;</code></li></ul></li><li><strong>数据类型不匹配（隐式类型转换）</strong><ul><li>❌ <code>WHERE string_column = 123</code>（字符串列用数字比较）</li><li>❌ <code>WHERE int_column = &#39;123&#39;</code>（数字列用字符串比较）</li></ul></li><li><strong>使用 <code>OR</code> 连接非索引列</strong><ul><li>❌ <code>WHERE a=1 OR b=2</code>（如果 <code>b</code> 无索引，全表扫描）</li><li>✅ <code>WHERE a=1 OR a=2</code>（<code>a</code> 有索引，可以优化）</li></ul></li><li><strong>使用范围查询（&gt;、&lt;、BETWEEN、LIKE）后的列失效</strong><ul><li>✅ <code>WHERE a=1 AND b=2</code>（<code>a, b</code> 都能用索引）</li><li>❌ <code>WHERE a&gt;1 AND b=2</code>（<code>a</code> 是范围查询，<code>b</code> 无法用索引）</li><li>❌ <code>WHERE name LIKE &#39;%abc&#39;</code>（前导通配符 <code>%</code> 导致索引失效）</li></ul></li><li><strong>使用 <code>!=</code>、<code>&lt;&gt;</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code></strong><ul><li>❌ <code>WHERE status != &#39;active&#39;</code></li><li>❌ <code>WHERE age NOT IN (18, 20)</code></li><li>❌ <code>WHERE phone IS NULL</code></li></ul></li></ul><h3 id="【简单】索引有哪些分类" tabindex="-1"><a class="header-anchor" href="#【简单】索引有哪些分类" aria-hidden="true">#</a> 【简单】索引有哪些分类？</h3><p>MySQL 索引可以从以下四个维度来分类：</p><ul><li>按【<strong>数据结构</strong>】分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong></li><li>按【<strong>物理存储</strong>】分类：<strong>聚簇索引、二级索引（辅助索引）</strong></li><li>按【<strong>字段特性</strong>】分类：<strong>主键索引、普通索引、前缀索引</strong></li><li>按【<strong>字段个数</strong>】分类：<strong>单列索引、联合索引（复合索引、组合索引）</strong></li></ul><h3 id="【简单】-和-in-的顺序对于命中索引是否有影响" tabindex="-1"><a class="header-anchor" href="#【简单】-和-in-的顺序对于命中索引是否有影响" aria-hidden="true">#</a> 【简单】= 和 in 的顺序对于命中索引是否有影响？</h3><p><strong>不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</strong>，MySQL 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p><p>【示例】如有索引 (a, b, c, d)，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL 会自动优化为 a = 1 and b = 2 and c &gt; 3 and d &lt; 4，依次命中 a、b、c、d。</p><h2 id="索引数据结构" tabindex="-1"><a class="header-anchor" href="#索引数据结构" aria-hidden="true">#</a> 索引数据结构</h2><h3 id="【简单】索引有哪些常见数据结构" tabindex="-1"><a class="header-anchor" href="#【简单】索引有哪些常见数据结构" aria-hidden="true">#</a> 【简单】索引有哪些常见数据结构？</h3><p>在 MySQL 中，<strong>索引是在存储引擎层而不是服务器层实现的</strong>，所以，并没有统一的索引标准。不同存储引擎的索引的数据结构也不相同。下面是 MySQL 常用存储引擎对一些主要索引数据结构的支持：</p><table><thead><tr><th>索引数据结构/存储引擎</th><th>InnoDB 引擎</th><th>MyISAM 引擎</th><th>Memory 引擎</th></tr></thead><tbody><tr><td><strong>B+ 树索引</strong></td><td>✅️️️️️️️</td><td>✅️️️️️️️</td><td>✅️️️️️️️</td></tr><tr><td><strong>Hash 索引</strong></td><td>❌</td><td>❌</td><td>✅️️️️️️️</td></tr><tr><td><strong>Full Text 索引</strong></td><td>✅️️️️️️️</td><td>✅️️️️️️️</td><td>❌</td></tr></tbody></table><p>MySQL 索引的常见数据结构：</p><ul><li><strong>哈希索引</strong><ul><li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li><li><strong>只支持等值比较查询</strong> - 包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；<strong>不支持任何范围查询</strong>，如 <code>WHERE price &gt; 100</code>。</li><li><strong>无法用于排序</strong> - 因为哈希索引数据不是按照索引值顺序存储的。</li><li><strong>不支持部分索引匹配查找</strong> - 因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li><li><strong>不能用索引中的值来避免读取行</strong> - 因为哈希索引只包含哈希值和行指针，不存储字段，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li><li>哈希索引有<strong>可能出现哈希冲突</strong><ul><li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li><li>如果哈希冲突多的话，维护索引的代价会很高。</li></ul></li></ul></li><li>B 树索引 <ul><li>适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</li><li>所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li><li>所有的叶子节点由指针连接。</li></ul></li></ul><h3 id="【中等】为什么-innodb-采用-b-树索引" tabindex="-1"><a class="header-anchor" href="#【中等】为什么-innodb-采用-b-树索引" aria-hidden="true">#</a> 【中等】为什么 InnoDB 采用 B+ 树索引？</h3><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 $$O(log(N))$$。</p><p>当然为了维持 $$O(log(N))$$ 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 $$O(log(N))$$。</p><p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I/O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I/O 存取次数？</p><p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p><p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p><p>理解 B+Tree 时，只需要理解其最重要的两个特征即可：</p><ul><li>首先，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li><li>其次，所有的叶子节点由指针连接。如下图为简化了的 B+Tree。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200304235424.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>B+ 树 vs B 树</p></blockquote><ul><li>B+ 树只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以 B+ 树的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</li><li>另外，B+ 树叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</li></ul><blockquote><p>B+ 树 vs 二叉树</p></blockquote><ul><li>对于有 N 个叶子节点的 B+ 树，其搜索复杂度为 <code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</li><li>在实际的应用当中， d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+ 树的高度依然维持在 1~3 层左右，也就是说一次数据查询操作只需要做 1~3 次的磁盘 I/O 操作就能查询到目标数据。</li><li>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+ 树高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</li></ul><p>一言以蔽之，使用 B+ 树，而不是二叉树，是为了减少树的高度，也就是为了减少磁盘 I/O 次数。</p><blockquote><p>B+ 树索引和 Hash 索引的差异</p></blockquote><ul><li><strong>B+ 树索引支持范围查询</strong>；Hash 索引不支持。</li><li><strong>B+ 树索引支持联合索引的最左匹配原则</strong>；Hash 索引不支持。</li><li><strong>B+ 树索引支持排序</strong>；Hash 索引不支持。</li><li><strong>B+ 树索引支持模糊查询</strong>；Hash 索引不支持。</li><li>Hash 索引的等值查询比 B+ 树索引效率高。</li></ul><p>综上，Hash 索引的应用场景很苛刻，不适用于绝大多数场景。</p><h3 id="【中等】b-树索引能存多少数据" tabindex="-1"><a class="header-anchor" href="#【中等】b-树索引能存多少数据" aria-hidden="true">#</a> 【中等】B+ 树索引能存多少数据？</h3><p>在 InnoDB 存储引擎中，B+ 树默认数据页大小为 <strong>16KB</strong>。</p><p>所有 B+ 树都是从高度为 1 的树开始，然后根据数据的插入，慢慢增加树的高度。随着插入 B+ 树索引的记录变多，1 个页（16K）无法存放这么多数据，所以会发生 B+ 树的分裂，B+ 树的高度变为 2。</p><blockquote><p>非叶子节点可存储的记录数</p></blockquote><p>根节点和中间节点存放的是索引键对，由（索引键、指针）组成。</p><p>索引键就是排序的列，而指针是指向下一层的地址，在 MySQL 的 InnoDB 存储引擎中占用 6 个字节。若主键是 BIGINT 类型，占 8 个字节。也即是说，这样的一个键值对需要 <code>8+6 = 14</code> 字节。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>非叶子节点可存储的记录数 = 页大小（16K） / 键值对大小（14） ≈ 1100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>叶子节点可存储的记录数</p></blockquote><p>为了方便计算，假设数据记录的平均大小为 1000 字节（实际一般小于这个值），则</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>叶子节点可存储的记录数 = 页大小（16K） / 记录平均大小（1000） ≈ 16
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由此可知，树高度为 2 的 B+ 树索引，有一个根节点，约 1100 个叶子节点。因此，最多能存放的记录数为：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code>二层 B+ 树记录数 ≈ 171100 * 16 =  17<span class="token punctuation">,</span><span class="token number">600</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>如何推算不同高度的 B+ 树可存储的记录数</p></blockquote><p>综上所述，数据记录的平均大小为 1000 字节，主键为 <code>BIGINT</code> 的表，可以按如下推算其可存储的记录数：</p><ul><li>高度为 2 的 B+树索引最多能存放约 <code>1100 * 16 = 17,600</code> 条记录（约 1.76 万），查询时只需 2 次 I/O。</li><li>高度为 3 的 B+树索引最多能存放约 <code>1100 * 1100 * 16 = 19,360,000</code> 条记录（约 2 千万），查询时只需 3 次 I/O。</li><li>高度为 4 的 B+树索引最多能存放约 <code>1100 * 1100 * 1100 * 16 = 21,296,000,000</code> 条记录（约 200 多亿），查询时只需 4 次 I/O。</li></ul><p>优化 B+ 树索引的插入性能：</p><ul><li>顺序插入（如自增 ID 或时间列）的维护代价小，性能较好。</li><li>无序插入（如用户昵称）会导致页分裂、旋转等开销较大的操作，影响性能。</li><li>主键设计应尽量使用顺序值（如自增 ID），以保证高并发场景下的性能。</li></ul><h2 id="聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引" aria-hidden="true">#</a> 聚簇索引和非聚簇索引</h2><h3 id="【中等】聚簇索引和非聚簇索引有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】聚簇索引和非聚簇索引有什么区别" aria-hidden="true">#</a> 【中等】聚簇索引和非聚簇索引有什么区别？</h3><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引又被称为<strong>聚簇索引（clustered index），其叶子节点存的是整行数据</strong>。</p><ul><li>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快。</li><li>因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</li><li>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行。</li></ul><p>非主键索引又被称为<strong>二级索引（secondary index），其叶子节点存的是主键的值</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</p><ul><li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索主键索引树；</li><li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503221604600.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p><p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p><h3 id="【简单】什么是覆盖索引" tabindex="-1"><a class="header-anchor" href="#【简单】什么是覆盖索引" aria-hidden="true">#</a> 【简单】什么是覆盖索引？</h3><p><strong>覆盖索引是指：二级索引上的信息满足查询所需的所有字段，不需要回表查询聚簇索引上的数据</strong>。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p><h2 id="字段特性索引" tabindex="-1"><a class="header-anchor" href="#字段特性索引" aria-hidden="true">#</a> 字段特性索引</h2><h3 id="【简单】auto-increment-列达到最大值时会发生什么" tabindex="-1"><a class="header-anchor" href="#【简单】auto-increment-列达到最大值时会发生什么" aria-hidden="true">#</a> 【简单】AUTO_INCREMENT 列达到最大值时会发生什么？</h3><blockquote><p>配置主键</p></blockquote><p>在 MySQL 中，如果表定义的自增 ID 到达上限后，再申请下一个 ID，得到的值不变！因此会导致重复值的错误。</p><blockquote><p>没有配置主键</p></blockquote><p>如果 InnoDB 表中没有配置主键，InnoDB 会自动创建一个不可见的、长度为 6 个字节的 row_id 作为默认主键。</p><p>InnoDB 在全局维护一个 <code>dict_sys.row_id</code> 值。每次插入一行数据时，都会获取当前的 <code>dict_sys.row_id</code> 值，并将其加 1。<code>row_id</code> 的范围是 <code>0</code> 到 <code>2^48 - 1</code>。当 <code>row_id</code> 达到上限后，会从 <code>0</code> 开始重新循环。</p><p>如果插入的新数据的 <code>row_id</code> 在表中已存在，老数据会被新数据覆盖，且不会产生任何报错。可以通过 <code>gdb</code> 动态修改 <code>dict_sys.row_id</code> 来验证这一行为。</p><h3 id="【简单】普通键和唯一键-应该怎么选择" tabindex="-1"><a class="header-anchor" href="#【简单】普通键和唯一键-应该怎么选择" aria-hidden="true">#</a> 【简单】普通键和唯一键，应该怎么选择？</h3><p>唯一索引的主要作用是保证数据的唯一性，而普通索引则更灵活。在业务代码保证不会写入重复数据的情况下，普通索引和唯一索引在查询性能上几乎没有差别。</p><p><strong>普通索引</strong> 在更新操作中性能更优，尤其是在写多读少的场景下，能够利用 change buffer 减少磁盘 I/O。</p><p><strong>唯一索引</strong> 适用于需要保证数据唯一性的场景，但在更新操作中性能较差，因为它无法使用 change buffer。</p><p>在业务允许的情况下，<strong>优先选择普通索引</strong>，因为它可以利用 change buffer 来提升更新性能。如果业务要求必须保证数据的唯一性，则必须使用唯一索引。</p><p><strong>查询过程的性能差异</strong>：对于查询操作，普通索引和唯一索引的性能差异微乎其微。唯一索引在找到第一个满足条件的记录后会停止检索，而普通索引需要继续查找下一个记录，但由于数据页的读取方式，这种差异可以忽略不计。</p><p><strong>更新过程的性能差异</strong>：更新操作中，普通索引可以利用 <strong>change buffer</strong> 来优化性能，而唯一索引则不能使用 change buffer。</p><ul><li><strong>change buffer</strong> 是一种将更新操作缓存在内存中的机制，减少了对磁盘的随机读取，从而提升了更新操作的性能。</li><li>唯一索引在更新时需要检查唯一性约束，必须将数据页读入内存，增加了磁盘 I/O 的开销。</li></ul><p><strong>change buffer 的应用</strong></p><ul><li>change buffer 的数据是持久化的，即使机器掉电重启，change buffer 中的数据也不会丢失，因为它会被写入磁盘。</li><li>change buffer 适用于写多读少的场景，如账单类、日志类系统，因为这些场景下数据页在写入后不会立即被访问，change buffer 可以显著减少磁盘 I/O。</li><li>对于写后立即查询的场景，change buffer 的效果不明显，甚至可能增加维护成本。</li></ul><p><strong>change buffer vs. redo log</strong></p><ul><li><strong>redo log</strong> 主要减少随机写磁盘的 I/O 消耗，将随机写转换为顺序写。</li><li><strong>change buffer</strong> 主要减少随机读磁盘的 I/O 消耗，通过缓存更新操作来减少磁盘读取。</li></ul><h3 id="【中等】为什么不推荐使用外键" tabindex="-1"><a class="header-anchor" href="#【中等】为什么不推荐使用外键" aria-hidden="true">#</a> 【中等】为什么不推荐使用外键？</h3><p><strong>逻辑外键</strong>是一种在应用程序层面上管理和维护数据完整性的方法，而不是通过数据库本身的外键约束。主要是利用应用程序代码来保证引用的完整性。</p><p>逻辑外键的优缺点：</p><p><strong>优点</strong>：</p><ul><li><strong>灵活性高</strong>：应用程序层面控制，可以更灵活地实现复杂的业务逻辑。</li><li><strong>性能优化</strong>：避免了数据库层面的约束检查，可以在某些情况下提高性能（详细看扩展知识）。</li><li><strong>跨数据库兼容性</strong>：逻辑外键在不同类型的数据之间更容易迁移。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>代码复杂性增加</strong>：需要在应用程序代码中手动实现和维护引用完整性，增加了代码的复杂性和错误的可能性。</li><li><strong>一致性风险</strong>：如果应用程序代码未正确实现引用完整性检查，可能导致数据不一致。</li><li><strong>维护成本高</strong>：逻辑外键需要开发人员持续关注和维护，增加了维护成本。</li></ul><p>物理外键的优缺点：</p><p><strong>优点</strong>：</p><ul><li><strong>自动维护引用完整性</strong>：数据库会自动检查和维护外键约束，确保数据的一致性。</li><li><strong>减少应用层复杂性</strong>：开发人员不需要手动管理引用完整性，减少了代码的复杂性和错误的可能性。</li><li><strong>数据完整性保障</strong>：数据库层面的约束能够更有效地防止非法数据的插入或更新。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>性能开销</strong>：外键约束会增加插入、更新和删除操作的开销，特别是在处理大量数据时。</li><li><strong>迁移和复制的复杂性</strong>：在进行数据库迁移或复制时，外键约束可能会增加复杂性，需要小心处理。</li><li><strong>灵活性较低</strong>：物理外键在某些复杂业务逻辑下可能不够灵活，需要更多的手动控制。</li></ul><h3 id="【中等】什么是前缀索引" tabindex="-1"><a class="header-anchor" href="#【中等】什么是前缀索引" aria-hidden="true">#</a> 【中等】什么是前缀索引？</h3><p><strong>“前缀索引”是指索引开始的部分字符</strong>。对于 <code>BLOB</code>/<code>TEXT</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p><p>前缀索引的优点是可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。</p><p>前缀索引的缺点是<strong>会降低索引的区分度</strong>。此外，<strong><code>order by</code> 无法使用前缀索引，无法把前缀索引用作覆盖索引</strong>。</p><h2 id="字段个数索引" tabindex="-1"><a class="header-anchor" href="#字段个数索引" aria-hidden="true">#</a> 字段个数索引</h2><h3 id="【中等】什么是索引最左匹配原则" tabindex="-1"><a class="header-anchor" href="#【中等】什么是索引最左匹配原则" aria-hidden="true">#</a> 【中等】什么是索引最左匹配原则？</h3><p>使用联合索引时，查询条件必须从索引的最左列开始匹配。</p><p>其底层原理是，InnoDB 的索引采用 B+ 树数据结构，按字段顺序存储。其存储结构，决定了其查询时，必须遵循从左到右的顺序。</p><p>具体来说，最左匹配原则有以下几个要点：</p><blockquote><p>为方便直观的阐述，这里假设有一张表 t，设置了联合索引 <code>(a, b, c)</code>。</p></blockquote><ul><li><strong>必须包含最左列</strong>：如果查询条件中不包含最左列，则联合索引失效。即查询条件必须包含 <code>a</code> 才能使用索引。 <ul><li>✅ <code>WHERE a=1</code>（能用索引）。</li><li>❌ <code>WHERE b=2</code>（不能使用索引，因为跳过了 <code>a</code>）。</li></ul></li><li><strong>连续匹配</strong>：不能跳过中间列，否则后面的列无法索引。 <ul><li>✅ <code>WHERE a=1 AND b=2</code>（能使用 <code>a, b</code> 两列索引）。</li><li>❌ <code>WHERE a=1 AND c=3</code>（只能用到 <code>a</code>，<code>c</code> 无法索引，因为跳过了 <code>b</code>）。值得一提的是，MySQL 5.6 支持了<strong>索引下推</strong>（InnoDB 和 MyISAM 支持），允许这种情况下，将匹配 a 字段的数据推送到引擎层，由引擎层在这些数据中过滤出匹配 c 字段的数据，以此提升查询效率。</li></ul></li><li><strong>遇到范围查询，右侧失效</strong>： <ul><li>遇到 <code>&gt;</code>、<code>&lt;</code>、前缀 <code>LIKE</code>（%xx） 会停止匹配</li><li>注意：若遇到 &gt;=、&lt;=、<code>BETWEEN</code>、后缀 <code>LIKE</code>（xx%）这种范围查询，不会停止匹配，因为这些查询包含一个等值判断，可以直接定位到某个数据，向后扫描</li></ul></li></ul><p><strong>最左前缀匹配命中示例</strong></p><p>假设有索引 <code>(name, age, city)</code>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>✅ <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">&#39;Alice&#39;</span> <span class="token operator">AND</span> age<span class="token operator">=</span><span class="token number">25</span> <span class="token operator">AND</span> city<span class="token operator">=</span><span class="token string">&#39;Beijing&#39;</span>  <span class="token comment">-- 完整使用索引</span>
✅ <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">&#39;Alice&#39;</span> <span class="token operator">AND</span> age<span class="token operator">=</span><span class="token number">25</span>                     <span class="token comment">-- 使用 name 和 age</span>
✅ <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">&#39;Alice&#39;</span>                               <span class="token comment">-- 仅使用 name</span>
❌ <span class="token keyword">WHERE</span> age<span class="token operator">=</span><span class="token number">25</span> <span class="token operator">AND</span> city<span class="token operator">=</span><span class="token string">&#39;Beijing&#39;</span>                  <span class="token comment">-- 跳过了 name，无法使用索引</span>
❌ <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">&#39;Alice&#39;</span> <span class="token operator">AND</span> city<span class="token operator">=</span><span class="token string">&#39;Beijing&#39;</span>            <span class="token comment">-- 只能用到 name，跳过了 age，但可以应用索引下推</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上，优化 SQL 时，应尽量让查询条件符合最左前缀匹配原则，以提高查询效率。</p><h3 id="【中等】什么是索引下推" tabindex="-1"><a class="header-anchor" href="#【中等】什么是索引下推" aria-hidden="true">#</a> 【中等】什么是索引下推？</h3><p>索引下推是一种减少回表查询、提高查询效率的技术。索引下推主要应用于联合索引。</p><p>它允许 MySQL 在使用索引查找数据时，将部分查询条件下推到存储引擎层进行过滤，从而减少需要从表中读取的数据行，减少 IO 操作。</p><p>索引下推注意点：</p><ul><li>MySQL 5.6 及以后版本支持索引下推，适用于 InnoDB 和 MyISAM 存储引擎。</li><li>综上，包含子查询，索引下推可能不会生效。</li><li>使用函数或表达式时，索引下推不会生效。</li><li>使用聚簇索引（主键）查询时，索引下推不会生效，因为它主要针对非聚簇索引。</li></ul>`,130),g={href:"https://zhuanlan.zhihu.com/p/121084592",target:"_blank",rel:"noopener noreferrer"},p=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),o(" 参考资料")],-1),u={href:"https://book.douban.com/subject/23008813/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://time.geekbang.org/column/intro/139",target:"_blank",rel:"noopener noreferrer"},b={href:"https://xiaolincoding.com/mysql/",target:"_blank",rel:"noopener noreferrer"};function m(E,f){const n=r("ExternalLinkIcon");return l(),a("div",null,[c,e("blockquote",null,[e("p",null,[o("扩展阅读："),e("a",g,[o("https://zhuanlan.zhihu.com/p/121084592"),s(n)])])]),p,e("ul",null,[e("li",null,[e("a",u,[o("《高性能 MySQL》"),s(n)])]),e("li",null,[e("a",h,[o("极客时间教程 - MySQL 实战 45 讲"),s(n)])]),e("li",null,[e("a",b,[o("图解 MySQL 介绍"),s(n)])])])])}const I=t(d,[["render",m],["__file","index.html.vue"]]);export{I as default};
