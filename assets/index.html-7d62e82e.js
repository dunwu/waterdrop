const e=JSON.parse('{"key":"v-1dae798c","path":"/pages/96684ccf/","title":"Java 并发面试二","lang":"zh-CN","frontmatter":{"title":"Java 并发面试二","date":"2024-07-23T07:21:03.000Z","order":8,"permalink":"/pages/96684ccf/","category":["Java","JavaCore","面试"],"tag":["Java","JavaCore","面试","并发"],"description":"Java 并发面试二 Java 锁 【中等】Java 中，根据不同维度划分，锁有哪些分类？ 在 Java 中，锁可以按照 多个维度 进行分类，不同维度的锁适用于不同的并发场景。以下是详细的分类： 按锁的公平性划分 锁类型 特点 实现类/关键字 公平锁 严格按照线程请求顺序（FIFO）分配锁，避免线程饥饿，但性能较低。 ReentrantLock(true) 非公平锁 允许插队，新请求的线程可能直接抢到锁，吞吐量高，但可能导致线程饥饿（默认方式）。 ReentrantLock(false)、synchronized","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/96684ccf/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 并发面试二"}],["meta",{"property":"og:description","content":"Java 并发面试二 Java 锁 【中等】Java 中，根据不同维度划分，锁有哪些分类？ 在 Java 中，锁可以按照 多个维度 进行分类，不同维度的锁适用于不同的并发场景。以下是详细的分类： 按锁的公平性划分 锁类型 特点 实现类/关键字 公平锁 严格按照线程请求顺序（FIFO）分配锁，避免线程饥饿，但性能较低。 ReentrantLock(true) 非公平锁 允许插队，新请求的线程可能直接抢到锁，吞吐量高，但可能导致线程饥饿（默认方式）。 ReentrantLock(false)、synchronized"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-27T02:43:58.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2024-07-23T07:21:03.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-27T02:43:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 并发面试二\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-23T07:21:03.000Z\\",\\"dateModified\\":\\"2025-12-27T02:43:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"Java 锁","slug":"java-锁","link":"#java-锁","children":[{"level":3,"title":"【中等】Java 中，根据不同维度划分，锁有哪些分类？","slug":"【中等】java-中-根据不同维度划分-锁有哪些分类","link":"#【中等】java-中-根据不同维度划分-锁有哪些分类","children":[]},{"level":3,"title":"【中等】悲观锁和乐观锁有什么区别？","slug":"【中等】悲观锁和乐观锁有什么区别","link":"#【中等】悲观锁和乐观锁有什么区别","children":[]},{"level":3,"title":"【中等】公平锁和非公平锁有什么区别？","slug":"【中等】公平锁和非公平锁有什么区别","link":"#【中等】公平锁和非公平锁有什么区别","children":[]},{"level":3,"title":"【中等】synchronized 和 ReentrantLock 有什么区别？","slug":"【中等】synchronized-和-reentrantlock-有什么区别","link":"#【中等】synchronized-和-reentrantlock-有什么区别","children":[]},{"level":3,"title":"【困难】ReentrantLock 的实现原理是什么？","slug":"【困难】reentrantlock-的实现原理是什么","link":"#【困难】reentrantlock-的实现原理是什么","children":[]},{"level":3,"title":"【困难】AQS 的实现原理是什么？","slug":"【困难】aqs-的实现原理是什么","link":"#【困难】aqs-的实现原理是什么","children":[]},{"level":3,"title":"【困难】ReentrantReadWriteLock 的实现原理是什么？","slug":"【困难】reentrantreadwritelock-的实现原理是什么","link":"#【困难】reentrantreadwritelock-的实现原理是什么","children":[]},{"level":3,"title":"【困难】StampedLock 的实现原理是什么？","slug":"【困难】stampedlock-的实现原理是什么","link":"#【困难】stampedlock-的实现原理是什么","children":[]}]},{"level":2,"title":"Java 无锁","slug":"java-无锁","link":"#java-无锁","children":[{"level":3,"title":"【中等】什么是 CAS？CAS 的实现原理是什么？","slug":"【中等】什么是-cas-cas-的实现原理是什么","link":"#【中等】什么是-cas-cas-的实现原理是什么","children":[]},{"level":3,"title":"【中等】CAS 算法存在哪些问题？","slug":"【中等】cas-算法存在哪些问题","link":"#【中等】cas-算法存在哪些问题","children":[]},{"level":3,"title":"【中等】什么是 ThreadLocal？","slug":"【中等】什么是-threadlocal","link":"#【中等】什么是-threadlocal","children":[]},{"level":3,"title":"【中等】ThreadLocal 的原理是什么？","slug":"【中等】threadlocal-的原理是什么","link":"#【中等】threadlocal-的原理是什么","children":[]},{"level":3,"title":"【中等】如何解决 ThreadLocal 内存泄漏问题？","slug":"【中等】如何解决-threadlocal-内存泄漏问题","link":"#【中等】如何解决-threadlocal-内存泄漏问题","children":[]},{"level":3,"title":"【中等】InheritableThreadLocal 的实现原理是什么？","slug":"【中等】inheritablethreadlocal-的实现原理是什么","link":"#【中等】inheritablethreadlocal-的实现原理是什么","children":[]},{"level":3,"title":"【中等】Java 中支持哪些原子类？","slug":"【中等】java-中支持哪些原子类","link":"#【中等】java-中支持哪些原子类","children":[]}]}],"git":{"createdTime":1757980215000,"updatedTime":1766803438000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":2}]},"readingTime":{"minutes":31.91,"words":9572},"filePathRelative":"01.Java/JavaCore/面试/Java_面试_并发（二）.md","localizedDate":"2024年7月23日","excerpt":"<h1> Java 并发面试二</h1>\\n<h2> Java 锁</h2>\\n<h3> 【中等】Java 中，根据不同维度划分，锁有哪些分类？</h3>\\n<p>在 Java 中，锁可以按照 <strong>多个维度</strong> 进行分类，不同维度的锁适用于不同的并发场景。以下是详细的分类：</p>\\n<p><strong>按锁的公平性划分</strong></p>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>锁类型</strong></th>\\n<th><strong>特点</strong></th>\\n<th><strong>实现类/关键字</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><strong>公平锁</strong></td>\\n<td>严格按照线程请求顺序（FIFO）分配锁，避免线程饥饿，但性能较低。</td>\\n<td><code>ReentrantLock(true)</code></td>\\n</tr>\\n<tr>\\n<td><strong>非公平锁</strong></td>\\n<td>允许插队，新请求的线程可能直接抢到锁，吞吐量高，但可能导致线程饥饿（默认方式）。</td>\\n<td><code>ReentrantLock(false)</code>、<code>synchronized</code></td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{e as data};
