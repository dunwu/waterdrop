import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,a as e,d as k,w as t,r as p,o,b as i,e as s}from"./app-W6ac-OwH.js";const g={};function c(A,a){const h=p("Tabs");return o(),d("div",null,[a[6]||(a[6]=e(`<h1 id="mysql-面试" tabindex="-1"><a class="header-anchor" href="#mysql-面试"><span>MySQL 面试</span></a></h1><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener noreferrer">《高性能 MySQL》</a></li><li><a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener noreferrer">极客时间教程 - MySQL 实战 45 讲</a></li><li><a href="https://xiaolincoding.com/mysql/" target="_blank" rel="noopener noreferrer">图解 MySQL 介绍</a></li><li><a href="https://book.douban.com/subject/35167240/" target="_blank" rel="noopener noreferrer">《SQL 必知必会》</a> - SQL 的基本概念和语法【入门】</li><li><a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener noreferrer">《MySQL 必知必会》</a> - MySQL 的基本概念和语法【入门】</li></ul></div><h2 id="sql" tabindex="-1"><a class="header-anchor" href="#sql"><span>SQL</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://book.douban.com/subject/35167240/" target="_blank" rel="noopener noreferrer">《SQL 必知必会》</a> - SQL 的基本概念和语法【入门】</li><li><a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener noreferrer">《MySQL 必知必会》</a> - MySQL 的基本概念和语法【入门】</li></ul></div><h3 id="【简单】什么是范式-什么是反范式-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】什么是范式-什么是反范式-⭐"><span>【简单】什么是范式？什么是反范式？⭐</span></a></h3><p>数据库规范化，又称“<strong>范式</strong>”，是数据库设计的指导理论。<strong>范式的目标是：使数据库结构更合理，消除存储异常，使数据冗余尽量小，增进数据的一致性</strong>。</p><p>根据约束程度从低到高有：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）等等。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2024/10/5001644c5874419d983278ad9bdecc6d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>1NF 要求<strong>所有属性都不可再分解</strong>。</li><li>2NF 要求<strong>不存在部分依赖</strong>。</li><li>3NF 要求<strong>不存在传递依赖</strong>。</li></ul><p>反范式，顾名思义，与范式的目标正好相反。<strong>范式</strong>的目标是<strong>消除冗余</strong>；<strong>反范式</strong>的目标是<strong>冗余以提高查询效率</strong>。</p><p>范式并非越严格越好，现代数据库设计，一般最多满足 3NF。范式越高意味着表的划分更细，一个数据库中需要的表也就越多，用户不得不将原本相关联的数据分摊到多个表中。当用户同时需要这些数据时只能通过关联表的形式将数据重新合并在一起。同时把多个表联接在一起的花费是巨大的，尤其是当需要连接的两张或者多张表数据非常庞大的时候，表连接操作几乎是一个噩梦，这严重地降低了系统运行性能。因此，<strong>有时为了提高查询效率，有必要适当的冗余数据，以达到空间换时间的目的——这就是“反范式”</strong>。</p><div class="hint-container info"><p class="hint-container-title">第一范式（1NF）</p></div><p>1NF 要求<strong>所有属性都不可再分解</strong>。</p><div class="hint-container info"><p class="hint-container-title">第二范式（2NF）</p></div><p>2NF 要求记录有唯一标识，即实体的唯一性，即<strong>不存在部分依赖</strong>。</p><p>假设有一张 student 表，结构如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 学生表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">student（学号、课程号、姓名、学分、成绩）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>举例来说，现有一张 student 表，具有学号、课程号、姓名、学分等字段。从中可以看出，表中包含了学生信息和课程信息。由于非主键字段必须依赖主键，这里学分依赖课程号，姓名依赖学号，所以不符合 2NF。</p><p>不符合 2NF 可能会存在的问题：</p><ul><li><strong>数据冗余</strong>：每条记录都含有相同信息。</li><li><strong>删除异常</strong>：删除所有学生成绩，就把课程信息全删除了。</li><li><strong>插入异常</strong>：学生未选课，无法记录进数据库。</li><li><strong>更新异常</strong>：调整课程学分，所有行都调整。</li></ul><p>根据 2NF 可以拆分如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 学生表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">student（学号、姓名）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 课程表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">course（课程号、学分）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 学生课程关系表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">student_course（学号、课程号、成绩）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">第三范式（3NF）</p></div><p><strong>如果一个关系属于第二范式</strong>，并且在<strong>两个（或多个）非主键属性之间不存在函数依赖</strong>（非主键属性之间的函数依赖也称为传递依赖），那么这个关系属于第三范式。</p><p>3NF 是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即<strong>不存在传递依赖</strong>。</p><p>假设有一张 student 表，结构如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 学生表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">student（学号、姓名、年龄、班级号、班主任）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上表属于第二范式，因为主键由单个属性组成（学号）。</p><p>因为存在<strong>依赖传递</strong>：（学号） → （学生）→（所在班级） → （班主任） 。</p><p><strong>可能会存在问题：</strong></p><ul><li>数据冗余 - 有重复值；</li><li>更新异常 - 有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li></ul><p>可以基于 3NF 拆解：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">student（学号、姓名、年龄、所在班级号）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">class（班级号、班主任）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="【简单】为什么不推荐使用存储过程" tabindex="-1"><a class="header-anchor" href="#【简单】为什么不推荐使用存储过程"><span>【简单】为什么不推荐使用存储过程？</span></a></h3><p>存储过程的优点：</p><ul><li><strong>执行效率高</strong>：一次编译多次使用。</li><li><strong>安全性强</strong>：在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</li><li><strong>可复用</strong>：将代码封装，可以提高代码复用。</li><li><strong>性能好</strong><ul><li>由于是预先编译，因此具有很高的性能。</li><li>一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率。</li></ul></li></ul><p>存储过程的缺点：</p><ul><li><strong>可移植性差</strong>：存储过程不能跨数据库移植。由于不同数据库的存储过程语法几乎都不一样，十分难以维护（不通用）。</li><li><strong>调试困难</strong>：只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</li><li><strong>版本管理困难</strong>：比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li><li><strong>不适合高并发的场景</strong>：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</li></ul><blockquote><p><em>综上，存储过程的优缺点都非常突出，是否使用一定要慎重，需要根据具体应用场景来权衡</em>。</p></blockquote><h3 id="【中等】如何避免重复插入数据" tabindex="-1"><a class="header-anchor" href="#【中等】如何避免重复插入数据"><span>【中等】如何避免重复插入数据？</span></a></h3><p>在 MySQL 中，当存在主键冲突或唯一键冲突的情况下，根据插入策略不同，一般有以下三种避免方法：</p><ul><li><code>INSERT IGNORE INTO</code>：若无则插入，若有则忽略</li><li><code>REPLACE INTO</code>：若无则插入，若有则先删除后插入</li><li><code>INSERT INTO ... ON DUPLICATE KEY UPDATE</code>：若无则插入，若有则更新</li></ul><p>下面结合示例来说明三种方式的效果。</p><p>下面是示例的初始化准备：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 建表</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\` (</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  \`id\`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) UNSIGNED </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NOT NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> AUTO_INCREMENT COMMENT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ID&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  \`name\`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">255</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NOT NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> COMMENT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;名称&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  \`age\`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;0&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> COMMENT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;年龄&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`id\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  UNIQUE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> KEY</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`name\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`name\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> CHARSET </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> utf8mb4;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 测试数据</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`user\`</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;刘备&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`user\`</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;关羽&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">28</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,45)),k(h,{data:[{id:"INSERT IGNORE INTO"},{id:"REPLACE INTO"},{id:"INSERT ... ON DUPLICATE KEY UPDATE"}],"tab-id":"避免重复插入数据"},{title0:t(({value:l,isActive:n})=>[...a[0]||(a[0]=[s("INSERT IGNORE INTO",-1)])]),title1:t(({value:l,isActive:n})=>[...a[1]||(a[1]=[s("REPLACE INTO",-1)])]),title2:t(({value:l,isActive:n})=>[...a[2]||(a[2]=[s("INSERT ... ON DUPLICATE KEY UPDATE",-1)])]),tab0:t(({value:l,isActive:n})=>[...a[3]||(a[3]=[i("p",null,[i("code",null,"INSERT IGNORE INTO"),s(" 会根据主键或者唯一键判断，忽略数据库中已经存在的数据：")],-1),i("ul",null,[i("li",null,[s("若数据库没有该条数据，就插入为新的数据，跟普通的 "),i("code",null,"INSERT INTO"),s(" 一样")]),i("li",null,"若数据库有该条数据，就忽略这条插入语句，不执行插入操作")],-1),i("div",{class:"language-sql line-numbers-mode","data-highlighter":"shiki","data-ext":"sql",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",{class:"language-sql"},[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"INSERT IGNORE INTO"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," user ("),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", age)")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"VALUES"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ("),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"'关羽'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"29"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"), ("),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"'张飞'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"25"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},");")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 最终数据")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"| id | "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"   | age  |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"1"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 刘备   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"30"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"2"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 关羽   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"28"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"3"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 张飞   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"25"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1)])]),tab1:t(({value:l,isActive:n})=>[...a[4]||(a[4]=[i("p",null,[i("code",null,"REPLACE INTO"),s(" 会根据主键或者唯一键判断：")],-1),i("ul",null,[i("li",null,[s("若表中已存在该数据，则先删除此行数据，然后插入新的数据，相当于 "),i("code",null,"delete + insert")]),i("li",null,[s("若表中不存在该数据，则直接插入新数据，跟普通的 "),i("code",null,"insert into"),s(" 一样")])],-1),i("div",{class:"language-sql line-numbers-mode","data-highlighter":"shiki","data-ext":"sql",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",{class:"language-sql"},[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"REPLACE"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," INTO"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," user(id, "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", age)")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"VALUES"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ("),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"2"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},",  "),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"'关羽'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"29"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"), ("),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"4"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},",  "),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"'赵云'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"22"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},");")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 最终数据")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"| id | "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"   | age  |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"1"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 刘备   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"30"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"2"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 关羽   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"29"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"3"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 张飞   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"25"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"4"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 赵云   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"22"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1)])]),tab2:t(({value:l,isActive:n})=>[...a[5]||(a[5]=[i("p",null,[i("code",null,"INSERT ... ON DUPLICATE KEY UPDATE"),s(" 会根据主键或者唯一键判断：")],-1),i("ul",null,[i("li",null,"若数据库已有该数据，则直接更新原数据，相当于 UPDATE"),i("li",null,"若数据库没有该数据，则插入为新的数据，相当于 INSERT")],-1),i("div",{class:"language-sql line-numbers-mode","data-highlighter":"shiki","data-ext":"sql",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",{class:"language-sql"},[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"INSERT INTO"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," user(id, "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", age)")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"VALUES"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ("),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"2"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", "),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"'关羽'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},", "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"27"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},")")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"ON"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," DUPLICATE "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"KEY"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," UPDATE"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"values"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"("),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"), age"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"values"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"(age);")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 最终数据")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"| id | "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"   | age  |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"1"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 刘备   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"30"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"2"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 关羽   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"27"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"3"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 张飞   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"25"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"|  "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"4"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | 赵云   |   "),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}},"22"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," |")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"+"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"----+--------+------+")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1)])]),_:1}),a[7]||(a[7]=e(`<h3 id="【简单】exists-和-in-有什么区别-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】exists-和-in-有什么区别-⭐"><span>【简单】EXISTS 和 IN 有什么区别？⭐</span></a></h3><p>EXISTS 和 IN 区别如下：</p><ul><li><strong>功能</strong><ul><li><code>EXISTS</code> 用于判断子查询的结果集是否为空。</li><li><code>IN</code> 用于判断某个值是否在指定的集合中。</li></ul></li><li><strong>性能</strong><ul><li><strong><code>EXISTS</code> 先外后内</strong>：先对外表进行循环查询，再将查询结果放入 <code>EXISTS</code> 的子查询中进行条件比较，一旦找到匹配记录，则终止内表子查询。</li><li><strong><code>IN</code> 先内后外</strong>：先查询内表，将内表的查询结果作为条件，提供给外表查询语句进行比较。</li></ul></li><li><strong>应用</strong><ul><li>如果查询的两个表大小相当，那么 <code>EXISTS</code> 和 <code>IN</code> 差别不大。</li><li><code>EXISTS</code> 适合外表小而内表大的场景。</li><li><code>IN</code> 适合外表大而内表小的场景。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/0ec4cd12de163599145889e17b25bf97.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>EXISTS 和 IN 的对比示例如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> A </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cc </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cc </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> B)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> A </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> EXISTS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cc </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> B </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cc</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当 A 小于 B 时，用 <code>EXISTS</code>。因为 <code>EXISTS</code> 的实现，相当于外表循环，实现的逻辑类似于：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> A</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> B</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         if</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cc</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 B 小于 A 时用 <code>IN</code>，因为实现的逻辑类似于：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> B</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> A</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         if</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cc</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哪个表小就用哪个表来驱动，A 表小就用 <code>EXISTS</code>，B 表小就用 <code>IN</code>；如果两个表大小相当，则使用 <code>EXISTS</code> 和 <code>IN</code> 的区别不大。</p><h3 id="【简单】union-和-union-all-有什么区别-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】union-和-union-all-有什么区别-⭐"><span>【简单】UNION 和 UNION ALL 有什么区别？⭐</span></a></h3><p><code>UNION</code> 和 <code>UNION ALL</code> 都是将两个结果集合并为一个，<strong>两个要联合的 SQL 语句字段个数必须一样，而且字段类型要“相容”（一致）</strong>。</p><ul><li><code>UNION</code> 需要进行去重扫描，因此效率较低；而 <code>UNION ALL</code> 不会进行去重。</li><li><code>UNION</code> 会按照字段的顺序进行排序；而 <code>UNION ALL</code> 只是简单的将两个结果合并就返回。</li></ul><h3 id="【简单】join-有哪些类型-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】join-有哪些类型-⭐⭐"><span>【简单】JOIN 有哪些类型？⭐⭐</span></a></h3><p><strong>在 SELECT, UPDATE 和 DELETE 语句中，“连接”可以用于联合多表查询。连接使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code></strong>。</p><p><strong>连接可以替换子查询，并且一般比子查询的效率更快</strong>。</p><p><code>JOIN</code> 有以下类型：</p><ul><li>内连接 - 内连接又称等值连接，用于获取两个表中字段匹配关系的记录，<strong>使用 <code>INNER JOIN</code> 关键字</strong>。在没有条件语句的情况下<strong>返回笛卡尔积</strong>。 <ul><li>笛卡尔积 - <strong>“笛卡尔积”也称为交叉连接（<code>CROSS JOIN</code>），它的作用就是可以把任意表进行连接，即使这两张表不相关</strong>。</li><li>自连接（=） - <strong>“自连接（=）”可以看成内连接的一种，只是连接的表是自身而已</strong>。</li><li>自然连接（NATURAL JOIN） - <strong>“自然连接”会自动连接所有同名列</strong>。自然连接使用 <code>NATURAL JOIN</code> 关键字。</li></ul></li><li>外连接 <ul><li>左连接（LEFT JOIN） - <strong>“左外连接”会获取左表所有记录，即使右表没有对应匹配的记录</strong>。左外连接使用 <code>LEFT JOIN</code> 关键字。</li><li>右连接（RIGHT JOIN） - <strong>“右外连接”会获取右表所有记录，即使左表没有对应匹配的记录</strong>。右外连接使用 <code>RIGHT JOIN</code> 关键字。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/sql-join.png" alt="SQL JOIN" tabindex="0" loading="lazy"><figcaption>SQL JOIN</figcaption></figure><h3 id="【中等】为什么不推荐多表-join" tabindex="-1"><a class="header-anchor" href="#【中等】为什么不推荐多表-join"><span>【中等】为什么不推荐多表 JOIN？</span></a></h3><div class="hint-container tip"><p class="hint-container-title">扩展</p><p><a href="https://www.cnblogs.com/eiffelzero/p/18608160" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/eiffelzero/p/18608160</a></p></div><p><a href="https://book.douban.com/subject/27605355/" target="_blank" rel="noopener noreferrer">《阿里巴巴 Java 开发手册》</a> 中强制要求超过三个表禁止 join。这是为什么呢？</p><p>主要原因如下：</p><ul><li><strong>性能问题</strong><ul><li><strong>查询效率低</strong>：当涉及多个表进行 <strong>JOIN</strong> 操作时，MySQL 需要执行多次扫描，尤其是在没有合适索引支持的情况下，性能可能会大幅下降。每增加一个表的 <strong>JOIN</strong>，查询的复杂度呈指数增长。</li><li><strong>临时表的创建</strong>：MySQL 在执行复杂的多表 <strong>JOIN</strong> 时，通常会创建临时表来存储中间结果。如果数据量很大，临时表可能会溢出到磁盘，导致磁盘 I/O 操作增加，从而显著影响查询性能。</li></ul></li><li><strong>索引的作用有限</strong><ul><li>在多表 <strong>JOIN</strong> 的操作中，虽然每个表可以使用索引加速查询，但是当涉及到多个表的连接时，MySQL 必须在这些表之间执行 <strong>JOIN</strong> 操作，这时索引的效果会大大降低。特别是在没有合适索引的情况下，<strong>JOIN</strong> 查询会导致全表扫描，极大地降低了查询效率。</li></ul></li><li><strong>数据冗余</strong><ul><li>在多表 <strong>JOIN</strong> 时，如果一个表中的一行数据与另一个表中的多行数据进行匹配，结果会产生数据冗余。例如，假设有两个表：<code>A</code> 和 <code>B</code>，<code>A</code> 中有 10 条记录，<code>B</code> 中有 5 条记录。如果在 <code>A</code> 和 <code>B</code> 上做 <strong>JOIN</strong> 操作，且匹配条件满足 2 条记录，那么最终的结果会有 20 条记录（10 * 2）。这会导致数据量急剧增加，浪费存储空间。</li></ul></li><li><strong>可读性和可维护性</strong><ul><li>多表 <strong>JOIN</strong> 的 SQL 查询通常比较复杂，尤其是当涉及多个表、多个连接条件以及嵌套查询时，查询语句的可读性会下降，增加了维护的难度。</li><li>复杂的查询可能让开发者和运维人员难以理解和优化，从而增加了错误的风险。</li></ul></li><li><strong>可能引发死锁</strong><ul><li>在进行多个表 <strong>JOIN</strong> 操作时，如果涉及到多张表的锁定，可能会导致死锁。特别是在高并发的环境下，频繁执行 <strong>JOIN</strong> 操作容易导致多个事务之间相互等待，最终导致死锁问题。</li></ul></li><li><strong>优化器的作用有限</strong><ul><li>MySQL 的优化器对多表 <strong>JOIN</strong> 的优化能力相对有限，尤其在处理非常复杂的查询时，可能无法有效选择最优的执行计划，从而导致性能瓶颈。</li><li>虽然 MySQL 使用了 <strong>查询缓存</strong> 和 <strong>索引优化</strong>，但对于多表 <strong>JOIN</strong> 的优化仍然受到很多限制，导致性能不如预期。</li></ul></li></ul><h3 id="【中等】drop、delete-和-truncate-有什么区别" tabindex="-1"><a class="header-anchor" href="#【中等】drop、delete-和-truncate-有什么区别"><span>【中等】DROP、DELETE 和 TRUNCATE 有什么区别？</span></a></h3><ul><li><code>DROP</code> 删除数据表，包括数据和结构。在 InnoDB 中，表数据存于 <code>.ibd</code> 文件；表结构元数据存于 .frm 文件。DROP 本质上是就是直接删除 <code>.ibd</code> 和 <code>.frm</code> 文件。</li><li><code>DELETE</code> 删除数据，但保留表结构。执行 DELETE 后，空间大小不会立刻变化。这是因为，DLETE 操作实际上只是标记，被写入 biglog、redo log 和 undo log。</li><li><code>TRUNCATE</code> 会删除全部表数据，且不会记录日志，因此无法回滚。<code>TRUNCATE</code> 执行后，自增主键重新从 1 开始。</li></ul><h2 id="mysql-建模" tabindex="-1"><a class="header-anchor" href="#mysql-建模"><span>MySQL 建模</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.4/en/data-types.html" target="_blank" rel="noopener noreferrer">MySQL 官方文档之数据类型</a></li><li><a href="http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal" target="_blank" rel="noopener noreferrer">MySQL 如何选择 float, double, decimal</a></li></ul></div><h3 id="【简单】char-和-varchar-的区别是什么" tabindex="-1"><a class="header-anchor" href="#【简单】char-和-varchar-的区别是什么"><span>【简单】CHAR 和 VARCHAR 的区别是什么？</span></a></h3><p><code>CHAR</code> 和 <code>VARCHAR</code> 的主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><ul><li><strong>长度限制</strong><ul><li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li></ul></li><li><strong>占用空间</strong><ul><li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；</li><li><code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。 <ul><li>字符长度超过 255，使用 2 个字节</li><li>字符长度未超过 255，使用 1 个字节</li></ul></li></ul></li><li><strong>应用</strong></li><li><strong><code>CHAR</code> 适合存储长度较短或长度固定的字符串</strong>。例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码；</li><li><strong><code>VARCHAR</code> 适合存储长度不确定的字符串</strong>。例如用户昵称、文章标题等。</li></ul><p><code>BINARY</code> 和 <code>VARBINARY</code> 类似于 <code>CHAR</code> 和 <code>VARCHAR</code>，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/91b303efe57c805f363da2ec6bcf526f.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【简单】金额数据用什么类型存储-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】金额数据用什么类型存储-⭐⭐"><span>【简单】金额数据用什么类型存储？⭐⭐</span></a></h3><p>MySQL 中有 3 种类型可以表示浮点数，分别是 <code>FLOAT</code>、<code>DOUBLE</code> 和 <code>DECIMAL</code>。</p><p><strong>采用 <code>FLOAT</code> 和 <code>DOUBLE</code> 类型会丢失精度</strong>。数据的精确度取决于分配给每种数据类型的存储长度。由于计算机只能存储二进制，所以浮点型数据在存储的时候，必须转化成二进制。</p><ul><li>单精度类型 <code>FLOAT</code> 存储空间为 4 字节，即 32 位。</li><li>双精度类型 <code>DOUBLE</code> 存储空间为 8 字节，即 64 位。</li></ul><p>如果存储的数据转为二进制后，超过存储的位数，数据就被截断，因此存在丢失精度的可能。</p><p>更重要的是，从 MySQL 8.0.17 版本开始，当创建表用到类型 Float 或 Double 时，会抛出下面的警告：MySQL 提醒用户不该用上述浮点类型，甚至提醒将在之后版本中废弃浮点类型。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Specifying number of digits for floating point data types is deprecated and will be removed in a future release</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>【示例】丢失精度案例</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 创建表</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\` (</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  \`value\`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FLOAT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DEFAULT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> NULL</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysql</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> insert into</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">131072</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Query OK, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> row</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> affected (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">01</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sec)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysql</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-----------+</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">| </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     |</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-----------+</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">| </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">131072</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">31</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> |</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">+</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-----------+</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> row</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">02</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：示例中，使用 FLOAT 类型，明明保留了两位小数。但是写入的数据却从 <code>131072.32</code> 变成了 <code>131072.31</code> 。</p><p><code>DECIMAL</code> 类型是 MySQL 官方唯一指定能精确存储的类型。因此，对于不允许丢失精度的场景（如金额数据），可以使用 <code>DECIMAL</code> 类型。</p><p>然而，在海量并发的互联网业务中使用，金额字段的设计并不推荐使用 <code>DECIMAL</code> 类型，而更推荐使用 <code>BIGINT</code> 整型类型。这里会用到一个巧思：将资金类型的数据用分为单位存储，而不是用元为单位存储。如 1 元在数据库中用整型类型 100 存储。</p><p>为什么更推荐用 <code>BIGINT</code> 存储金钱数据？因为 <code>DECIMAL</code> 是个变长字段，若要定义金额字段，则定义为 <code>DECIMAL(8,2)</code> 是远远不够的。这样只能表示存储最大值为 999999.99，百万级的资金存储。用户的金额至少要存储百亿的字段，而统计局的 GDP 金额字段则可能达到数十万亿级别。用类型 <code>DECIMAL</code> 定义，不好统一。另外重要的是，类型 <code>DECIMAL</code> 是通过二进制实现的一种编码方式，计算效率远不如整型来的高效。因此，推荐使用 <code>BIGINT</code> 来存储金额相关的字段。</p><div class="hint-container tip"><p class="hint-container-title">扩展</p><p><a href="http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal" target="_blank" rel="noopener noreferrer">MySQL 如何选择 float, double, decimal</a></p></div><h3 id="【简单】如何存储-emoji-😃" tabindex="-1"><a class="header-anchor" href="#【简单】如何存储-emoji-😃"><span>【简单】如何存储 emoji 😃？</span></a></h3><p>在表结构设计中，除了将列定义为 <code>CHAR</code> 和 <code>VARCHAR</code> 用以存储字符以外，还需要额外定义字符对应的字符集，因为每种字符在不同字符集编码下，对应着不同的二进制值。常见的字符集有 <code>gbk</code>、<code>utf8</code>，通常推荐把默认字符集设置为 <code>utf8</code>。</p><p>随着移动互联网的飞速发展，<strong>推荐把 MySQL 的默认字符集设置为 <code>utf8mb4</code></strong>，否则，某些 emoji 表情字符无法在 UTF8 字符集下存储。</p><p>【示例】设置表的字符集为 <code>utf8mb4</code></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test CHARSET utf8mb4;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>注意：上述修改只是将表的字符集修改为 <code>utf8mb4</code>，下次新增列时，若不显式地指定字符集，新列的字符集会变更为 <code>utf8mb4</code>，<strong>但对于已经存在的列，其默认字符集并不做修改</strong>。</p></blockquote><p>【示例】设置表的默认字符集为 <code>utf8mb4</code></p><p>正确设置 <code>utf8mb4</code> 字符集方法如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test CONVERT </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> CHARSET utf8mb4;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="【简单】时间数据选择-datetime-还是-timestamp" tabindex="-1"><a class="header-anchor" href="#【简单】时间数据选择-datetime-还是-timestamp"><span>【简单】时间数据选择 DATETIME 还是 TIMESTAMP？</span></a></h3><p>表结构设计时，对时间字段的存储，通常会有 3 种选择：<code>DATETIME</code>、<code>TIMESTAMP</code>、<code>INT</code>。</p><p><code>DATETIME</code>、<code>TIMESTAMP</code>、<code>INT</code> 数据表示范围：</p><ul><li><code>DATETIME</code> 占用 8 个字节，可表示范围为：<code>1000-01-01 00:00:00.000000</code> 到 <code>9999-12-31 23:59:59.999999</code></li><li><code>TIMESTAMP</code> 占用 4 个字节，可表示范围为：<code>&#39;1970-01-01 00:00:01.000000&#39; UTC</code> 到 <code>&#39;2038-01-09 03:14:07.999999&#39; UTC</code>。表示从 <code>1970-01-01 00:00:00</code> 到现在的毫秒数。</li><li><code>INT</code> 类型就是直接存储 ‘1970-01-01 00:00:00’ 到现在的毫秒数，本质和 <code>TIMESTAMP</code> 一样，因此用 <code>INT</code> 不如直接使用 <code>TIMESTAMP</code>。</li></ul><p>此外，<code>TIMESTAMP</code> 还存在潜在的性能问题。虽然从毫秒数转换到类型 <code>TIMESTAMP</code> 本身需要的 CPU 指令并不多，这并不会带来直接的性能问题。但是如果使用默认的操作系统时区，则每次通过时区计算时间时，要调用操作系统底层系统函数 <code>__tz_convert()</code>，而这个函数需要额外的加锁操作，以确保这时操作系统时区没有修改。所以，当大规模并发访问时，由于热点资源竞争，会产生两个问题。</p><ul><li><strong>性能不如 DATETIME：</strong> <code>DATETIME</code> 不存在时区转化问题。</li><li><strong>性能抖动：</strong> 海量并发时，存在性能抖动问题。</li></ul><p>为了优化 TIMESTAMP 的使用，强烈建议使用显式的时区，而不是操作系统时区。比如在配置文件中显示地设置时区，而不要使用系统时区</p><p>综上，由于 <code>TIMESTAMP</code> 存在时间上限和潜在性能问题，所以推荐使用 <code>DATETIME</code> 类型来存储时间字段。</p><h3 id="【简单】mysql一张表最多可以有多少列" tabindex="-1"><a class="header-anchor" href="#【简单】mysql一张表最多可以有多少列"><span>【简单】MySQL一张表最多可以有多少列？</span></a></h3><p><strong>理论上限 4096 列</strong>，但实际受存储引擎制约——<strong>InnoDB 引擎最多 1017 列</strong>。</p><p><strong>InnoDB 行格式差异</strong></p><table><thead><tr><th style="text-align:left;">行格式</th><th style="text-align:left;">特点</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>REDUNDANT</strong></td><td style="text-align:left;">768字节前缀</td><td style="text-align:left;">旧版本兼容</td></tr><tr><td style="text-align:left;"><strong>COMPACT</strong></td><td style="text-align:left;">768字节前缀</td><td style="text-align:left;">5.0-5.7默认</td></tr><tr><td style="text-align:left;"><strong>DYNAMIC</strong></td><td style="text-align:left;"><strong>仅20字节指针</strong></td><td style="text-align:left;"><strong>当前默认</strong>（通用）</td></tr><tr><td style="text-align:left;"><strong>COMPRESSED</strong></td><td style="text-align:left;">20字节指针，支持压缩</td><td style="text-align:left;">节省磁盘空间</td></tr></tbody></table><h3 id="【中等】mysql-在建表时需要注意什么" tabindex="-1"><a class="header-anchor" href="#【中等】mysql-在建表时需要注意什么"><span>【中等】MySQL 在建表时需要注意什么？</span></a></h3><p><strong>建表决定命运——类型、主键、字符集、索引、约束，五大要点决定生死</strong>。</p><ul><li>字段类型：够用就好：能用TINYINT不用INT，能用数字不用字符串，金额必须DECIMAL。</li><li>主键设计：必须自增：必须有主键，最好BIGINT自增，严禁UUID（随机插入毁性能）。</li><li>字符集：唯一选择utf8mb4：千万别用utf8，它存不了emoji。</li><li>约束：能加就加：尽量NOT NULL，合理DEFAULT，必要UNIQUE。</li><li>索引：精准打击：区分度高的放联合索引前面，单表不超过5个，避免冗余。</li></ul><h2 id="mysql-存储" tabindex="-1"><a class="header-anchor" href="#mysql-存储"><span>MySQL 存储</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html" target="_blank" rel="noopener noreferrer">MySQL 官方文档之 InnoDB 存储引擎</a></li><li><a href="https://dev.mysql.com/doc/refman/8.4/en/storage-engines.html" target="_blank" rel="noopener noreferrer">MySQL 官方文档之可选的存储引擎</a></li></ul></div><h3 id="【中等】mysql-支持哪些存储引擎-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】mysql-支持哪些存储引擎-⭐⭐"><span>【中等】MySQL 支持哪些存储引擎？⭐⭐</span></a></h3><p><strong>存储引擎层负责数据的存储和提取</strong>。MySQL 的存储引擎采用了插拔式架构，可以根据需要替换。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/0a682886e08640e2a99db61fc0eb9ec9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL 内置了以下存储引擎：</p><ul><li><strong>InnoDB</strong>：InnoDB 是 MySQL 5.5 版本以后的默认存储引擎。 <ul><li>优点：支持<strong>事务</strong>，支持<strong>行级锁</strong>，支持<strong>外键约束</strong>等，<strong>并发性能不错</strong>且支持<strong>自动故障恢复</strong>。</li></ul></li><li><strong>MyISAM</strong>：MyISAM 是 MySQL 5.5 版本以前的默认存储引擎。 <ul><li>优点：速度快，占用资源少。</li><li>缺点：不支持事务，不支持行级锁，不支持外键约束，也不支持自动故障恢复功能。</li></ul></li><li><strong>Memory</strong>：使用系统内存作为存储介质，以便得到更快的响应速度。不过，如果 mysqld 进程崩溃，则会导致所有的数据丢失。因此，Memory 引擎常用于临时表。</li><li><strong>NDB</strong>：也被称为 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li><li><strong>Archive</strong>：Archive 存储引擎有很好的压缩机制，非常适合用于归档数据。 <ul><li>Archive 存储引擎只支持 <code>INSERT</code> 和 <code>SELECT</code> 操作。</li><li>Archive 存储引擎采用 zlib 算法压缩数据，压缩比可达到 1: 10。</li></ul></li><li><strong>CSV</strong>：可以将 CSV 文件作为 MySQL 的表来处理，但这种表不支持索引。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/62d5206d48503343590200ddd8b9cfd0.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【中等】innodb-和-myisam-有哪些差异-⭐" tabindex="-1"><a class="header-anchor" href="#【中等】innodb-和-myisam-有哪些差异-⭐"><span>【中等】InnoDB 和 MyISAM 有哪些差异？⭐</span></a></h3><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持四种事务隔离级别</td></tr><tr><td>锁粒度</td><td>支持表级锁</td><td>支持表级锁、行级锁</td></tr><tr><td>索引</td><td>采用 B+ 树索引（非聚簇索引）</td><td>采用 B+ 树索引（聚簇索引）</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>计数器</td><td>维护了计数器，<code>SELECT COUNT(*)</code> 效率为 <code>O(1)</code></td><td>没有维护计数器，需要全表扫描</td></tr><tr><td>自动故障恢复</td><td>不支持</td><td>支持（依赖于 redo log）</td></tr></tbody></table><h3 id="【中等】如何选择-mysql-存储引擎" tabindex="-1"><a class="header-anchor" href="#【中等】如何选择-mysql-存储引擎"><span>【中等】如何选择 MySQL 存储引擎？</span></a></h3><ul><li><strong>大多数情况下，使用默认的 InnoDB 就够了</strong>。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。</li><li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li><li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中。MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li><li>如果存储归档数据，可以使用 ARCHIVE 引擎。</li></ul><p>使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p><h3 id="【中等】mysql-有哪些物理存储文件" tabindex="-1"><a class="header-anchor" href="#【中等】mysql-有哪些物理存储文件"><span>【中等】MySQL 有哪些物理存储文件？</span></a></h3><p>MySQL 不同存储引擎的物理存储文件是不一样的。</p><p>InnoDB 的物理文件结构为：</p><ul><li><code>.frm</code> 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li><li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。 <ul><li>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件</li><li>共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2023/11/4dbec2a86c464e16a3ff4d462becd077.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MyISAM 的物理文件结构为：</p><ul><li><code>.frm</code>文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li><li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据。</li><li><code>.MYI</code> (<code>MYIndex</code>) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息。</li></ul><h3 id="【中等】什么是-buffer-pool-⭐" tabindex="-1"><a class="header-anchor" href="#【中等】什么是-buffer-pool-⭐"><span>【中等】什么是 Buffer Pool？⭐</span></a></h3><p>Buffer Pool（缓冲池）是 MySQL InnoDB 存储引擎的核心组件之一，它是数据库系统中的内存缓存区域，主要<strong>用于缓存表和索引的数据</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/061066cc08d4c4a0714094e60adff7eb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>主要作用</strong>：</p><ol><li><strong>减少磁盘 I/O</strong>：将频繁访问的数据页缓存在内存中，避免每次查询都要从磁盘读取</li><li><strong>提高查询性能</strong>：内存访问速度远快于磁盘访问</li><li><strong>写缓冲</strong>：对数据的修改先在内存中进行，再通过后台线程定期刷新到磁盘</li></ol><p><strong>工作原理</strong>：</p><ul><li>Buffer Pool <strong>以页 (page) 为单位存储数据，默认每页 16KB</strong></li><li><strong>使用 LRU 算法管理内存页</strong></li><li>包含&quot;年轻代&quot;和&quot;老年代&quot;两个区域，防止全表扫描污染缓存</li></ul><h3 id="【中等】什么是-change-buffer-⭐" tabindex="-1"><a class="header-anchor" href="#【中等】什么是-change-buffer-⭐"><span>【中等】什么是 Change Buffer？⭐</span></a></h3><p>Change Buffer 是 InnoDB 存储引擎中的一种关键优化机制，主要<strong>用于提高非唯一二级索引的写操作性能</strong>。</p><p>Change Buffer 是一种特殊的内存数据结构，用于缓存对<strong>非唯一二级索引页</strong>的修改操作（INSERT、UPDATE、DELETE），当这些索引页不在缓冲池 (Buffer Pool) 中时，避免立即从磁盘读取索引页。</p><p><strong>原理</strong></p><ul><li><strong>写操作发生时</strong>：当修改非唯一二级索引的数据时，InnoDB 会检查目标索引页是否在 Buffer Pool 中。 <ul><li>如果在：直接修改</li><li>如果不在：将修改操作记录到 Change Buffer</li></ul></li><li><strong>后续读取时</strong>：当需要读取该索引页时，InnoDB 会将 Change Buffer 中的修改与从磁盘读取的原始页合并。</li><li><strong>后台合并</strong>：有专门的线程定期将 Change Buffer 中的变更合并到磁盘上的索引页。</li></ul><p><strong>优势</strong></p><ul><li><strong>减少磁盘 I/O</strong>：避免为写入操作立即读取索引页，将随机写入转为顺序写入</li><li><strong>提高吞吐量</strong>：多个变更可以合并执行</li></ul><p><strong>适用场景</strong></p><ul><li>适用于<strong>写多读少</strong>的非唯一二级索引</li><li>特别适合<strong>大量 DML 操作</strong>但索引不常被查询的业务场景</li></ul><p><strong>不适用场景</strong></p><ul><li>唯一索引（需要立即检查唯一性约束）</li><li>索引被频繁查询（会导致频繁合并操作）</li></ul><p><strong>相关配置</strong></p><ul><li><code>innodb_change_buffer_max_size</code>：Change Buffer 最大占 Buffer Pool 的比例（默认 25%）</li><li><code>innodb_change_buffering</code>：指定缓冲的变更类型（all/none/inserts/deletes 等）</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/8d46210ed8cde0f0744e3899216c58e4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【简单】mysql-有哪些类型的日志" tabindex="-1"><a class="header-anchor" href="#【简单】mysql-有哪些类型的日志"><span>【简单】MySQL 有哪些类型的日志？</span></a></h3><p>MySQL 日志文件有很多，包括 ：</p><ul><li><strong>错误日志</strong>（error log）：错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。</li><li><strong>慢查询日志</strong>（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</li><li><strong>一般查询日志</strong>（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。</li><li><strong>二进制日志</strong>（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。</li></ul><p>还有两个 InnoDB 存储引擎特有的日志文件：</p><ul><li><strong>重做日志</strong>（redo log）：重做日志至关重要，因为它们记录了对于 InnoDB 存储引擎的事务日志。</li><li><strong>回滚日志</strong>（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的 undo log 日志；如果事务执行失败或调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><h3 id="【简单】bin-log-和-redo-log-有什么区别-⭐" tabindex="-1"><a class="header-anchor" href="#【简单】bin-log-和-redo-log-有什么区别-⭐"><span>【简单】bin log 和 redo log 有什么区别？⭐</span></a></h3><table><thead><tr><th style="text-align:left;">维度</th><th style="text-align:left;">binlog</th><th style="text-align:left;">redo log</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>所属层级</strong></td><td style="text-align:left;"><strong>MySQL Server 层</strong></td><td style="text-align:left;"><strong>InnoDB 存储引擎层</strong></td></tr><tr><td style="text-align:left;"><strong>日志性质</strong></td><td style="text-align:left;"><strong>逻辑日志</strong> （记录的 SQL 语句/行变化逻辑）</td><td style="text-align:left;"><strong>物理日志</strong> （记录数据页的修改）</td></tr><tr><td style="text-align:left;"><strong>主要用途</strong></td><td style="text-align:left;"><strong>数据复制</strong> （主从同步） &amp; <strong>数据恢复</strong> （任意时间点恢复）</td><td style="text-align:left;"><strong>崩溃恢复</strong> （保证事务持久性）</td></tr><tr><td style="text-align:left;"><strong>写入时机</strong></td><td style="text-align:left;">事务<strong>提交后</strong>才一次性写入</td><td style="text-align:left;">事务<strong>进行中</strong>持续写入 (Write-Ahead Logging)</td></tr><tr><td style="text-align:left;"><strong>写入方式</strong></td><td style="text-align:left;"><strong>追加写</strong> （文件一直增大）</td><td style="text-align:left;"><strong>循环写</strong> （固定大小，循环覆盖）</td></tr><tr><td style="text-align:left;"><strong>内容格式</strong></td><td style="text-align:left;">Statement (SQL 语句） / Row （行数据） / Mixed</td><td style="text-align:left;">物理数据页变化 (Page ID + 修改内容）</td></tr><tr><td style="text-align:left;"><strong>生命周期</strong></td><td style="text-align:left;">长期保留 （可配置过期时间）</td><td style="text-align:left;">事务提交后可能被覆盖 (crash-safe 后即可复用）</td></tr></tbody></table><h3 id="【简单】什么是-wal-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】什么是-wal-⭐⭐⭐"><span>【简单】什么是 WAL？⭐⭐⭐</span></a></h3><p>WAL（Write-Ahead Logging）是一种数据库事务日志管理技术，确保在修改数据之前先将修改记录写入日志。它的关键点就是 <strong>先写日志，再写磁盘</strong>。</p><p>WAL 是一种通用技术，被广泛应用于各种数据库，但实现各有不同。在 InnoDB 中，redo log 就是 WAL 的实现。</p><h3 id="【中等】redo-log-如何刷盘-⭐" tabindex="-1"><a class="header-anchor" href="#【中等】redo-log-如何刷盘-⭐"><span>【中等】redo log 如何刷盘？⭐</span></a></h3><p><strong>redo log 刷盘是事务持久性的保证</strong>。</p><p><strong>redo log 刷盘 = 将内存中的日志（redo log buffer）写到磁盘文件（ib_logfile）的过程</strong>。</p><p><strong>redo log 是 WAL 技术（先写日志，后写数据）在 InnoDB 的实现</strong>。</p><div class="hint-container info"><p class="hint-container-title">redo log 工作流程</p></div><p>Redo Log 由固定大小的文件组成（如 ib_logfile0、ib_logfile1），循环写入。</p><p>写满后触发 Checkpoint，将脏页刷盘，并清理已释放的日志空间。</p><ul><li><strong>延迟刷盘</strong><ul><li>事务提交前，修改先写入 redo log 缓冲区（Log Buffer）。</li><li>Log Buffer 的数据按 <code>innodb_flush_log_at_trx_commit</code> 参数配置的刷盘策略，延迟刷新到磁盘上的 redo log 文件。</li></ul></li><li><strong>先写日志，再写磁盘</strong>： <ul><li>事务提交前，先确保 redo log 已写入磁盘</li><li>数据写入 binlog 并刷盘</li><li>将 redo log 的事务状态改为提交状态</li></ul></li><li><strong>故障恢复</strong><ul><li>数据库崩溃时，通过 redo log 实现故障恢复</li><li>找到 redo log 最近一次 Checkpoint 的位置</li><li>重放 Checkpoint 之后的所有日志，恢复未刷盘的脏页</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">刷盘策略</p></div><p><strong>redo log 通过 <code>innodb_flush_log_at_trx_commit</code> 参数决定刷盘策略</strong>。</p><table><thead><tr><th style="text-align:left;">参数值</th><th style="text-align:left;">刷盘时机</th><th style="text-align:left;">数据安全</th><th style="text-align:left;">性能</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>= 1</strong> （默认）</td><td style="text-align:left;"><strong>事务提交时，立即 fsync</strong></td><td style="text-align:left;"><strong>最高</strong>（崩溃最多丢失 1 个事务）</td><td style="text-align:left;"><strong>最低</strong>（每次提交都有磁盘 IO）</td><td style="text-align:left;">强一致，如金融交易</td></tr><tr><td style="text-align:left;"><strong>= 2</strong></td><td style="text-align:left;"><strong>事务提交时，写到 OS 页缓存，每秒 fsync</strong></td><td style="text-align:left;"><strong>中等</strong>（崩溃可能丢失 1 秒数据）</td><td style="text-align:left;"><strong>中等</strong>（无磁盘 IO，除非 OS 刷新）</td><td style="text-align:left;">折中，通用场景</td></tr><tr><td style="text-align:left;"><strong>= 0</strong></td><td style="text-align:left;"><strong>事务提交不刷，后台线程每秒 fsync</strong></td><td style="text-align:left;"><strong>最低</strong>（崩溃可能丢失最多 1 秒数据）</td><td style="text-align:left;"><strong>最高</strong>（合并 IO，吞吐量大）</td><td style="text-align:left;">可容忍少量丢失，如日志采集</td></tr></tbody></table><h3 id="【中等】日志为什么要两阶段提交-⭐" tabindex="-1"><a class="header-anchor" href="#【中等】日志为什么要两阶段提交-⭐"><span>【中等】日志为什么要两阶段提交？⭐</span></a></h3><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 <ul><li>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li><li>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li></ul></li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>可以看到，<strong>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong>。</p><h3 id="【中等】什么是-log-buffer-⭐" tabindex="-1"><a class="header-anchor" href="#【中等】什么是-log-buffer-⭐"><span>【中等】什么是 Log Buffer？⭐</span></a></h3><p><strong>Log Buffer</strong> 用于缓冲 redo log 的写入，减少频繁刷盘 fsync 的开销，将多次写入优化为一次批量写入。</p><p>redo log 是 InnoDB 的重做日志，用于崩溃恢复，确保数据正确性。redo log 采用 WAL 机制：先写日志，再写磁盘数据，将随机写入转换为顺序写入。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2023/11/b2995714d7774039899d5aa0d446891c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>Log Buffer 的刷盘时机</strong></p><ul><li><strong>事务提交时</strong>：事务产生的多条 redo log 会先缓存在 Log Buffer，提交时一次性写入文件（受配置参数控制）。</li><li><strong>空间触发机制</strong>：当 Log Buffer 超过总容量的一半（默认 16MB）时自动刷盘。</li><li><strong>时间触发机制</strong>：每隔 1 秒定时刷盘。</li></ul><p><strong>配置参数<code>innodb_flush_log_at_trx_commit</code></strong></p><ul><li><strong>0</strong>：事务提交不刷盘，依赖后台线程每秒刷盘。性能最佳，但可能丢失 1 秒数据。</li><li><strong>1</strong>（默认）：事务提交时同步刷盘（写 OS cache 并调用 fsync）。数据最安全，性能最差。</li><li><strong>2</strong>：事务提交时仅写 OS cache，后台线程每秒调用 fsync。性能折中，服务器宕机可能丢失 1 秒数据。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/0865f0eedb05b7b625c67ce41bdb78d9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="mysql-复制" tabindex="-1"><a class="header-anchor" href="#mysql-复制"><span>MySQL 复制</span></a></h2><h3 id="【中等】mysql-如何实现主从同步-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】mysql-如何实现主从同步-⭐⭐⭐"><span>【中等】MySQL 如何实现主从同步？⭐⭐⭐</span></a></h3><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一台主库的数据可以同步到多台从库上，从库本身也可以被配置成另外一台服务器的主库。主库和从库之间可以有多种不同的组合方式。</p><p>MySQL 复制采用主从同步，基于 <strong>binlog（二进制日志）</strong> 实现。其流程大致为：</p><ul><li>主库记录 <strong>DML/DDL</strong> 操作到 binlog。</li><li>从库获取 binlog 并重放，保持数据同步。</li></ul><p>MySQL 支持三种复制方式：同步、异步、半同步。下面是三种方式的对比：</p><table><thead><tr><th><strong>模式</strong></th><th><strong>机制</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>异步复制</strong>（默认）</td><td>主库不等待从库响应</td><td>高性能</td><td>数据一致性弱（可能丢失）</td></tr><tr><td><strong>同步复制</strong></td><td>主库等待所有从库确认</td><td>强一致性</td><td>性能差，延迟高</td></tr><tr><td><strong>半同步复制</strong></td><td>主库等待至少一个从库确认</td><td>平衡性能与一致性</td><td>比异步略慢</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">异步复制</p></div><p>MySQL 异步复制可以分为三个步骤，分别由三个线程完成：</p><ul><li><strong>binlog dump 线程</strong>：主库接收事务请求，更新数据，并即时响应客户端（不等待从库）。主库上有一个特殊的 binlog dump 线程，负责将主服务器上的数据更改写入 binlog 中。</li><li><strong>I/O 线程</strong>：从库上有一个 I/O 线程，负责从主库上读取 binlog，并写入从库的中继日志（relay log）中。</li><li><strong>SQL 线程</strong>：从库上有一个 SQL 线程，负责重放中继日志（relay log），更新从库数据。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>需要注意的是，<strong>采用异步复制有丢失数据的风险</strong>，主库崩溃时，未同步的 binlog 可能丢失（<strong>弱一致性</strong>）。</p><div class="hint-container info"><p class="hint-container-title">同步复制</p></div><p>主库必须等待<strong>所有从库</strong>完成 binlog 同步后才响应客户端。</p><p><strong>特点</strong>：</p><ul><li>数据强一致性（所有节点完全同步）</li><li>性能极差（延迟高，吞吐量低）</li><li>生产环境基本不使用</li></ul><div class="hint-container info"><p class="hint-container-title">半同步复制</p></div><p>MySQL 5.7 引入了半同步复制：主库只需等待<strong>至少 N 个从库</strong>（可配置）确认即返回。</p><p><strong>特点</strong>：</p><ul><li><strong>性能与可靠性的平衡</strong>（比全同步快，比异步安全）。</li><li>仅当主库和所有已确认从库<strong>同时崩溃</strong>时可能丢数据。</li></ul><div class="hint-container info"><p class="hint-container-title">并行复制</p></div><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/fc628018902cb3853fc7e10fce082e0b.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【中等】如何处理-mysql-主从同步延迟" tabindex="-1"><a class="header-anchor" href="#【中等】如何处理-mysql-主从同步延迟"><span>【中等】如何处理 MySQL 主从同步延迟？</span></a></h3><p><strong>主从延迟的常见解决方案</strong></p><ul><li><strong>二次查询</strong>（兜底策略）：从库查不到时，再查主库。缺点是：恶意查询可能导致主库压力增大。</li><li><strong>强制写后读走主库</strong>：写入后立即读的操作绑定走主库。缺点是：代码耦合，灵活性差。</li><li><strong>关键业务读写主库，非关键业务读写分离</strong></li><li><strong>使用缓存</strong>：主库写入后同步缓存，查询优先查缓存。缺点是：引入缓存后，新增了一致性问题。</li><li><strong>提升从库配置</strong>：优化从库硬件（CPU、内存、磁盘等），提高同步效率。</li></ul><p><strong>MySQL 主从延迟的常见原因及优化方案</strong></p><table><thead><tr><th style="text-align:left;"><strong>原因</strong></th><th style="text-align:left;"><strong>优化方案</strong></th></tr></thead><tbody><tr><td style="text-align:left;">从库单线程复制</td><td style="text-align:left;">启用 <strong>并行复制</strong>（多线程同步）。</td></tr><tr><td style="text-align:left;">网络延迟</td><td style="text-align:left;">优化网络，缩短主从物理距离。</td></tr><tr><td style="text-align:left;">从库性能不足</td><td style="text-align:left;">升级硬件（CPU、内存、存储）。</td></tr><tr><td style="text-align:left;">长事务</td><td style="text-align:left;">减少主库长事务，优化 SQL。</td></tr><tr><td style="text-align:left;">从库数量过多</td><td style="text-align:left;">合理控制从库数量，避免主库同步压力过大。</td></tr><tr><td style="text-align:left;">从库查询负载高</td><td style="text-align:left;">增加从库实例，优化慢查询。</td></tr></tbody></table><p><strong>小结</strong></p><ul><li>主从延迟 <strong>无法完全避免</strong>，只能优化降低延迟时间。</li><li>业务层面应结合 <strong>缓存、读写分离策略、关键业务走主库</strong> 等方式综合解决。</li><li>技术层面可优化 <strong>并行复制、网络、硬件</strong> 等。</li></ul><h2 id="mysql-架构" tabindex="-1"><a class="header-anchor" href="#mysql-架构"><span>MySQL 架构</span></a></h2><h3 id="【简单】什么是-cdc-change-data-capture" tabindex="-1"><a class="header-anchor" href="#【简单】什么是-cdc-change-data-capture"><span>【简单】什么是 CDC（Change Data Capture）？</span></a></h3><p>CDC 即实时捕获数据库中的数据变更（增删改），并同步到其他系统。</p><p>常见 CDC 工具：</p><table><thead><tr><th style="text-align:left;">工具</th><th style="text-align:left;">支持数据库</th><th style="text-align:left;">特点</th><th style="text-align:left;">适用场景</th><th style="text-align:left;">记忆点</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Canal</strong></td><td style="text-align:left;">MySQL</td><td style="text-align:left;">阿里开源，Java生态，解析binlog</td><td style="text-align:left;">MySQL→Kafka/ES</td><td style="text-align:left;">&quot;阿里运河&quot;</td></tr><tr><td style="text-align:left;"><strong>Debezium</strong></td><td style="text-align:left;">MySQL, PG, MongoDB, Oracle等</td><td style="text-align:left;">Kafka原生集成，云原生友好</td><td style="text-align:left;">全场景、Kafka生态</td><td style="text-align:left;">&quot;数据瑞士军刀&quot;</td></tr><tr><td style="text-align:left;"><strong>Flink CDC</strong></td><td style="text-align:left;">MySQL, PG, Oracle等</td><td style="text-align:left;">基于Flink，支持Exactly-Once</td><td style="text-align:left;">实时计算、数据集成</td><td style="text-align:left;">&quot;流式计算CDC&quot;</td></tr><tr><td style="text-align:left;"><strong>Maxwell</strong></td><td style="text-align:left;">MySQL</td><td style="text-align:left;">轻量级，输出JSON</td><td style="text-align:left;">简单MySQL同步</td><td style="text-align:left;">&quot;轻量小工具&quot;</td></tr></tbody></table><h3 id="【中等】sql-查询语句的执行顺序是怎么样的" tabindex="-1"><a class="header-anchor" href="#【中等】sql-查询语句的执行顺序是怎么样的"><span>【中等】SQL 查询语句的执行顺序是怎么样的？</span></a></h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2025/06/710bd42c250f49ada0796d8a59d976b0.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所有的查询语句都是从 FROM 开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。</p><p><strong>执行顺序</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DISTINCT</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Select_list</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">left_table</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">join_type</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">JOIN</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">right_table</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ON</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">join_condition</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">where_condition</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">GROUP BY</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">group_by_list</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WITH</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CUBE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ROLLUP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">HAVING</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">having_condtion</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">order_by_list</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">limit_number</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">扩展</p><p><a href="https://zhuanlan.zhihu.com/p/77847158" target="_blank" rel="noopener noreferrer">SQL 的书写顺序和执行顺序</a></p></div><h3 id="【困难】一条-sql-查询语句是如何执行的-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【困难】一条-sql-查询语句是如何执行的-⭐⭐⭐"><span>【困难】一条 SQL 查询语句是如何执行的？⭐⭐⭐</span></a></h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2024/10/702667178a274a67ac92bc333a0ffbfd.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL 整个查询执行过程，总的来说分为 6 个步骤：</p><ol><li><strong>连接器</strong>：客户端和 MySQL 服务器建立连接；连接器负责跟客户端<strong>建立连接</strong>、<strong>获取权限</strong>、<strong>维持和管理连接</strong>。</li><li><strong>查询缓存</strong>：MySQL 服务器首先检查查询缓存，如果命中缓存，则立刻返回结果。否则进入下一阶段。MySQL 缓存弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。</li><li><strong>分析器</strong>：MySQL 服务器进行 SQL 解析：<strong>语法分析</strong>、<strong>词法分析</strong>。</li><li><strong>优化器</strong>：MySQL 服务器用优化器<strong>生成对应的执行计划</strong>，<strong>根据策略选择最优索引</strong>。</li><li><strong>执行器</strong>：MySQL 服务器根据执行计划，调用存储引擎的 API 来<strong>执行查询</strong>。</li><li><strong>返回结果</strong>：MySQL 服务器将结果返回给客户端，同时缓存查询结果。</li></ol><h3 id="【困难】一条-sql-更新语句是如何执行的-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【困难】一条-sql-更新语句是如何执行的-⭐⭐⭐"><span>【困难】一条 SQL 更新语句是如何执行的？⭐⭐⭐</span></a></h3><p>更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：</p><ul><li><strong>redo log（重做日志）</strong><ul><li>InnoDB 存储引擎独有的日志（物理日志）</li><li>采用循环写入</li></ul></li><li><strong>bin log（归档日志）</strong><ul><li>MySQL Server 层通用日志（逻辑日志）</li><li>采用追加写入</li></ul></li></ul><p>为了保证 redo log 和 bin log 的数据一致性，所以采用两阶段提交方式更新日志。</p><h3 id="【困难】order-by-是怎么工作的-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【困难】order-by-是怎么工作的-⭐⭐"><span>【困难】<code>order by</code> 是怎么工作的？⭐⭐</span></a></h3><p>用 explain 命令查看执行计划时，Extra 这个字段中的“Using filesort”表示的就是需要排序。</p><div class="hint-container info"><p class="hint-container-title">全字段排序</p></div><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> city,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,age </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> city</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;杭州&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> order by</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> limit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个语句执行流程如下所示 ：</p><p><strong>执行流程</strong>：</p><ul><li>初始化 <code>sort_buffer</code>，确定放入需要排序的字段（如 <code>name</code>、<code>city</code>、<code>age</code>）。</li><li>从索引中找到满足条件的记录，取出对应的字段值存入 <code>sort_buffer</code>。</li><li>对 <code>sort_buffer</code> 中的数据按照排序字段进行排序。</li><li>返回排序后的结果。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/07/1d5a380080ae4a8e8a6ab59701ba0c2a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>内存与磁盘排序</strong>：</p><ul><li>如果排序数据量小于 <code>sort_buffer_size</code>，排序在内存中完成。</li><li>如果数据量过大，MySQL 会使用临时文件进行外部排序（归并排序）。<strong>MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</strong></li></ul><p><strong>优化器追踪</strong>：通过 <code>OPTIMIZER_TRACE</code> 可以查看排序过程中是否使用了临时文件（<code>number_of_tmp_files</code>）。</p><div class="hint-container info"><p class="hint-container-title">rowid 排序</p></div><ul><li><strong>执行流程</strong>： <ul><li>当单行数据过大时，MySQL 会采用 <code>rowid</code> 排序，只将排序字段（如 <code>name</code>）和主键 <code>id</code> 放入 <code>sort_buffer</code>。</li><li>排序完成后，根据 <code>id</code> 回表查询其他字段（如 <code>city</code>、<code>age</code>）。</li></ul></li><li><strong>性能影响</strong>：<code>rowid</code> 排序减少了 <code>sort_buffer</code> 的内存占用，但增加了回表操作，导致更多的磁盘 I/O。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2022/07/40b5efca71a04ddfa9a9d659d808f32a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container info"><p class="hint-container-title">全字段排序 VS rowid 排序</p></div><ul><li><strong>内存优先</strong>： <ul><li>如果内存足够大，MySQL 优先使用全字段排序，以减少磁盘访问。</li><li>只有在内存不足时，才会使用 <code>rowid</code> 排序。</li></ul></li><li><strong>设计思想</strong>：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></li></ul><p>并不是所有的 order by 语句，都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的</strong>。如果查询的字段和排序字段可以通过联合索引覆盖，MySQL 可以直接利用索引的有序性，避免排序操作。</p><h3 id="【困难】如果-select-from-一个有千万级数据的表-内存会飙升么" tabindex="-1"><a class="header-anchor" href="#【困难】如果-select-from-一个有千万级数据的表-内存会飙升么"><span>【困难】如果 select * from 一个有千万级数据的表，内存会飙升么？</span></a></h3><p><strong>通常不会导致 MySQL 服务器内存飙升，但如果客户端处理不当，客户端的内存可能会飙升。</strong></p><ul><li>服务端：<code>SELECT * FROM huge_table</code> 时，MySQL 的 <strong>InnoDB 存储引擎</strong> 并不会尝试将全部千万条记录一次性加载到内存中。MySQL 服务端使用固定大小的 Buffer Pool 按需读取数据页，并流式地将结果发送给客户端。</li><li>客户端：如果客户端尝试一次性拉取全部数据，就会出现内存飙升的情况。</li></ul><p><strong>客户端最佳实践</strong></p><p>聪明的客户端会使用“流式查询”或“游标”的方式来处理大数据集。</p><ul><li><strong>服务器端游标（Server-Side Cursor）</strong>：MySQL 提供了这种方式（虽然协议上支持，但并非所有驱动都默认开启）。</li><li><strong>客户端流式读取（Client-Side Streaming）</strong>：即使没有真正的服务器端游标，客户端也可以以流的方式处理结果集。它从网络连接中读取一批数据（例如 1000 行），处理完这批数据后，再读取下一批，而不是一次性读取所有。 <ul><li><strong>Python (PyMySQL/MySQLdb)</strong>: 创建游标时使用 <code>SSCursor</code>（<code>cursorclass = pymysql.cursors.SSCursor</code>）。</li><li><strong>Java (JDBC)</strong>: 在创建 <code>Statement</code> 对象时设置 <code>fetchSize</code> 为 <code>Integer.MIN_VALUE</code>（或根据驱动文档设置）来启用流式读取。</li></ul></li></ul><p>使用流式处理后，客户端的内存占用将保持在一个<strong>很小且恒定</strong>的水平（只相当于单批处理数据的大小），而不会随着结果集的大小而增长。</p><h3 id="【困难】mysql-如何选择执行计划-⭐" tabindex="-1"><a class="header-anchor" href="#【困难】mysql-如何选择执行计划-⭐"><span>【困难】MySQL 如何选择执行计划？⭐</span></a></h3><p>MySQL 通过优化器（Optimizer）选择执行计划，核心流程如下：</p><p><strong>执行计划生成步骤</strong></p><ol><li><strong>解析 SQL</strong>：生成语法树，检查表/列是否存在</li><li><strong>预处理阶段</strong>：展开视图、优化子查询</li><li><strong>优化器核心工作</strong>： <ul><li><strong>生成候选执行计划</strong>（全表扫描、索引扫描、JOIN 顺序等）</li><li><strong>成本估算</strong>（基于统计信息计算每个计划的 I/O、CPU 消耗）</li><li><strong>选择成本最低的计划</strong></li></ul></li></ol><p><strong>影响执行计划的关键因素</strong></p><table><thead><tr><th>因素</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><strong>统计信息</strong></td><td>表大小、索引区分度等</td><td><code>ANALYZE TABLE</code>更新统计</td></tr><tr><td><strong>索引情况</strong></td><td>可用索引及其选择性</td><td>高区分度索引优先</td></tr><tr><td><strong>查询复杂度</strong></td><td>JOIN/子查询数量</td><td>简单查询优先走索引</td></tr><tr><td><strong>系统变量</strong></td><td>优化器开关配置</td><td><code>optimizer_switch</code>参数</td></tr><tr><td><strong>HINT 指令</strong></td><td>强制干预优化器</td><td><code>/*+ INDEX(idx_name) */</code></td></tr></tbody></table><p><strong>成本估算模型</strong></p><p>优化器主要计算：</p><ul><li><strong>I/O 成本</strong>：读取数据页的代价</li><li><strong>CPU 成本</strong>：处理数据的计算代价</li><li><strong>内存成本</strong>：排序/临时表消耗</li></ul><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-plaintext"><span class="line"><span>总成本 = （数据页读取数 × 单页 I/O 成本）</span></span>
<span class="line"><span>       + （扫描行数 × 行 CPU 处理成本）</span></span>
<span class="line"><span>       + （排序行数 × 排序成本）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查看和干预执行计划</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查看执行计划</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">EXPLAIN </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 强制使用索引（慎用）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> /*+ INDEX(users idx_age) */</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 更新统计信息</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ANALYZE </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>常见执行计划问题</strong></p><ul><li><p><strong>索引失效</strong>：函数计算、隐式类型转换</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 反例：索引失效</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> YEAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(create_time) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2023</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>错误 JOIN 顺序</strong>：解决方案：使用<code>STRAIGHT_JOIN</code>强制顺序</p></li><li><p><strong>临时表/文件排序</strong>：关注<code>EXPLAIN</code>中的<code>Using temporary</code>/<code>Using filesort</code></p></li></ul><p><strong>优化建议</strong></p><ul><li>定期<code>ANALYZE TABLE</code>更新统计信息</li><li>避免在索引列上使用函数</li><li>使用覆盖索引减少回表</li><li>监控<code>performance_schema</code>中的 SQL 执行历史</li></ul><blockquote><p><strong>注意</strong>：MySQL 8.0 引入直方图统计（<code>histogram</code>）和代价模型改进，大幅提升复杂查询的计划准确性。</p></blockquote><h2 id="mysql-优化" tabindex="-1"><a class="header-anchor" href="#mysql-优化"><span>MySQL 优化</span></a></h2><h3 id="【简单】如何发现慢-sql" tabindex="-1"><a class="header-anchor" href="#【简单】如何发现慢-sql"><span>【简单】如何发现慢 SQL？</span></a></h3><p>慢 SQL 的监控主要通过两个途径：</p><ul><li><strong>慢查询日志</strong>：开启 MySQL 的慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</li><li><strong>服务监控</strong>：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。</li></ul><h3 id="【简单】什么是执行计划-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】什么是执行计划-⭐⭐"><span>【简单】什么是执行计划？⭐⭐</span></a></h3><p><strong>“执行计划”是对 SQL 查询语句在数据库中执行过程的描述</strong>。 如果要分析某条 SQL 的性能问题，通常需要先查看 SQL 的执行计划，排查每一步 SQL 执行是否存在问题。</p><p>很多数据库都支持执行计划，MySQL 也不例外。在 MySQL 中，用户可以通过 <code>EXPLAIN</code> 命令查看优化器针对指定 SQL 生成的逻辑执行计划。</p><p>【示例】MySQL 执行计划示例</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysql</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user_info </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*************************** </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">row</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ***************************</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">           id: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  select_type: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SIMPLE</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: user_info</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   partitions: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NULL</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: const</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">possible_keys: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">PRIMARY</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">          key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">PRIMARY</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      key_len: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          ref: const</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         rows</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     filtered: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Extra: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">NULL</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> row</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> warning (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行计划返回结果参数说明：</p><ul><li><code>id</code> - SELECT 查询的标识符。每个 <code>SELECT</code> 都会自动分配一个唯一的标识符。</li><li><code>select_type</code> - <code>SELECT</code> 查询的类型。 <ul><li><code>SIMPLE</code> - 表示此查询不包含 <code>UNION</code> 查询或子查询。</li><li><code>PRIMARY</code> - 表示此查询是最外层的查询。</li><li><code>UNION</code> - 表示此查询是 <code>UNION</code> 的第二或随后的查询。</li><li><code>DEPENDENT UNION</code> - <code>UNION</code> 中的第二个或后面的查询语句，取决于外面的查询。</li><li><code>UNION RESULT</code> - <code>UNION</code> 的结果。</li><li><code>SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>。</li><li><code>DEPENDENT SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>, 取决于外面的查询。即子查询依赖于外层查询的结果。</li></ul></li><li><code>table</code> - 查询的是哪个表，如果给表起别名了，则显示别名。</li><li><code>partitions</code> - 匹配的分区。</li><li><code>type</code> - 表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标。执行效率由高到低依次为： <ul><li><code>system</code>/<code>const</code> - 表中只有一行数据匹配。此时根据索引查询一次就能找到对应的数据。如果是 B+ 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。<code>const</code> 表示此时索引在第一层，只需访问一层便能得到数据。</li><li><code>eq_ref</code> - 使用唯一索引扫描。常见于多表连接中使用主键和唯一索引作为关联条件。</li><li><code>ref</code> - 非唯一索引扫描。还可见于唯一索引最左原则匹配扫描。</li><li><code>range</code> - 索引范围扫描。比如 <code>&lt;</code>，<code>&gt;</code>，<code>between</code> 等操作。</li><li><code>index</code> - 索引全表扫描。此时遍历整个索引树。</li><li><code>ALL</code> - 表示全表扫描。需要遍历全表来找到对应的行。</li></ul></li><li><code>possible_keys</code> - 此次查询中可能选用的索引。</li><li><code>key</code> - 此次查询中实际使用的索引。如果这一项为 <code>NULL</code>，说明没有使用索引。</li><li><code>ref</code> - 哪个字段或常数与 key 一起被使用。</li><li><code>rows</code> - 显示此查询一共扫描了多少行，这个是一个估计值。</li><li><code>filtered</code> - 表示此查询条件所过滤的数据的百分比。</li><li><code>extra</code> - 额外的信息。 <ul><li><code>Using index</code> - 使用覆盖索引，无需回表。</li><li><code>Using where</code> - 服务器在存储引擎检索后过滤。</li><li><code>Using temporary</code> - 使用临时表。MySQL 在对查询结果排序时使用临时表，常见于排序 <code>ORDER BY</code> 和分组查询 <code>GROUP BY</code>。效率低，要避免这种问题的出现。</li><li><code>Using filesort</code> - 额外排序。无法利用索引完成排序时，就不得不将查询匹配数据进行排序，甚至可能会通过文件进行排序，效率很低。</li><li><code>Using join buffer</code> - 使用连接缓冲</li></ul></li></ul><blockquote><p>更多内容请参考：<a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener noreferrer">MySQL 性能优化神器 Explain 使用分析</a></p></blockquote><h3 id="【简单】如何分析执行计划-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#【简单】如何分析执行计划-⭐⭐⭐"><span>【简单】如何分析执行计划？⭐⭐⭐</span></a></h3><p><strong>执行计划关键字段</strong></p><ul><li><strong><code>type</code></strong>：按性能从高到低排序：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code>。目标应尽可能避免 <code>ALL</code>（全表扫描）。</li><li><strong><code>possible_keys</code></strong>：可能使用的索引。</li><li><strong><code>key</code></strong>：实际使用的索引。</li><li><strong><code>rows</code></strong>：预估需要检查的行数，值越小越好。</li><li><strong><code>Extra</code></strong>：包含重要补充信息。</li></ul><p><strong>执行计划分析步骤</strong>：</p><ol><li>查看 <code>type</code> - 确保访问类型为 <code>const</code> 、 <code>eq_ref</code> 、 <code>ref</code> 或 <code>range</code> ，避免 <code>ALL</code> 。</li><li>查看 <code>key</code> - 确认是否使用了合适的索引。若 <code>key</code> 为 <code>NULL</code> 表示未使用索引，需优化。</li><li>查看 <code>rows</code> - 扫描的行数越少越好。</li><li>查看 <code>Extra</code> - 避免 <code>Using temporary</code>（使用临时表） 和 <code>Using filesort</code> （额外排序）。</li></ol><p>对应优化：</p><ul><li>如果 <code>type</code> 为 <code>ALL</code>，考虑为 <code>WHERE</code> 条件列添加索引。</li><li>如果 <code>Extra</code> 包含 <code>Using filesort</code> ，优化 <code>ORDER BY</code> 或 <code>GROUP BY</code> 。</li><li>如果 <code>rows</code> 过大，检查索引是否有效。</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/c6791737c73220b41941d008aa6d5998.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="【中等】如何优化-sql-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】如何优化-sql-⭐⭐"><span>【中等】如何优化 SQL？⭐⭐</span></a></h3><div class="hint-container info"><p class="hint-container-title">避免不必要的列</p></div><p>这个是老生常谈，但还是经常会出的情况，SQL 查询的时候，应该只查询需要的列，而不要包含额外的列，像<code>slect *</code> 这种写法应该尽量避免。</p><div class="hint-container info"><p class="hint-container-title">分页优化</p></div><p>在数据量比较大，分页比较深的情况下，需要考虑分页的优化。</p><p>例如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> level</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 9</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> order by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">asc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> limit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 190289</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>优化方案：</p><ul><li><strong>延迟关联</strong></li></ul><p>先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行</p><p>例如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a.* </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> level</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 9</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> order by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">asc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> limit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 190289</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ) b</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">id</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>书签方式</strong></li></ul><p>书签方式就是找到 limit 第一个参数对应的主键值，根据这个主键值再去过滤并 limit</p><p>例如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> level</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 9</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> order by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">asc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> limit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 190</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">索引优化</p></div><p>合理地设计和使用索引，是优化慢 SQL 的利器。</p><p><strong>利用覆盖索引</strong></p><p>InnoDB 使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p><p>例如对于如下查询：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> city</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;上海&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">alter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_city_name (city, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>低版本避免使用 or 查询</strong></p><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p><p><strong>避免使用 != 或者 &lt;&gt; 操作符</strong></p><p>SQL 中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p><p>解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描</p><p>例如，把<code>column&lt;&gt;’aaa’，改成 column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p><p><strong>适当使用前缀索引</strong></p><p>适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。</p><p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">alter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index2(email(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>PS: 需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引做 order by 和 group by 操作，也无法作为覆盖索引</p><p><strong>避免列上函数运算</strong></p><p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id + </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> month</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(updateTime) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>正确使用联合索引</strong></p><p>使用联合索引的时候，注意最左匹配原则。</p><div class="hint-container info"><p class="hint-container-title">JOIN 优化</p></div><p><strong>优化子查询</strong></p><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p><p><strong>小表驱动大表</strong></p><p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL 内部会遍历驱动表，再去连接被驱动表。</p><p>比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> select</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> A </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">left join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> B ;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>适当增加冗余字段</strong></p><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p><p><strong>避免使用 JOIN 关联太多的表</strong></p><p>《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。</p><p>如果不可避免要 join 多张表，可以考虑使用数据异构的方式异构到 ES 中查询。</p><div class="hint-container info"><p class="hint-container-title">排序优化</p></div><p><strong>利用索引扫描做排序</strong></p><p>MySQL 有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p><p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢</p><p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p><p>例如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--建立索引（date,staff_id,customer_id）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> staff_id, customer_id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> test </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> date</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;2010-01-01&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> order by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> staff_id,customer_id;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p><p><strong>条件下推</strong></p><p>MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引</p><p>最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化</p><p>此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高。</p><h3 id="【中等】mysql-中如何解决深分页问题-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】mysql-中如何解决深分页问题-⭐⭐"><span>【中等】MySQL 中如何解决深分页问题？⭐⭐</span></a></h3><p>深分页 (Deep Pagination) 是指当数据量很大时，查询靠后的分页数据（比如第 1000 页）性能急剧下降的问题。</p><p>解决方案有以下几种：</p><p>（1）<strong>使用索引覆盖+延迟关联</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 原始深分页查询（性能差）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 优化后的查询</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INNER JOIN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tmp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">USING</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(id);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）<strong>使用游标分页</strong>（记录上一页最后一条记录）</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第一页</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 获取上一页最后一条记录的 id=12345</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 下一页查询</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 12345</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）<strong>使用子查询优化</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> large_table </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="【中等】哪种-count-性能最好-⭐⭐" tabindex="-1"><a class="header-anchor" href="#【中等】哪种-count-性能最好-⭐⭐"><span>【中等】哪种 COUNT 性能最好？⭐⭐</span></a></h3><p>先说结论：<strong>按照效率排序的话，<code>COUNT（字段）</code> &lt; <code>COUNT（主键 id)</code> &lt; <code>COUNT(1)</code> ≈ <code>COUNT(*)</code></strong>。<strong>推荐采用 <code>COUNT(*)</code></strong> 。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/7987b9c75e90c4e61ab5f9e65a190c4e.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>对于 <code>COUNT（主键 id)</code> 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p><p><strong>对于 <code>COUNT(1)</code> 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，<code>COUNT(1)</code> 执行得要比 <code>COUNT（主键 id)</code> 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于 <code>COUNT（字段）</code> 来说</strong>：</p><ul><li>如果这个“字段”是定义为 <code>not null</code> 的话，一行行地从记录里面读出这个字段，判断不能为 <code>null</code>，按行累加；</li><li>如果这个“字段”定义允许为 <code>null</code>，那么执行的时候，判断到有可能是 <code>null</code>，还要把值取出来再判断一下，不是 <code>null</code> 才累加。</li></ul><p><strong>但是 <code>COUNT(*)</code> 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。<code>COUNT(*)</code> 肯定不是 <code>null</code>，按行累加。</p><blockquote><p>InnoDB 和 MyISAM 的 <code>count(*)</code> 实现方式有什么区别？</p></blockquote><p>不同的 MySQL 引擎中，<code>COUNT(*)</code> 有不同的实现方式：</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>COUNT(*)</code> 的时候会直接返回这个数，效率很高；</li><li>而 InnoDB 引擎就麻烦了，它执行 <code>COUNT(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><blockquote><p>为什么 InnoDB 不跟 MyISAM 一样，也维护一个计数器？</p></blockquote><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 <code>COUNT(*)</code> 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。</p><ul><li>MyISAM 表虽然 <code>COUNT(*)</code> 很快，但是不支持事务；</li><li><code>show table status</code> 命令虽然返回很快，但是不准确；</li><li>InnoDB 表直接 <code>COUNT(*)</code> 会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><blockquote><p>如何优化查询计数？</p></blockquote><ul><li>可以使用 Redis 保存计数，但存在数据丢失和逻辑不一致的问题。</li><li>可以使用数据库其他表保存计数，利用事务的原子性和隔离性，可以避免数据丢失和逻辑不一致的问题。</li></ul><h3 id="【困难】mysql-如何性能优化" tabindex="-1"><a class="header-anchor" href="#【困难】mysql-如何性能优化"><span>【困难】MySQL 如何性能优化？</span></a></h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/dd2015bbcb6b92ee5f28e9309cb60306.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="读写分离" tabindex="-1"><a class="header-anchor" href="#读写分离"><span>读写分离</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><p>参考：<a href="https://dunwu.github.io/waterdrop/pages/ed2c687e/#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" target="_blank" rel="noopener noreferrer">分布式存储面试#读写分离</a></p></div><h2 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表"><span>分库分表</span></a></h2><div class="hint-container tip"><p class="hint-container-title">扩展</p><p>参考：<a href="https://dunwu.github.io/waterdrop/pages/ed2c687e/#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8" target="_blank" rel="noopener noreferrer">分布式存储面试#分库分表</a></p></div>`,353))])}const u=r(g,[["render",c]]),b=JSON.parse('{"path":"/pages/2379811c/","title":"MySQL 面试","lang":"zh-CN","frontmatter":{"icon":"logos:mysql","title":"MySQL 面试","cover":"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/020ab2bf4af8401590e0291a34f873f8.jpg","date":"2020-09-12T10:43:53.000Z","categories":["数据库","关系型数据库","MySQL"],"tags":["数据库","关系型数据库","MySQL","面试"],"permalink":"/pages/2379811c/","description":"MySQL 面试 扩展 《高性能 MySQL》 极客时间教程 - MySQL 实战 45 讲 图解 MySQL 介绍 《SQL 必知必会》 - SQL 的基本概念和语法【入门】 《MySQL 必知必会》 - MySQL 的基本概念和语法【入门】 SQL 扩展 《SQL 必知必会》 - SQL 的基本概念和语法【入门】 《MySQL 必知必会》 - My...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 面试\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2024/10/5001644c5874419d983278ad9bdecc6d.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/0ec4cd12de163599145889e17b25bf97.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/sql-join.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/91b303efe57c805f363da2ec6bcf526f.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/0a682886e08640e2a99db61fc0eb9ec9.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/62d5206d48503343590200ddd8b9cfd0.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2023/11/4dbec2a86c464e16a3ff4d462becd077.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/061066cc08d4c4a0714094e60adff7eb.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/8d46210ed8cde0f0744e3899216c58e4.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2023/11/b2995714d7774039899d5aa0d446891c.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/0865f0eedb05b7b625c67ce41bdb78d9.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/fc628018902cb3853fc7e10fce082e0b.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/06/710bd42c250f49ada0796d8a59d976b0.jpg\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2024/10/702667178a274a67ac92bc333a0ffbfd.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/07/1d5a380080ae4a8e8a6ab59701ba0c2a.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2022/07/40b5efca71a04ddfa9a9d659d808f32a.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/c6791737c73220b41941d008aa6d5998.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/7987b9c75e90c4e61ab5f9e65a190c4e.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2026/02/dd2015bbcb6b92ee5f28e9309cb60306.jpg\\"],\\"datePublished\\":\\"2020-09-12T10:43:53.000Z\\",\\"dateModified\\":\\"2026-02-25T15:49:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/2379811c/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"MySQL 面试"}],["meta",{"property":"og:description","content":"MySQL 面试 扩展 《高性能 MySQL》 极客时间教程 - MySQL 实战 45 讲 图解 MySQL 介绍 《SQL 必知必会》 - SQL 的基本概念和语法【入门】 《MySQL 必知必会》 - MySQL 的基本概念和语法【入门】 SQL 扩展 《SQL 必知必会》 - SQL 的基本概念和语法【入门】 《MySQL 必知必会》 - My..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/020ab2bf4af8401590e0291a34f873f8.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-25T15:49:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/03/020ab2bf4af8401590e0291a34f873f8.jpg"}],["meta",{"name":"twitter:image:alt","content":"MySQL 面试"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"关系型数据库"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2020-09-12T10:43:53.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-25T15:49:24.000Z"}]]},"git":{"createdTime":1697125600000,"updatedTime":1772034564000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":29,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":53.01,"words":15903},"filePathRelative":"12.数据库/关系型数据库/MySQL/MySQL_面试.md","excerpt":"\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">扩展</p>\\n<ul>\\n<li><a href=\\"https://book.douban.com/subject/23008813/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《高性能 MySQL》</a></li>\\n<li><a href=\\"https://time.geekbang.org/column/intro/139\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">极客时间教程 - MySQL 实战 45 讲</a></li>\\n<li><a href=\\"https://xiaolincoding.com/mysql/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">图解 MySQL 介绍</a></li>\\n<li><a href=\\"https://book.douban.com/subject/35167240/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《SQL 必知必会》</a> - SQL 的基本概念和语法【入门】</li>\\n<li><a href=\\"https://book.douban.com/subject/3354490/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《MySQL 必知必会》</a> - MySQL 的基本概念和语法【入门】</li>\\n</ul>\\n</div>","autoDesc":true}');export{u as comp,b as data};
