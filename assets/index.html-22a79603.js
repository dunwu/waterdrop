const l=JSON.parse('{"key":"v-44492f02","path":"/pages/62e44ef3/","title":"Dubbo 面试之架构","lang":"zh-CN","frontmatter":{"title":"Dubbo 面试之架构","date":"2024-12-12T08:18:57.000Z","permalink":"/pages/62e44ef3/","category":["分布式","分布式通信","RPC"],"tag":["分布式","通信","RPC","微服务","Dubbo","面试"],"description":"Dubbo 面试之架构 调用流程 【简单】Dubbo 支持哪些序列化方式？ Hessian（默认） 特点：二进制格式，速度较快，体积较小 适用场景：通用 RPC 调用（Dubbo 默认方案） 缺点：对复杂对象支持有限 JSON 特点：文本格式，可读性强，跨语言支持好 适用场景：前后端交互、多语言系统 缺点：性能较差，数据体积大 Java 原生序列化 特点：JDK 内置，使用简单 适用场景：Java 单体应用调试 缺点：性能差，体积大，仅限 Java Kryo 特点：高性能二进制，速度极快，体积小 适用场景：高并发、低延迟场景 缺点：API 复杂，需注册类 Protobuf（推荐） 特点：Google 出品，高效跨语言，可扩展 适用场景：微服务跨语言通信 缺点：需预定义。proto 文件 FST 特点：类似 Kryo，高性能二进制 适用场景：替代 Hessian 的高性能需求 缺点：兼容性较弱","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/62e44ef3/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Dubbo 面试之架构"}],["meta",{"property":"og:description","content":"Dubbo 面试之架构 调用流程 【简单】Dubbo 支持哪些序列化方式？ Hessian（默认） 特点：二进制格式，速度较快，体积较小 适用场景：通用 RPC 调用（Dubbo 默认方案） 缺点：对复杂对象支持有限 JSON 特点：文本格式，可读性强，跨语言支持好 适用场景：前后端交互、多语言系统 缺点：性能较差，数据体积大 Java 原生序列化 特点：JDK 内置，使用简单 适用场景：Java 单体应用调试 缺点：性能差，体积大，仅限 Java Kryo 特点：高性能二进制，速度极快，体积小 适用场景：高并发、低延迟场景 缺点：API 复杂，需注册类 Protobuf（推荐） 特点：Google 出品，高效跨语言，可扩展 适用场景：微服务跨语言通信 缺点：需预定义。proto 文件 FST 特点：类似 Kryo，高性能二进制 适用场景：替代 Hessian 的高性能需求 缺点：兼容性较弱"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-13T09:46:18.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"通信"}],["meta",{"property":"article:tag","content":"RPC"}],["meta",{"property":"article:tag","content":"微服务"}],["meta",{"property":"article:tag","content":"Dubbo"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:published_time","content":"2024-12-12T08:18:57.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-13T09:46:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dubbo 面试之架构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-12T08:18:57.000Z\\",\\"dateModified\\":\\"2025-09-13T09:46:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"调用流程","slug":"调用流程","link":"#调用流程","children":[{"level":3,"title":"【简单】Dubbo 支持哪些序列化方式？","slug":"【简单】dubbo-支持哪些序列化方式","link":"#【简单】dubbo-支持哪些序列化方式","children":[]},{"level":3,"title":"【简单】Dubbo 支持哪些通信协议？","slug":"【简单】dubbo-支持哪些通信协议","link":"#【简单】dubbo-支持哪些通信协议","children":[]},{"level":3,"title":"【困难】动态代理在 Dubbo 中有哪些应用？","slug":"【困难】动态代理在-dubbo-中有哪些应用","link":"#【困难】动态代理在-dubbo-中有哪些应用","children":[]}]},{"level":2,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[{"level":3,"title":"【中等】Dubbo 的工作原理是什么？","slug":"【中等】dubbo-的工作原理是什么","link":"#【中等】dubbo-的工作原理是什么","children":[]},{"level":3,"title":"【简单】Dubbo 有哪些核心组件？","slug":"【简单】dubbo-有哪些核心组件","link":"#【简单】dubbo-有哪些核心组件","children":[]},{"level":3,"title":"【困难】Dubbo 框架整体如何设计的？","slug":"【困难】dubbo-框架整体如何设计的","link":"#【困难】dubbo-框架整体如何设计的","children":[]},{"level":3,"title":"【中等】Dubbo 中用到哪些设计模式？","slug":"【中等】dubbo-中用到哪些设计模式","link":"#【中等】dubbo-中用到哪些设计模式","children":[]}]},{"level":2,"title":"可用性设计","slug":"可用性设计","link":"#可用性设计","children":[{"level":3,"title":"【困难】Dubbo 如何保证服务的高可用性？","slug":"【困难】dubbo-如何保证服务的高可用性","link":"#【困难】dubbo-如何保证服务的高可用性","children":[]}]},{"level":2,"title":"性能优化设计","slug":"性能优化设计","link":"#性能优化设计","children":[{"level":3,"title":"【困难】Dubbo 有哪些性能优化设计？","slug":"【困难】dubbo-有哪些性能优化设计","link":"#【困难】dubbo-有哪些性能优化设计","children":[]},{"level":3,"title":"【中等】Dubbo 如何支持异步调用？","slug":"【中等】dubbo-如何支持异步调用","link":"#【中等】dubbo-如何支持异步调用","children":[]},{"level":3,"title":"【困难】Dubbo 中的线程模型是如何设计的？","slug":"【困难】dubbo-中的线程模型是如何设计的","link":"#【困难】dubbo-中的线程模型是如何设计的","children":[]},{"level":3,"title":"【中等】Dubbo 中的连接数过多如何处理？","slug":"【中等】dubbo-中的连接数过多如何处理","link":"#【中等】dubbo-中的连接数过多如何处理","children":[]},{"level":3,"title":"【困难】Dubbo 中的时钟轮机制是如何设计的？","slug":"【困难】dubbo-中的时钟轮机制是如何设计的","link":"#【困难】dubbo-中的时钟轮机制是如何设计的","children":[]}]},{"level":2,"title":"扩展性设计","slug":"扩展性设计","link":"#扩展性设计","children":[{"level":3,"title":"【困难】Dubbo 架构是如何实现高度可扩展的？","slug":"【困难】dubbo-架构是如何实现高度可扩展的","link":"#【困难】dubbo-架构是如何实现高度可扩展的","children":[]},{"level":3,"title":"【中等】如何自定义一个 Dubbo 的 SPI 扩展？","slug":"【中等】如何自定义一个-dubbo-的-spi-扩展","link":"#【中等】如何自定义一个-dubbo-的-spi-扩展","children":[]},{"level":3,"title":"【困难】Dubbo 的 SPI 机制是如何设计的？","slug":"【困难】dubbo-的-spi-机制是如何设计的","link":"#【困难】dubbo-的-spi-机制是如何设计的","children":[]},{"level":3,"title":"【中等】什么是 Dubbo 的 Filter 机制？","slug":"【中等】什么是-dubbo-的-filter-机制","link":"#【中等】什么是-dubbo-的-filter-机制","children":[]}]},{"level":2,"title":"分布式特性","slug":"分布式特性","link":"#分布式特性","children":[{"level":3,"title":"【困难】Dubbo 中如何实现分布式事务？","slug":"【困难】dubbo-中如何实现分布式事务","link":"#【困难】dubbo-中如何实现分布式事务","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1748532635000,"updatedTime":1757756778000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":3}]},"readingTime":{"minutes":44.8,"words":13440},"filePathRelative":"15.分布式/21.分布式通信/01.RPC/Dubbo_面试_架构.md","localizedDate":"2024年12月12日","excerpt":"<h1> Dubbo 面试之架构</h1>\\n<h2> 调用流程</h2>\\n<h3> 【简单】Dubbo 支持哪些序列化方式？</h3>\\n<ul>\\n<li><strong>Hessian（默认）</strong>\\n<ul>\\n<li><strong>特点</strong>：二进制格式，速度较快，体积较小</li>\\n<li><strong>适用场景</strong>：通用 RPC 调用（Dubbo 默认方案）</li>\\n<li><strong>缺点</strong>：对复杂对象支持有限</li>\\n</ul>\\n</li>\\n<li><strong>JSON</strong>\\n<ul>\\n<li><strong>特点</strong>：文本格式，可读性强，跨语言支持好</li>\\n<li><strong>适用场景</strong>：前后端交互、多语言系统</li>\\n<li><strong>缺点</strong>：性能较差，数据体积大</li>\\n</ul>\\n</li>\\n<li><strong>Java 原生序列化</strong>\\n<ul>\\n<li><strong>特点</strong>：JDK 内置，使用简单</li>\\n<li><strong>适用场景</strong>：Java 单体应用调试</li>\\n<li><strong>缺点</strong>：性能差，体积大，仅限 Java</li>\\n</ul>\\n</li>\\n<li><strong>Kryo</strong>\\n<ul>\\n<li><strong>特点</strong>：高性能二进制，速度极快，体积小</li>\\n<li><strong>适用场景</strong>：高并发、低延迟场景</li>\\n<li><strong>缺点</strong>：API 复杂，需注册类</li>\\n</ul>\\n</li>\\n<li><strong>Protobuf（推荐）</strong>\\n<ul>\\n<li><strong>特点</strong>：Google 出品，高效跨语言，可扩展</li>\\n<li><strong>适用场景</strong>：微服务跨语言通信</li>\\n<li><strong>缺点</strong>：需预定义。proto 文件</li>\\n</ul>\\n</li>\\n<li><strong>FST</strong>\\n<ul>\\n<li><strong>特点</strong>：类似 Kryo，高性能二进制</li>\\n<li><strong>适用场景</strong>：替代 Hessian 的高性能需求</li>\\n<li><strong>缺点</strong>：兼容性较弱</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
