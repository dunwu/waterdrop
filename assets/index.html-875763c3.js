const e=JSON.parse('{"key":"v-908a2912","path":"/pages/667f5956/","title":"Java 虚拟机面试二","lang":"zh-CN","frontmatter":{"title":"Java 虚拟机面试二","date":"2025-04-30T06:33:26.000Z","order":11,"permalink":"/pages/667f5956/","category":["Java","JavaCore","面试"],"tag":["Java","JavaCore","面试","JVM"],"description":"Java 虚拟机面试二 垃圾收集 【困难】如何判断 Java 对象是否可以被回收？ 判断 Java 对象是否可以被回收有两种方法： 引用计数法 可达性分析法 引用计数法 引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 引用计数算法简单高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/667f5956/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 虚拟机面试二"}],["meta",{"property":"og:description","content":"Java 虚拟机面试二 垃圾收集 【困难】如何判断 Java 对象是否可以被回收？ 判断 Java 对象是否可以被回收有两种方法： 引用计数法 可达性分析法 引用计数法 引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 引用计数算法简单高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-15T23:50:15.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2025-04-30T06:33:26.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-15T23:50:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 虚拟机面试二\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-30T06:33:26.000Z\\",\\"dateModified\\":\\"2025-09-15T23:50:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"垃圾收集","slug":"垃圾收集","link":"#垃圾收集","children":[{"level":3,"title":"【困难】如何判断 Java 对象是否可以被回收？","slug":"【困难】如何判断-java-对象是否可以被回收","link":"#【困难】如何判断-java-对象是否可以被回收","children":[]},{"level":3,"title":"【中等】为什么不建议使用 finalize()？","slug":"【中等】为什么不建议使用-finalize","link":"#【中等】为什么不建议使用-finalize","children":[]},{"level":3,"title":"【中等】Java 对象有哪些引用类型？","slug":"【中等】java-对象有哪些引用类型","link":"#【中等】java-对象有哪些引用类型","children":[]},{"level":3,"title":"【中等】Java 中有哪些垃圾回收算法？","slug":"【中等】java-中有哪些垃圾回收算法","link":"#【中等】java-中有哪些垃圾回收算法","children":[]},{"level":3,"title":"【中等】Java 中常见的垃圾收集器有哪些？","slug":"【中等】java-中常见的垃圾收集器有哪些","link":"#【中等】java-中常见的垃圾收集器有哪些","children":[]},{"level":3,"title":"【困难】为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？","slug":"【困难】为什么-java-8-移除了永久代-permgen-并引入了元空间-metaspace","link":"#【困难】为什么-java-8-移除了永久代-permgen-并引入了元空间-metaspace","children":[]},{"level":3,"title":"【困难】Java 中的 Young GC、Old GC、Full GC 和 Mixed GC 的区别是什么？","slug":"【困难】java-中的-young-gc、old-gc、full-gc-和-mixed-gc-的区别是什么","link":"#【困难】java-中的-young-gc、old-gc、full-gc-和-mixed-gc-的区别是什么","children":[]},{"level":3,"title":"【困难】Java 的 CMS 垃圾回收流程是怎样的？","slug":"【困难】java-的-cms-垃圾回收流程是怎样的","link":"#【困难】java-的-cms-垃圾回收流程是怎样的","children":[]},{"level":3,"title":"【困难】Java 的 G1 垃圾回收流程是怎样的？","slug":"【困难】java-的-g1-垃圾回收流程是怎样的","link":"#【困难】java-的-g1-垃圾回收流程是怎样的","children":[]},{"level":3,"title":"【困难】Java 的 ZGC 垃圾回收流程是怎样的？","slug":"【困难】java-的-zgc-垃圾回收流程是怎样的","link":"#【困难】java-的-zgc-垃圾回收流程是怎样的","children":[]},{"level":3,"title":"【困难】JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？","slug":"【困难】jvm-垃圾回收时产生的-concurrent-mode-failure-的原因是什么","link":"#【困难】jvm-垃圾回收时产生的-concurrent-mode-failure-的原因是什么","children":[]}]}],"git":{"createdTime":1757980215000,"updatedTime":1757980215000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":22.3,"words":6689},"filePathRelative":"01.Java/JavaCore/面试/Java_面试_虚拟机（二）.md","localizedDate":"2025年4月30日","excerpt":"<h1> Java 虚拟机面试二</h1>\\n<h2> 垃圾收集</h2>\\n<h3> 【困难】如何判断 Java 对象是否可以被回收？</h3>\\n<p>判断 Java 对象是否可以被回收有两种方法：</p>\\n<ul>\\n<li>引用计数法</li>\\n<li>可达性分析法</li>\\n</ul>\\n<h4> 引用计数法</h4>\\n<p>引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>\\n<p>引用计数算法<strong>简单高效</strong>，但是<strong>存在循环引用问题</strong>——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>","autoDesc":true}');export{e as data};
