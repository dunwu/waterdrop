import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as t}from"./app-PnIX1L9C.js";const l={};function s(r,a){return t(),i("div",null,[...a[0]||(a[0]=[n('<h1 id="《极客时间教程-深入浅出-java-虚拟机》笔记" tabindex="-1"><a class="header-anchor" href="#《极客时间教程-深入浅出-java-虚拟机》笔记"><span>《极客时间教程 - 深入浅出 Java 虚拟机》笔记</span></a></h1><h2 id="开篇词-jvm-一块难啃的骨头" tabindex="-1"><a class="header-anchor" href="#开篇词-jvm-一块难啃的骨头"><span>开篇词：JVM，一块难啃的骨头</span></a></h2><p>略</p><h2 id="一探究竟-为什么需要-jvm-它处在什么位置" tabindex="-1"><a class="header-anchor" href="#一探究竟-为什么需要-jvm-它处在什么位置"><span>一探究竟：为什么需要 JVM？它处在什么位置？</span></a></h2><p><strong>JVM</strong> - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 <code>*.java</code> 文件编译为 JVM 可理解的 <code>*.class</code> 文件（字节码）。Java 有一句著名的口号：“Write Once, Run Anywhere（一次编写，随处运行）”，JVM 正是其核心所在。实际上，JVM 针对不同的系统（Windows、Linux、MacOS）有不同的实现，目的在于用相同的字节码执行同样的结果。</p><p><strong>JRE</strong> - Java Runtime Environment 的缩写，即 Java 运行时环境。它是运行已编译 Java 程序所需的一切的软件包，主要包括 JVM、Java 类库（Class Library）、Java 命令和其他基础结构。但是，它不能用于创建新程序。</p><p><strong>JDK</strong> - Java Development Kit 的缩写，即 Java SDK。它不仅包含 JRE 的所有功能，还包含编译器 (javac) 和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><blockquote><p>总结来说，JDK、JRE、JVM 三者的关系是：JDK &gt; JRE &gt; JVM</p><p><strong>JDK = JRE + 开发/调试工具</strong></p><p><strong>JRE = JVM + Java 类库 + Java 运行库</strong></p><p><strong>JVM = 类加载系统 + 运行时内存区域 + 执行引擎</strong></p></blockquote><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/archive/2025/04/1713e34f9ed8477a8faf3feeb2d00335.png" alt="enter image description here" tabindex="0" loading="lazy"><figcaption>enter image description here</figcaption></figure><blockquote><p>摘自 <a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre" target="_blank" rel="noopener noreferrer">stackoverflow 高票问题 - What is the difference between JDK and JRE?</a></p></blockquote><h2 id="大厂面试题-你不得不掌握的-jvm-内存管理" tabindex="-1"><a class="header-anchor" href="#大厂面试题-你不得不掌握的-jvm-内存管理"><span>大厂面试题：你不得不掌握的 JVM 内存管理</span></a></h2><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4VrjWAPqAuAARqnz6cigo666.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4VrjaANruFAAQKxZvgfSs652.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4VrjaAIlgaAAJKReuKXII670.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="大厂面试题-从覆盖-jdk-的类开始掌握类的加载机制" tabindex="-1"><a class="header-anchor" href="#大厂面试题-从覆盖-jdk-的类开始掌握类的加载机制"><span>大厂面试题：从覆盖 JDK 的类开始掌握类的加载机制</span></a></h2><p>Java 类的完整生命周期包括以下几个阶段：</p><ul><li><strong>加载（Loading）</strong> - 将 _.java 文件转为 _.class</li><li><strong>链接（Linking）</strong><ul><li><strong>验证（Verification）</strong> - 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求</li><li><strong>准备（Preparation）</strong> - 为 static 变量在方法区分配内存并初始化为默认值</li><li><strong>解析（Resolution）</strong> - 将常量池的符号引用替换为直接引用的过程</li></ul></li><li><strong>初始化（Initialization）</strong> - 为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化</li></ul><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/CgqCHl9ZjveAemjoAAB4J1dCVDo17.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>类加载器</p><ul><li><p>Bootstrap ClassLoader - 负责加载 <code>&lt;JAVA_HOME&gt;\\lib</code> 或被 <code>-Xbootclasspath</code> 指定的路径</p></li><li><p>ExtClassLoader - 负责加载 <code>&lt;JAVA_HOME&gt;\\lib\\ext</code> 或被<code>java.ext.dir</code> 指定的路径</p></li><li><p>AppClassLoader - 负载加载 <code>classpath</code> 路径</p></li><li><p>自定义类加载器 - 继承自 <code>java.lang.ClassLoader</code></p></li></ul><p><strong>双亲委派机制</strong> - 除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。</p><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4cQNeAZ4FuAABzsqSozok762.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="动手实践-从栈帧看字节码是如何在-jvm-中进行流转的" tabindex="-1"><a class="header-anchor" href="#动手实践-从栈帧看字节码是如何在-jvm-中进行流转的"><span>动手实践：从栈帧看字节码是如何在 JVM 中进行流转的</span></a></h2><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/CgpOIF4ezuOAK_6bAACFY5oeX-Y174.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/CgpOIF4ezeKAHVCXAABv7rzSgXE896.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>javap - javap 是 JDK 自带的反解析工具。它的作用是将 .class 字节码文件解析成可读的文件格式。</p></li><li><p>jclasslib - jclasslib 是一个图形化的工具，能够更加直观的查看字节码中的内容。</p></li></ul><h2 id="大厂面试题-得心应手应对-oom-的疑难杂症" tabindex="-1"><a class="header-anchor" href="#大厂面试题-得心应手应对-oom-的疑难杂症"><span>大厂面试题：得心应手应对 OOM 的疑难杂症</span></a></h2><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4hefWAWKFZAAMwndGjScg437.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对象生命周期判断</p><ul><li>引用计数法</li><li>可达性分析法 - GC Roots</li></ul><p>引用类型：</p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><h2 id="深入剖析-垃圾回收你真的了解吗-上" tabindex="-1"><a class="header-anchor" href="#深入剖析-垃圾回收你真的了解吗-上"><span>深入剖析：垃圾回收你真的了解吗？（上）</span></a></h2><p>垃圾回收算法</p><ul><li>标记-复制 - 效率最高，但会浪费大量内存空间</li><li>标记-清除 - 效率一般，会产生大量内存碎片</li><li>标记-整理 - 效率最差，但是不会浪费空间，也消除了内存碎片</li></ul><p>GC 分代收集：年轻代 GC 使用标记-复制算法；老年代 GC 使用标记-清除算法、标记-整理算法。</p><p>常见 GC 收集器：</p><ul><li>年轻代：Serial、ParNew、Parallel</li><li>老年代：Serial Old、Parallel Old、CMS</li><li>元空间：G1、ZGC</li></ul><figure><img src="https://learn.lianglianglee.com/专栏/深入浅出 Java 虚拟机-完/assets/Cgq2xl4lQuiAHmINAACWihcFScA929.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>GC 收集器配置参数：</p><ul><li><strong>-XX:+UseSerialGC</strong> 年轻代和老年代都用串行收集器</li><li><strong>-XX:+UseParNewGC</strong> 年轻代使用 ParNew，老年代使用 Serial Old</li><li><strong>-XX:+UseParallelGC</strong> 年轻代使用 ParallerGC，老年代使用 Serial Old</li><li><strong>-XX:+UseParallelOldGC</strong> 新生代和老年代都使用并行收集器</li><li><strong>-XX:+UseConcMarkSweepGC</strong>，表示年轻代使用 ParNew，老年代的用 CMS</li><li><strong>-XX:+UseG1GC</strong> 使用 G1 垃圾回收器</li><li><strong>-XX:+UseZGC</strong> 使用 ZGC 垃圾回收器</li></ul><h2 id="深入剖析-垃圾回收你真的了解吗-下" tabindex="-1"><a class="header-anchor" href="#深入剖析-垃圾回收你真的了解吗-下"><span>深入剖析：垃圾回收你真的了解吗？（下）</span></a></h2><ul><li>Minor GC：发生在年轻代的 GC。</li><li>Major GC：发生在老年代的 GC。</li><li>Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。</li></ul><p>CMS 垃圾回收器分为四个阶段：</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清理</li></ol><p>CMS 中都会有哪些停顿（STW）：</p><ol><li>初始标记，这部分的停顿时间较短；</li><li>Minor GC（可选），在预处理阶段对年轻代的回收，停顿由年轻代决定；</li><li>重新标记，由于 preclaen 阶段的介入，这部分停顿也较短；</li><li>Serial-Old 收集老年代的停顿，主要发生在预留空间不足的情况下，时间会持续很长；</li><li>Full GC，永久代空间耗尽时的操作，由于会有整理阶段，持续时间较长。</li></ol><h2 id="大厂面试题-有了-g1-还需要其他垃圾回收器吗" tabindex="-1"><a class="header-anchor" href="#大厂面试题-有了-g1-还需要其他垃圾回收器吗"><span>大厂面试题：有了 G1 还需要其他垃圾回收器吗？</span></a></h2><p>G1 最重要的概念，其实就是 Region。它采用分而治之，部分收集的思想，尽力达到我们给它设定的停顿目标。</p><h2 id="案例实战-亿级流量高并发下如何进行估算和调优" tabindex="-1"><a class="header-anchor" href="#案例实战-亿级流量高并发下如何进行估算和调优"><span>案例实战：亿级流量高并发下如何进行估算和调优</span></a></h2><p>GC 指标：</p><ul><li>系统容量（Capacity）</li><li>延迟（Latency）</li><li>吞吐量（Throughput）</li></ul><p><strong>选择垃圾回收器</strong></p><ul><li>如果你的堆大小不是很大（比如 100MB），选择串行收集器一般是效率最高的。参数：-XX:+UseSerialGC。</li><li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有 1C，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。参数：-XX:+UseSerialGC。</li><li>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。参数：-XX:+UseParallelGC。</li><li>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1、ZGC、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。参数：-XX:+UseConcMarkSweepGC、-XX:+UseG1GC、-XX:+UseZGC 等。</li></ul><h2 id="第-09-讲-案例实战-面对突如其来的-gc-问题如何下手解决" tabindex="-1"><a class="header-anchor" href="#第-09-讲-案例实战-面对突如其来的-gc-问题如何下手解决"><span>第 09 讲：案例实战：面对突如其来的 GC 问题如何下手解决</span></a></h2><h2 id="第-10-讲-动手实践-自己模拟-jvm-内存溢出场景" tabindex="-1"><a class="header-anchor" href="#第-10-讲-动手实践-自己模拟-jvm-内存溢出场景"><span>第 10 讲：动手实践：自己模拟 JVM 内存溢出场景</span></a></h2><h2 id="第-11-讲-动手实践-遇到问题不要慌-轻松搞定内存泄漏" tabindex="-1"><a class="header-anchor" href="#第-11-讲-动手实践-遇到问题不要慌-轻松搞定内存泄漏"><span>第 11 讲：动手实践：遇到问题不要慌，轻松搞定内存泄漏</span></a></h2><p>jinfo、jstat、jstack、jhsdb（jmap）等是经常被使用的一些工具，尤其是 jmap，在分析处理内存泄漏问题的时候，是必须的。</p><h2 id="工具进阶-如何利用-mat-找到问题发生的根本原因" tabindex="-1"><a class="header-anchor" href="#工具进阶-如何利用-mat-找到问题发生的根本原因"><span>工具进阶：如何利用 MAT 找到问题发生的根本原因</span></a></h2><p>MAT 是用来分析内存快照的。</p><h2 id="动手实践-让面试官刮目相看的堆外内存排查" tabindex="-1"><a class="header-anchor" href="#动手实践-让面试官刮目相看的堆外内存排查"><span>动手实践：让面试官刮目相看的堆外内存排查</span></a></h2><h2 id="预警与解决-深入浅出-gc-监控与调优" tabindex="-1"><a class="header-anchor" href="#预警与解决-深入浅出-gc-监控与调优"><span>预警与解决：深入浅出 GC 监控与调优</span></a></h2><h2 id="案例分析-一个高死亡率的报表系统的优化之路" tabindex="-1"><a class="header-anchor" href="#案例分析-一个高死亡率的报表系统的优化之路"><span>案例分析：一个高死亡率的报表系统的优化之路</span></a></h2><h2 id="案例分析-分库分表后-我的应用崩溃了" tabindex="-1"><a class="header-anchor" href="#案例分析-分库分表后-我的应用崩溃了"><span>案例分析：分库分表后，我的应用崩溃了</span></a></h2><h2 id="动手实践-从字节码看方法调用的底层实现" tabindex="-1"><a class="header-anchor" href="#动手实践-从字节码看方法调用的底层实现"><span>动手实践：从字节码看方法调用的底层实现</span></a></h2><h2 id="大厂面试题-不要搞混-jmm-与-jvm" tabindex="-1"><a class="header-anchor" href="#大厂面试题-不要搞混-jmm-与-jvm"><span>大厂面试题：不要搞混 JMM 与 JVM</span></a></h2><h2 id="动手实践-从字节码看并发编程的底层实现" tabindex="-1"><a class="header-anchor" href="#动手实践-从字节码看并发编程的底层实现"><span>动手实践：从字节码看并发编程的底层实现</span></a></h2><h2 id="动手实践-不为人熟知的字节码指令" tabindex="-1"><a class="header-anchor" href="#动手实践-不为人熟知的字节码指令"><span>动手实践：不为人熟知的字节码指令</span></a></h2><h2 id="深入剖析-如何使用-java-agent-技术对字节码进行修改" tabindex="-1"><a class="header-anchor" href="#深入剖析-如何使用-java-agent-技术对字节码进行修改"><span>深入剖析：如何使用 Java Agent 技术对字节码进行修改</span></a></h2><h2 id="_23-动手实践-jit-参数配置如何影响程序运行" tabindex="-1"><a class="header-anchor" href="#_23-动手实践-jit-参数配置如何影响程序运行"><span>23 动手实践：JIT 参数配置如何影响程序运行？</span></a></h2><h2 id="案例分析-大型项目如何进行性能瓶颈调优" tabindex="-1"><a class="header-anchor" href="#案例分析-大型项目如何进行性能瓶颈调优"><span>案例分析：大型项目如何进行性能瓶颈调优？</span></a></h2><h2 id="未来-jvm-的历史与展望" tabindex="-1"><a class="header-anchor" href="#未来-jvm-的历史与展望"><span>未来：JVM 的历史与展望</span></a></h2><h2 id="福利-常见-jvm-面试题补充" tabindex="-1"><a class="header-anchor" href="#福利-常见-jvm-面试题补充"><span>福利：常见 JVM 面试题补充</span></a></h2>',73)])])}const c=e(l,[["render",s]]),g=JSON.parse('{"path":"/pages/76e8b6af/","title":"《极客时间教程 - 深入浅出 Java 虚拟机》笔记","lang":"zh-CN","frontmatter":{"title":"《极客时间教程 - 深入浅出 Java 虚拟机》笔记","date":"2024-08-06T08:00:04.000Z","order":2,"categories":["笔记","Java"],"tags":["Java","JVM"],"permalink":"/pages/76e8b6af/","description":"《极客时间教程 - 深入浅出 Java 虚拟机》笔记 开篇词：JVM，一块难啃的骨头 略 一探究竟：为什么需要 JVM？它处在什么位置？ JVM - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 *.java 文件编译为 JVM 可理...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《极客时间教程 - 深入浅出 Java 虚拟机》笔记\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/04/1713e34f9ed8477a8faf3feeb2d00335.png\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4VrjWAPqAuAARqnz6cigo666.png\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4VrjaANruFAAQKxZvgfSs652.png\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4VrjaAIlgaAAJKReuKXII670.png\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/CgqCHl9ZjveAemjoAAB4J1dCVDo17.jpeg\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4cQNeAZ4FuAABzsqSozok762.png\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/CgpOIF4ezuOAK_6bAACFY5oeX-Y174.jpg\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/CgpOIF4ezeKAHVCXAABv7rzSgXE896.jpg\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4hefWAWKFZAAMwndGjScg437.png\\",\\"https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4lQuiAHmINAACWihcFScA929.jpg\\"],\\"datePublished\\":\\"2024-08-06T08:00:04.000Z\\",\\"dateModified\\":\\"2026-02-11T15:41:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"],["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/76e8b6af/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"《极客时间教程 - 深入浅出 Java 虚拟机》笔记"}],["meta",{"property":"og:description","content":"《极客时间教程 - 深入浅出 Java 虚拟机》笔记 开篇词：JVM，一块难啃的骨头 略 一探究竟：为什么需要 JVM？它处在什么位置？ JVM - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 *.java 文件编译为 JVM 可理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/archive/2025/04/1713e34f9ed8477a8faf3feeb2d00335.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-11T15:41:54.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2024-08-06T08:00:04.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-11T15:41:54.000Z"}]]},"git":{"createdTime":1722902404000,"updatedTime":1770824514000,"contributors":[{"name":"dunwu","username":"dunwu","email":"forbreak@163.com","commits":10,"url":"https://github.com/dunwu"}]},"readingTime":{"minutes":7.61,"words":2284},"filePathRelative":"00.笔记/Java/极客时间教程-深入浅出Java虚拟机笔记.md","excerpt":"\\n<h2>开篇词：JVM，一块难啃的骨头</h2>\\n<p>略</p>\\n<h2>一探究竟：为什么需要 JVM？它处在什么位置？</h2>\\n<p><strong>JVM</strong> - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 <code>*.java</code> 文件编译为 JVM 可理解的 <code>*.class</code> 文件（字节码）。Java 有一句著名的口号：“Write Once, Run Anywhere（一次编写，随处运行）”，JVM 正是其核心所在。实际上，JVM 针对不同的系统（Windows、Linux、MacOS）有不同的实现，目的在于用相同的字节码执行同样的结果。</p>","autoDesc":true}');export{c as comp,g as data};
