const e=JSON.parse('{"key":"v-20573bfa","path":"/01.Java/01.JavaCore/99.%E9%9D%A2%E8%AF%95/Java_%E9%9D%A2%E8%AF%95_%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89.html","title":"Java 虚拟机面试二","lang":"zh-CN","frontmatter":{"title":"Java 虚拟机面试二","category":["Java","JavaCore","面试"],"tag":["Java","JavaCore","面试","JVM"],"description":"Java 虚拟机面试二 垃圾收集 【困难】如何判断 Java 对象是否可以被回收？ 判断 Java 对象是否可以被回收有两种方法： 引用计数法 可达性分析法 引用计数法 引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 引用计数算法简单高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/01.Java/01.JavaCore/99.%E9%9D%A2%E8%AF%95/Java_%E9%9D%A2%E8%AF%95_%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 虚拟机面试二"}],["meta",{"property":"og:description","content":"Java 虚拟机面试二 垃圾收集 【困难】如何判断 Java 对象是否可以被回收？ 判断 Java 对象是否可以被回收有两种方法： 引用计数法 可达性分析法 引用计数法 引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 引用计数算法简单高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T22:33:26.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:modified_time","content":"2025-04-29T22:33:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 虚拟机面试二\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-29T22:33:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"垃圾收集","slug":"垃圾收集","link":"#垃圾收集","children":[{"level":3,"title":"【困难】如何判断 Java 对象是否可以被回收？","slug":"【困难】如何判断-java-对象是否可以被回收","link":"#【困难】如何判断-java-对象是否可以被回收","children":[]},{"level":3,"title":"【中等】Java 对象有哪些引用类型？","slug":"【中等】java-对象有哪些引用类型","link":"#【中等】java-对象有哪些引用类型","children":[]},{"level":3,"title":"【中等】Java 中有哪些垃圾回收算法？","slug":"【中等】java-中有哪些垃圾回收算法","link":"#【中等】java-中有哪些垃圾回收算法","children":[]},{"level":3,"title":"【中等】Java 中常见的垃圾收集器有哪些？","slug":"【中等】java-中常见的垃圾收集器有哪些","link":"#【中等】java-中常见的垃圾收集器有哪些","children":[]},{"level":3,"title":"【中等】为什么 Java 的垃圾收集器将堆分为老年代和年轻代？","slug":"【中等】为什么-java-的垃圾收集器将堆分为老年代和年轻代","link":"#【中等】为什么-java-的垃圾收集器将堆分为老年代和年轻代","children":[]},{"level":3,"title":"【困难】为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？","slug":"【困难】为什么-java-8-移除了永久代-permgen-并引入了元空间-metaspace","link":"#【困难】为什么-java-8-移除了永久代-permgen-并引入了元空间-metaspace","children":[]},{"level":3,"title":"【困难】Java 中的 young GC、old GC、full GC 和 mixed GC 的区别是什么？","slug":"【困难】java-中的-young-gc、old-gc、full-gc-和-mixed-gc-的区别是什么","link":"#【困难】java-中的-young-gc、old-gc、full-gc-和-mixed-gc-的区别是什么","children":[]},{"level":3,"title":"【中等】什么是 Minor GC？什么情况触发？","slug":"【中等】什么是-minor-gc-什么情况触发","link":"#【中等】什么是-minor-gc-什么情况触发","children":[]},{"level":3,"title":"【困难】什么是 Full GC？什么情况触发？","slug":"【困难】什么是-full-gc-什么情况触发","link":"#【困难】什么是-full-gc-什么情况触发","children":[]},{"level":3,"title":"【困难】Java 的 G1 垃圾回收流程是怎样的？","slug":"【困难】java-的-g1-垃圾回收流程是怎样的","link":"#【困难】java-的-g1-垃圾回收流程是怎样的","children":[]},{"level":3,"title":"【困难】Java 的 CMS 垃圾回收流程是怎样的？","slug":"【困难】java-的-cms-垃圾回收流程是怎样的","link":"#【困难】java-的-cms-垃圾回收流程是怎样的","children":[]},{"level":3,"title":"【困难】你了解 Java 的 ZGC（Z Garbage Collector）吗？","slug":"【困难】你了解-java-的-zgc-z-garbage-collector-吗","link":"#【困难】你了解-java-的-zgc-z-garbage-collector-吗","children":[]},{"level":3,"title":"【困难】JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？","slug":"【困难】jvm-垃圾回收时产生的-concurrent-mode-failure-的原因是什么","link":"#【困难】jvm-垃圾回收时产生的-concurrent-mode-failure-的原因是什么","children":[]},{"level":3,"title":"【中等】为什么 Java 中某些年轻代和老年代的垃圾收集器不能组合使用？比如 ParNew 和 Parallel Old","slug":"【中等】为什么-java-中某些年轻代和老年代的垃圾收集器不能组合使用-比如-parnew-和-parallel-old","link":"#【中等】为什么-java-中某些年轻代和老年代的垃圾收集器不能组合使用-比如-parnew-和-parallel-old","children":[]},{"level":3,"title":"【中等】JVM 年轻代垃圾回收如何避免全堆扫描？","slug":"【中等】jvm-年轻代垃圾回收如何避免全堆扫描","link":"#【中等】jvm-年轻代垃圾回收如何避免全堆扫描","children":[]},{"level":3,"title":"【困难】为什么 G1 垃圾收集器不维护年轻代到老年代的记忆集？","slug":"【困难】为什么-g1-垃圾收集器不维护年轻代到老年代的记忆集","link":"#【困难】为什么-g1-垃圾收集器不维护年轻代到老年代的记忆集","children":[]},{"level":3,"title":"【中等】G1 vs. CMS？","slug":"【中等】g1-vs-cms","link":"#【中等】g1-vs-cms","children":[]},{"level":3,"title":"【困难】G1 和 CMS 的记忆集实现有什么不同？","slug":"【困难】g1-和-cms-的记忆集实现有什么不同","link":"#【困难】g1-和-cms-的记忆集实现有什么不同","children":[]}]}],"git":{"createdTime":1745766924000,"updatedTime":1745966006000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":2}]},"readingTime":{"minutes":28.19,"words":8456},"filePathRelative":"01.Java/01.JavaCore/99.面试/Java_面试_虚拟机（二）.md","localizedDate":"2025年4月27日","excerpt":"<h1> Java 虚拟机面试二</h1>\\n<h2> 垃圾收集</h2>\\n<h3> 【困难】如何判断 Java 对象是否可以被回收？</h3>\\n<p>判断 Java 对象是否可以被回收有两种方法：</p>\\n<ul>\\n<li>引用计数法</li>\\n<li>可达性分析法</li>\\n</ul>\\n<h4> 引用计数法</h4>\\n<p>引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>\\n<p>引用计数算法<strong>简单高效</strong>，但是<strong>存在循环引用问题</strong>——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>","autoDesc":true}');export{e as data};
