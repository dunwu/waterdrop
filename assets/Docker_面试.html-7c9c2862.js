import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as l,c as d,a as e,b as n,d as t,e as o}from"./app-c4d395b2.js";const i={},c=o(`<h1 id="docker-面试" tabindex="-1"><a class="header-anchor" href="#docker-面试" aria-hidden="true">#</a> Docker 面试</h1><h2 id="docker-简介" tabindex="-1"><a class="header-anchor" href="#docker-简介" aria-hidden="true">#</a> Docker 简介</h2><h3 id="【简单】什么是-docker-为什么需要-docker" tabindex="-1"><a class="header-anchor" href="#【简单】什么是-docker-为什么需要-docker" aria-hidden="true">#</a> 【简单】什么是 Docker？为什么需要 Docker？</h3><p>Docker 是一个<strong>容器化平台</strong>，用于将应用及其所有依赖打包成一个标准化、轻量级、可移植的单元（容器），从而实现 <strong>“一次构建，处处运行”</strong>。</p><p><strong>核心价值</strong></p><ul><li><strong>环境一致性</strong>：彻底解决“在我电脑上能跑”的问题，保证开发、测试、生产环境绝对一致。</li><li><strong>隔离性</strong>：每个容器拥有独立的文件系统、网络和进程空间，应用间互不干扰。</li><li><strong>轻量高效</strong>：与传统虚拟机相比，<strong>容器直接共享主机内核</strong>，启动更快（秒级）、资源占用更少（MB 级）。</li><li><strong>DevOps 基石</strong>：极大简化了持续集成/持续部署 (CI/CD) 流程，是实现微服务架构的理想载体。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>微服务</strong>：将大型应用拆分为多个独立部署和扩展的容器化服务。</li><li><strong>CI/CD 流水线</strong>：以镜像作为标准化交付物，实现自动化测试和部署。</li><li><strong>快速搭建/清理环境</strong>：一键部署和销毁复杂的测试环境，保持主机清洁。</li><li><strong>混合云部署</strong>：凭借其可移植性，轻松在不同云平台间迁移应用。</li></ul><h3 id="【简单】docker-有哪些核心概念和组件" tabindex="-1"><a class="header-anchor" href="#【简单】docker-有哪些核心概念和组件" aria-hidden="true">#</a> 【简单】Docker 有哪些核心概念和组件？</h3><ul><li><strong>容器</strong>：是 Docker 的核心组件，是一个轻量级、可移植、自包含的软件包，包含应用程序运行所需的所有依赖项，与主机系统隔离但共享内核。</li><li><strong>镜像</strong>：是一个只读模板，包含启动容器所需的文件系统和配置信息，可基于其他镜像构建，由多个层组成。</li><li><strong>仓库</strong>：用于存储和分发 Docker 镜像，分为公共仓库和私有仓库，Docker Hub 是常见的公共仓库。</li><li><strong>Dockerfile</strong>：是一个文本文件，包含一系列指令，用于定义如何构建 Docker 镜像。</li><li><strong>网络</strong>：Docker 网络允许容器之间进行通信，提供多种网络驱动，如桥接网络、主机网络和覆盖网络等。</li><li><strong>卷</strong>：是 Docker 中用于持久化数据的机制，可独立于容器生命周期存在，也可用于多个容器之间共享数据。</li></ul><h3 id="【简单】docker-有哪些核心组件" tabindex="-1"><a class="header-anchor" href="#【简单】docker-有哪些核心组件" aria-hidden="true">#</a> 【简单】Docker 有哪些核心组件？</h3><ul><li><strong>Docker 守护进程</strong>：运行在宿主机上，负责管理 Docker 对象，如镜像、容器、网络和卷等。</li><li><strong>Docker 客户端</strong>：是一个命令行工具，用于与 Docker 守护进程交互，用户通过客户端发送命令来管理容器和镜像。</li><li><strong>Docker Registry</strong>：是一个存储和分发 Docker 镜像的服务，公共的 Docker Registry 是 Docker Hub，用户也可以搭建私有 Registry。</li><li><strong>Docker Compose</strong>：用于定义和运行多容器 Docker 应用程序，通过一个<code>docker - compose.yml</code>文件，可定义多个服务及其依赖关系。</li><li><strong>Docker Swarm</strong>：是 Docker 的原生集群管理和编排工具，允许用户将多个 Docker 主机组成一个虚拟的 Docker 主机，实现容器的高可用性和负载均衡。</li></ul><h3 id="【中等】docker-的工作原理是什么" tabindex="-1"><a class="header-anchor" href="#【中等】docker-的工作原理是什么" aria-hidden="true">#</a> 【中等】Docker 的工作原理是什么？</h3><p>Docker 基于 <strong>容器化技术</strong> 和 <strong>Linux 内核特性</strong>（如 Namespace 隔离、Cgroups 资源限制、Union File System 分层存储）实现：</p><ul><li><strong>隔离性</strong>：通过 Namespace 为容器提供独立的 PID（进程）、Network（网络）、Mount（文件系统）等命名空间，使容器看起来像独立主机。</li><li><strong>资源控制</strong>：通过 Cgroups 限制容器的 CPU、内存等资源，防止过度占用宿主机资源。</li><li><strong>分层存储</strong>：利用联合文件系统将镜像分层存储，容器运行时在镜像只读层上添加可写层，实现增量修改，节省空间并提高复用率。</li><li><strong>生命周期管理</strong>：通过 Docker 引擎协调镜像拉取、容器创建 / 启动 / 停止 / 删除等操作，简化应用的打包、部署和迁移流程。</li></ul><p>简言之，Docker 通过封装和隔离，实现了 &quot;一次构建，到处运行&quot; 的目标，解决了应用环境一致性问题。</p><h3 id="【困难】如何保证-docker-沙箱执行时的安全性" tabindex="-1"><a class="header-anchor" href="#【困难】如何保证-docker-沙箱执行时的安全性" aria-hidden="true">#</a> 【困难】如何保证 Docker 沙箱执行时的安全性？</h3><p><strong>遵循最小权限原则：</strong> 绝不给予容器超出其运行所需之外的任何权限。</p><p>Docker 安全是 <strong>“最小权限”</strong> 的实践。通过使用<strong>最小镜像</strong>、以<strong>非 root</strong> 运行、<strong>丢弃所有能力</strong>、配置<strong>只读根目录</strong>，并<strong>保护 Docker Socket</strong>，可构建深度防御体系，极大降低风险。</p><table><thead><tr><th style="text-align:left;">层面</th><th style="text-align:left;">核心实践</th><th style="text-align:left;">关键命令/示例</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>镜像安全</strong> <br>（供应链安全）</td><td style="text-align:left;"><strong>使用最小化基础镜像</strong> (Alpine, Distroless) <br><strong>扫描镜像漏洞</strong> (Trivy, Grype) <br><strong>多阶段构建</strong></td><td style="text-align:left;"><code>FROM alpine:3.18</code> <br> <code>trivy image my-app:latest</code></td></tr><tr><td style="text-align:left;"><strong>运行时安全</strong> <br>（最核心）</td><td style="text-align:left;"><strong>禁止以 root 用户运行</strong> <br><strong>限制 Linux 能力</strong> <br><strong>使用只读文件系统</strong> <br><strong>限制资源</strong> (CPU, 内存，PIDs)</td><td style="text-align:left;"><code>USER 1000</code> <br> <code>--cap-drop=ALL --cap-add=NET_BIND_SERVICE</code> <br> <code>--read-only --tmpfs /tmp</code> <br> <code>-m 512m --cpus=&quot;1.5&quot;</code></td></tr><tr><td style="text-align:left;"><strong>网络安全</strong></td><td style="text-align:left;"><strong>使用自定义网络</strong> <br><strong>谨慎发布端口</strong></td><td style="text-align:left;"><code>docker network create my-net</code> <br> <code>-p 127.0.0.1:8080:80</code></td></tr><tr><td style="text-align:left;"><strong>主机安全</strong></td><td style="text-align:left;"><strong>严禁随意挂载 Docker Socket</strong> <br><strong>启用用户命名空间重映射</strong></td><td style="text-align:left;"><strong>绝不轻易使用：</strong> <br> <code>-v /var/run/docker.sock:/var/run/docker.sock</code></td></tr></tbody></table><h2 id="镜像和容器" tabindex="-1"><a class="header-anchor" href="#镜像和容器" aria-hidden="true">#</a> 镜像和容器</h2><h3 id="【简单】docker-中的镜像和容器有什么区别" tabindex="-1"><a class="header-anchor" href="#【简单】docker-中的镜像和容器有什么区别" aria-hidden="true">#</a> 【简单】Docker 中的镜像和容器有什么区别？</h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">镜像 (Image)</th><th style="text-align:left;">容器 (Container)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>本质</strong></td><td style="text-align:left;"><strong>只读的模板</strong>和<strong>静态文件</strong></td><td style="text-align:left;"><strong>镜像的运行实例</strong>和<strong>隔离的进程</strong></td></tr><tr><td style="text-align:left;"><strong>状态</strong></td><td style="text-align:left;"><strong>静态的、不可变的</strong></td><td style="text-align:left;"><strong>动态的、可变的</strong>（运行、暂停、停止）</td></tr><tr><td style="text-align:left;"><strong>存储</strong></td><td style="text-align:left;">由一系列<strong>只读层</strong>组成</td><td style="text-align:left;">在镜像的只读层之上，添加一个薄薄的<strong>可写层</strong></td></tr><tr><td style="text-align:left;"><strong>创建方式</strong></td><td style="text-align:left;">通过 <code>docker build</code> 根据 Dockerfile 创建</td><td style="text-align:left;">通过 <code>docker run</code> 从镜像启动</td></tr><tr><td style="text-align:left;"><strong>数量关系</strong></td><td style="text-align:left;">一个镜像可以用于<strong>启动多个容器</strong></td><td style="text-align:left;">多个容器可以基于<strong>同一个镜像</strong>运行</td></tr><tr><td style="text-align:left;"><strong>生命周期</strong></td><td style="text-align:left;">手动<strong>移除</strong> (<code>docker rmi</code>)</td><td style="text-align:left;">可以被<strong>启动、停止、删除</strong> (<code>docker start/stop/rm</code>)</td></tr></tbody></table><h3 id="【简单】docker-中如何实现镜像的推送和拉取" tabindex="-1"><a class="header-anchor" href="#【简单】docker-中如何实现镜像的推送和拉取" aria-hidden="true">#</a> 【简单】Docker 中如何实现镜像的推送和拉取？</h3><p>Docker 实现镜像推送和拉取的核心步骤（适用于 Docker Hub 或私有仓库）：</p><ul><li><strong>登录仓库</strong>：用 <code>docker login [仓库地址]</code> 完成身份认证</li><li><strong>镜像打标签</strong>：按 <code>仓库地址/用户名/镜像名：版本</code> 格式，通过 <code>docker tag</code> 关联本地镜像与远程地址</li><li><strong>推送镜像</strong>：用 <code>docker push 标签名</code> 上传镜像到仓库</li><li><strong>拉取镜像</strong>：用 <code>docker pull 标签名</code>（不指定版本默认拉 latest）从仓库下载镜像</li><li><strong>可选退出</strong>：操作后可通过 <code>docker logout [仓库地址]</code> 退出登录</li></ul><h3 id="【简单】docker-容器如何实现资源限制-如-cpu-和内存" tabindex="-1"><a class="header-anchor" href="#【简单】docker-容器如何实现资源限制-如-cpu-和内存" aria-hidden="true">#</a> 【简单】Docker 容器如何实现资源限制（如 CPU 和内存）？</h3><p>Docker 容器的 CPU 和内存资源限制可通过命令参数实现，核心方式：</p><ul><li><strong>内存限制</strong><ul><li><code>--memory/-m</code>：限制最大使用内存（如 <code>-m 512m</code>）</li><li><code>--memory-swap</code>：限制内存 + 交换区总用量（需配合 <code>-m</code> 使用）</li></ul></li><li><strong>CPU 限制</strong><ul><li><code>--cpus</code>：指定可用核心数（支持小数，如 <code>--cpus 0.5</code>）</li><li><code>--cpu-shares</code>：设置资源竞争时的相对权重（默认 1024）</li><li><code>--cpuset-cpus</code>：绑定特定物理核心（如 <code>--cpuset-cpus 0,1</code>）</li></ul></li></ul><p>示例：限制容器最多使用 1 个 CPU 核心，512MB 内存</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--cpus</span> <span class="token number">1</span> <span class="token parameter variable">-m</span> 512m <span class="token parameter variable">--name</span> memory-limited nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="【中等】docker-镜像的多层结构是如何实现的" tabindex="-1"><a class="header-anchor" href="#【中等】docker-镜像的多层结构是如何实现的" aria-hidden="true">#</a> 【中等】Docker 镜像的多层结构是如何实现的？</h3><p>Docker 镜像的多层结构基于联合文件系统实现，核心要点：</p><ol><li><strong>分层存储</strong>：由多个只读层组成，每层对应 Dockerfile 一条指令（如 <code>FROM</code>、<code>RUN</code> 等）</li><li><strong>读写分离</strong>：运行容器时添加可写层，仅在该层进行修改，不改变底层只读层</li><li><strong>层复用机制</strong>：不同镜像可共享基础层，节省空间，加速构建与传输</li></ol><p>通过分层设计实现镜像轻量、高效的存储与分发。</p><h2 id="docker-构建" tabindex="-1"><a class="header-anchor" href="#docker-构建" aria-hidden="true">#</a> Docker 构建</h2><h3 id="【简单】如何构建-docker-镜像" tabindex="-1"><a class="header-anchor" href="#【简单】如何构建-docker-镜像" aria-hidden="true">#</a> 【简单】如何构建 Docker 镜像？</h3><p>使用 Dockerfile 创建自定义镜像的核心是通过编写指令脚本，定义镜像的构建流程，具体步骤如下：</p><p>（1）<strong>准备工作</strong></p><ul><li>创建项目目录（如 <code>my-image</code>），并在其中新建 <code>Dockerfile</code>（无扩展名）</li><li>准备所需文件（如应用代码、配置文件等）</li></ul><p>（2）<strong>编写 Dockerfile 指令</strong></p><p>常用核心指令及作用：</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 基础镜像（必填，指定从哪个镜像构建）</span>
<span class="token instruction"><span class="token keyword">FROM</span> ubuntu:22.04</span>

<span class="token comment"># 设置工作目录（后续命令在此目录执行）</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token comment"># 复制文件（本地文件 -&gt; 镜像内目录）</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./app.py /app/</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./requirements.txt /app/</span>

<span class="token comment"># 执行命令（如安装依赖）</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; <span class="token operator">\\</span>
    apt-get install -y python3 &amp;&amp; <span class="token operator">\\</span>
    pip3 install -r requirements.txt</span>

<span class="token comment"># 设置环境变量</span>
<span class="token instruction"><span class="token keyword">ENV</span> APP_ENV=production</span>

<span class="token comment"># 声明暴露端口（仅文档说明，需运行时-p 映射）</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 5000</span>

<span class="token comment"># 容器启动命令（容器启动时执行）</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;python3&quot;</span>, <span class="token string">&quot;app.py&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）<strong>构建镜像</strong></p><p>在 Dockerfile 所在目录执行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># -t 指定镜像标签（格式：名称：版本）</span>
<span class="token comment"># . 表示构建上下文（当前目录所有文件）</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> my-python-app:v1 <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4） <strong>验证自定义镜像</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 运行镜像测试</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 my-python-app:v1

<span class="token comment"># 查看镜像信息</span>
<span class="token function">docker</span> images <span class="token operator">|</span> <span class="token function">grep</span> my-python-app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="【中等】docker-中的多阶段构建有什么优势" tabindex="-1"><a class="header-anchor" href="#【中等】docker-中的多阶段构建有什么优势" aria-hidden="true">#</a> 【中等】Docker 中的多阶段构建有什么优势？</h3><p>Docker 多阶段构建的核心优势：</p><ul><li><strong>减小镜像体积</strong>：分离构建与运行环境，仅保留运行必需文件，剔除编译工具、源码等冗余内容</li><li><strong>简化维护</strong>：单 Dockerfile 完成全流程，通过 <code>COPY --from</code> 复用前序产物，无需多个文件或手动清理</li><li><strong>提升安全性</strong>：减少镜像包含的工具和文件，降低攻击面，避免敏感信息残留</li><li><strong>优化效率</strong>：各阶段可使用最适合的基础镜像，支持并行构建场景</li></ul><h3 id="【中等】在-docker-中-如何构建多阶段镜像以减少镜像体积" tabindex="-1"><a class="header-anchor" href="#【中等】在-docker-中-如何构建多阶段镜像以减少镜像体积" aria-hidden="true">#</a> 【中等】在 Docker 中，如何构建多阶段镜像以减少镜像体积？</h3><p>下面是一个多阶段构建示例：</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 构建阶段：使用完整的编译环境</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:18 <span class="token keyword">AS</span> build-stage</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>
<span class="token instruction"><span class="token keyword">COPY</span> package*.json ./</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install  # 安装依赖</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm run build  # 编译前端项目（生成 dist 目录）</span>

<span class="token comment"># 运行阶段：使用轻量的 Nginx 镜像</span>
<span class="token instruction"><span class="token keyword">FROM</span> nginx:alpine</span>
<span class="token comment"># 复制构建阶段的产物到 Nginx 静态目录</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">build-stage</span></span> /app/dist /usr/share/nginx/html</span>
<span class="token comment"># 暴露 80 端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 80</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;nginx&quot;</span>, <span class="token string">&quot;-g&quot;</span>, <span class="token string">&quot;daemon off;&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="实践" tabindex="-1"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h2><h3 id="【简单】在-docker-中-如何管理和查看容器日志" tabindex="-1"><a class="header-anchor" href="#【简单】在-docker-中-如何管理和查看容器日志" aria-hidden="true">#</a> 【简单】在 Docker 中，如何管理和查看容器日志？</h3>`,56),p={href:"https://docs.docker.com/engine/reference/commandline/logs",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,"docker logs",-1),k=e("h3",{id:"【中等】在-docker-中-如何进行数据卷管理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#【中等】在-docker-中-如何进行数据卷管理","aria-hidden":"true"},"#"),n(" 【中等】在 Docker 中，如何进行数据卷管理？")],-1),u=e("p",null,"在 Docker 中，数据卷管理主要包括创建、挂载、查看、删除等操作。",-1),h=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"left"}},"命令"),e("th",{style:{"text-align":"left"}},"功能描述"),e("th",{style:{"text-align":"left"}},"常用示例")])],-1),m={style:{"text-align":"left"}},v={href:"https://docs.docker.com/engine/reference/commandline/volume_create/",target:"_blank",rel:"noopener noreferrer"},b=e("strong",null,[e("code",null,"docker volume create")],-1),f=e("td",{style:{"text-align":"left"}},[e("strong",null,"创建数据卷")],-1),y=e("td",{style:{"text-align":"left"}},[e("code",null,"docker volume create my_volume")],-1),x={style:{"text-align":"left"}},D={href:"https://docs.docker.com/engine/reference/commandline/volume_rm/",target:"_blank",rel:"noopener noreferrer"},_=e("strong",null,[e("code",null,"docker volume rm")],-1),w=e("td",{style:{"text-align":"left"}},[e("strong",null,"删除数据卷")],-1),C=e("td",{style:{"text-align":"left"}},[e("code",null,"docker volume rm my_volume"),n(),e("code",null,"docker volume rm vol1 vol2")],-1),P={style:{"text-align":"left"}},S={href:"https://docs.docker.com/engine/reference/commandline/volume_ls/",target:"_blank",rel:"noopener noreferrer"},N=e("strong",null,[e("code",null,"docker volume ls")],-1),I=e("td",{style:{"text-align":"left"}},[e("strong",null,"列出所有已有的数据卷")],-1),R=e("td",{style:{"text-align":"left"}},[e("code",null,"docker volume ls"),n(),e("code",null,"docker volume ls --quiet"),n(" （仅显示名称）")],-1),q={style:{"text-align":"left"}},E={href:"https://docs.docker.com/engine/reference/commandline/volume_inspect/",target:"_blank",rel:"noopener noreferrer"},O=e("strong",null,[e("code",null,"docker volume inspect")],-1),A=e("td",{style:{"text-align":"left"}},[e("strong",null,"查看数据卷的具体信息"),n(" （如：创建时间、挂载点、驱动类型等）")],-1),M=e("td",{style:{"text-align":"left"}},[e("code",null,"docker volume inspect my_volume")],-1),U={style:{"text-align":"left"}},V={href:"https://docs.docker.com/engine/reference/commandline/volume_prune/",target:"_blank",rel:"noopener noreferrer"},L=e("strong",null,[e("code",null,"docker volume prune")],-1),K=e("td",{style:{"text-align":"left"}},[e("strong",null,"清理无主的数据卷")],-1),T=e("td",{style:{"text-align":"left"}},[e("code",null,"docker volume prune"),n(),e("code",null,"docker volume prune --force"),n(" （无需确认）")],-1),B=o(`<h3 id="【中等】如何在-docker-中实现数据卷-volume-的持久化存储" tabindex="-1"><a class="header-anchor" href="#【中等】如何在-docker-中实现数据卷-volume-的持久化存储" aria-hidden="true">#</a> 【中等】如何在 Docker 中实现数据卷（volume）的持久化存储？</h3><p>在 Docker 中实现数据卷（volume）的持久化存储，可以通过定义一个 Docker volume，并将其挂载到容器内部的路径来实现。具体步骤如下：</p><p>创建一个 Docker volume：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create my_volume
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动容器并将该 volume 挂载到容器内部的某个路径（例如 <code>/data</code>）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> my_volume:/data <span class="token parameter variable">--name</span> my_container my_image
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过上述步骤，我们已经将一个名为 my_volume 的数据卷挂载到了容器 my_container 的 /data 目录，这样即使容器被删除，该数据卷中的数据也不会丢失，可以被其他容器重新挂载使用。</p><h3 id="【中等】在-docker-中-如何优化容器启动时间" tabindex="-1"><a class="header-anchor" href="#【中等】在-docker-中-如何优化容器启动时间" aria-hidden="true">#</a> 【中等】在 Docker 中，如何优化容器启动时间？</h3><p>Docker 容器启动时间优化重点：</p><ul><li><strong>优化镜像</strong>：多阶段构建减冗余，用轻量基础镜（alpine/distroless），合并层减少层数</li><li><strong>简化启动流程</strong>：避免启动时耗时操作，减少命令复杂度，采用异步初始化</li><li><strong>资源配置</strong>：适当增加启动时 CPU / 内存配额，优化应用自身配置</li><li><strong>利用缓存</strong>：合理排序 Dockerfile 指令利用层缓存，预编译依赖</li><li><strong>存储驱动</strong>：使用 overlay2 等高效驱动</li></ul><h3 id="【中等】在-docker-中-如何实现容器之间的通信" tabindex="-1"><a class="header-anchor" href="#【中等】在-docker-中-如何实现容器之间的通信" aria-hidden="true">#</a> 【中等】在 Docker 中，如何实现容器之间的通信？</h3><p>Docker 容器间通信的核心方式：</p><ul><li><strong>同一网络</strong>：连接到同一网络（默认 / 自定义），通过容器名或 IP 直接通信</li><li><strong>不同网络</strong>：用<code>docker network connect</code>将容器加入目标网络实现跨网通信</li><li><strong>间接访问</strong>：通过宿主机端口映射（<code>-p</code>），其他容器访问宿主机 IP: 端口</li><li><strong>跨主机</strong>：集群用 overlay 网络，非集群可通过自定义路由或工具实现</li></ul><p>依赖网络隔离与 DNS 服务发现，同网络内通信无需额外配置。</p><h3 id="【中等】在-docker-中-如何配置和管理环境变量" tabindex="-1"><a class="header-anchor" href="#【中等】在-docker-中-如何配置和管理环境变量" aria-hidden="true">#</a> 【中等】在 Docker 中，如何配置和管理环境变量？</h3><p>Docker 中环境变量的配置与管理方式：</p><ul><li><strong>构建时定义</strong>：Dockerfile 中用<code>ENV</code>指令设置（如<code>ENV APP_PORT=8080</code>），镜像固化变量，容器默认继承</li><li><strong>启动时设置</strong>： <ul><li>命令行<code>-e</code>指定（<code>docker run -e &quot;APP_ENV=prod&quot; 镜像</code>）</li><li><code>--env-file</code>引用文件（<code>docker run --env-file .env 镜像</code>）</li><li>优先级高于 Dockerfile 定义，支持动态修改</li></ul></li><li><strong>运行中查看</strong>：<code>docker exec 容器名 env</code>查看所有变量，<code>echo $变量名</code>查看指定变量</li><li><strong>管理技巧</strong>：敏感信息避免明文，启动时变量可覆盖构建时定义，支持传递宿主机变量（<code>-e &quot;HOST_IP=$HOST_IP&quot;</code>）</li></ul><h3 id="【中等】docker-compose-的主要作用是什么" tabindex="-1"><a class="header-anchor" href="#【中等】docker-compose-的主要作用是什么" aria-hidden="true">#</a> 【中等】Docker Compose 的主要作用是什么？</h3><p>Docker Compose 的核心作用：</p><ul><li>用 <code>docker-compose.yml</code> 集中定义多容器配置（镜像、网络等），替代多个 <code>docker run</code> 命令</li><li>通过 <code>up</code>/<code>down</code> 等命令一键批量管理容器（启动、停止等）</li><li>自动创建网络，实现容器间通过服务名通信</li><li>支持 <code>.env</code> 文件管理环境变量，实现环境隔离</li><li>可定义容器依赖和启动顺序</li></ul><p>适用于简化多容器应用的本地开发、测试和简单部署管理。</p><h3 id="【中等】在-ci-cd-流程中-如何使用-jenkins-与-docker-集成" tabindex="-1"><a class="header-anchor" href="#【中等】在-ci-cd-流程中-如何使用-jenkins-与-docker-集成" aria-hidden="true">#</a> 【中等】在 CI/CD 流程中，如何使用 Jenkins 与 Docker 集成？</h3><p>Jenkins 与 Docker 集成实现 CI/CD 的核心要点：</p><ul><li><strong>环境准备</strong>：Jenkins 服务器安装 Docker 并配置权限，安装 <code>Docker Pipeline</code> 等相关插件</li><li><strong>核心流程</strong>： <ul><li>拉取代码后，通过 <code>docker build</code> 构建镜像（带构建号标签）</li><li>用凭据登录镜像仓库，推送镜像（<code>docker push</code>）</li><li>基于镜像启动容器执行自动化测试（<code>docker run</code>）</li><li>通过 Docker Compose 或 <code>docker run</code> 部署到目标环境</li></ul></li><li><strong>优势</strong>：保障环境一致性，实现全流程自动化，支持版本控制与回滚</li><li><strong>关键配置</strong>：使用 Jenkinsfile 定义流水线，通过 <code>withCredentials</code> 管理仓库凭据</li></ul><h2 id="docker-网络" tabindex="-1"><a class="header-anchor" href="#docker-网络" aria-hidden="true">#</a> Docker 网络</h2><h3 id="【中等】在-docker-中-如何配置容器的网络" tabindex="-1"><a class="header-anchor" href="#【中等】在-docker-中-如何配置容器的网络" aria-hidden="true">#</a> 【中等】在 Docker 中，如何配置容器的网络？</h3><p>Docker 中配置容器网络主要通过 Docker 内置的网络驱动和相关命令实现，核心方式如下：</p><p>（1）<strong>使用默认网络</strong></p><p>Docker 启动时自动创建三种网络：</p><ul><li><strong><code>bridge</code></strong>（默认）：容器通过桥接模式与宿主机通信，彼此隔离但可通过端口映射访问</li><li><strong><code>host</code></strong>：容器直接使用宿主机网络，无网络隔离，性能好但安全性低</li><li><strong><code>none</code></strong>：禁用网络，容器无网络连接</li></ul><p>示例：指定网络模式启动容器</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> <span class="token function">host</span> nginx  <span class="token comment"># 使用 host 网络</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）<strong>自定义网络</strong></p><p>适合多容器通信（如微服务），支持自动 DNS 解析：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建自定义桥接网络</span>
<span class="token function">docker</span> network create my-network

<span class="token comment"># 连接容器到自定义网络</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> app1 <span class="token parameter variable">--network</span> my-network nginx
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> app2 <span class="token parameter variable">--network</span> my-network nginx
<span class="token comment"># app1 和 app2 可通过容器名互相访问</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）<strong>端口映射</strong></p><p>让外部访问容器服务，格式：<code>宿主机端口：容器端口</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 nginx  <span class="token comment"># 宿主机 8080 端口映射到容器 80 端口</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（4）<strong>网络连接管理</strong></p><p>动态连接 / 断开容器与网络：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network connect my-network app3  <span class="token comment"># 连接现有容器到网络</span>
<span class="token function">docker</span> network disconnect my-network app3  <span class="token comment"># 断开连接</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑：通过网络模式隔离或连接容器，利用自定义网络实现容器间通信，通过端口映射实现外部访问，满足不同场景的网络需求。</p><h3 id="【中等】docker-支持哪些网络模型" tabindex="-1"><a class="header-anchor" href="#【中等】docker-支持哪些网络模型" aria-hidden="true">#</a> 【中等】Docker 支持哪些网络模型？</h3><p>Docker 网络模型基于隔离、互通和可扩展原则，利用 Linux 网络命名空间和虚拟设备实现容器网络管理，主要网络类型（驱动）及特点：</p><ul><li><strong>bridge（默认）</strong>：通过虚拟网桥实现单宿主机容器通信，支持 IP 分配和 NAT，适合本地多容器场景</li><li><strong>host</strong>：容器共享宿主机网络，性能优但无隔离，适合高性能需求</li><li><strong>none</strong>：禁用网络，完全隔离，适合离线任务</li><li><strong>overlay</strong>：基于 VXLAN 实现跨宿主机 Swarm 集群通信，支持服务发现</li><li><strong>macvlan</strong>：为容器分配独立 MAC 地址，模拟物理设备接入网络</li><li><strong>ipvlan</strong>：轻量级替代 macvlan，共享 MAC 地址、分配不同 IP</li><li><strong>自定义插件</strong>：如 Calico 等，扩展实现复杂网络策略</li></ul><p>核心特点：平衡隔离与互通，支持服务发现和跨主机扩展，适配不同场景需求。</p><h3 id="【中等】docker-的-bridge-网络模式如何配置和使用" tabindex="-1"><a class="header-anchor" href="#【中等】docker-的-bridge-网络模式如何配置和使用" aria-hidden="true">#</a> 【中等】Docker 的 bridge 网络模式如何配置和使用？</h3><ul><li><strong>默认配置</strong>：Docker 自动创建默认 <code>bridge</code> 网络（含 <code>docker0</code> 网桥），容器默认接入，获 <code>172.17.x.x</code> IP，支持容器间 IP 通信、宿主机 NAT 转发</li><li><strong>自定义网络（推荐）</strong>：<code>docker network create --driver bridge 网络名</code> 创建，支持容器名解析，功能优于默认网络</li><li><strong>容器连接</strong>：启动时用 <code>--network 网络名</code> 指定；已有容器用 <code>docker network connect 网络名 容器名</code> 连接</li><li><strong>外部访问</strong>：通过 <code>-p 宿主机端口：容器端口</code> 做端口映射（如 <code>-p 8080:80</code>）</li><li><strong>通信规则</strong>：同 bridge 网络容器可通过 IP / 容器名互通，不同网络默认隔离</li><li><strong>移除操作</strong>：先 <code>docker network disconnect 网络名 容器名</code> 断开容器，再 <code>docker network rm 网络名</code> 删除网络</li></ul><h3 id="【中等】docker-中的-overlay-网络模式如何配置和使用" tabindex="-1"><a class="header-anchor" href="#【中等】docker-中的-overlay-网络模式如何配置和使用" aria-hidden="true">#</a> 【中等】Docker 中的 overlay 网络模式如何配置和使用？</h3><p>Docker overlay 网络模式用于 Swarm 集群跨宿主机容器通信，核心配置与使用要点：</p><ul><li><strong>前提</strong>：需 Swarm 集群环境，开放 4789、7946、2377 端口</li><li><strong>创建网络</strong>：管理节点执行 <code>docker network create --driver overlay 网络名</code>，<code>--attachable</code> 允许独立容器加入</li><li><strong>服务使用</strong>：部署服务时指定 <code>--network 网络名</code>，跨节点副本自动互通</li><li><strong>独立容器加入</strong>：需网络开启 <code>--attachable</code>，不同节点容器可通过名称通信</li><li><strong>特点</strong>：基于 VXLAN 实现跨主机通信，支持 DNS 解析，自动加密流量，适用于集群微服务场景</li></ul><h2 id="docker-编排" tabindex="-1"><a class="header-anchor" href="#docker-编排" aria-hidden="true">#</a> Docker 编排</h2><h3 id="【中等】docker-的容器编排有哪些常见工具" tabindex="-1"><a class="header-anchor" href="#【中等】docker-的容器编排有哪些常见工具" aria-hidden="true">#</a> 【中等】Docker 的容器编排有哪些常见工具？</h3><p>Docker 容器编排常见工具及特点：</p><ul><li><strong>Docker Swarm</strong>：官方原生，轻量简单，适合中小规模集群</li><li><strong>Kubernetes（K8s）</strong>：主流之选，功能强大，适合大规模及复杂应用，生态丰富</li><li><strong>Docker Compose</strong>：用于本地单主机多容器管理，适合开发测试</li><li><strong>Mesos + Marathon</strong>：适合超大规模集群，支持多种任务类型</li><li><strong>Rancher</strong>：容器管理平台，简化多种编排引擎的使用</li></ul><h3 id="【中等】什么是-docker-swarm" tabindex="-1"><a class="header-anchor" href="#【中等】什么是-docker-swarm" aria-hidden="true">#</a> 【中等】什么是 Docker Swarm？</h3><p><strong>Docker Swarm 是 Docker 官方的容器集群编排工具</strong>。</p><p><strong>Docker Swarm 特点</strong></p><ul><li>与 Docker 深度集成，命令兼容，学习成本低</li><li>部署配置简单，易于快速搭建集群</li><li>具备基础编排能力（服务部署、扩缩容、滚动更新等）</li><li>轻量级，无需额外复杂组件</li></ul><p>适用场景：中小规模应用、需求简单的场景，作为 Docker 单机模式的自然扩展，成本较低，但在大规模集群和复杂场景下功能与扩展性不及 Kubernetes。</p><h3 id="【中等】如何使用-docker-swarm-部署一个高可用集群" tabindex="-1"><a class="header-anchor" href="#【中等】如何使用-docker-swarm-部署一个高可用集群" aria-hidden="true">#</a> 【中等】如何使用 Docker Swarm 部署一个高可用集群？</h3><p>使用 Docker Swarm 部署高可用集群需通过多节点角色配置和集群初始化实现，核心步骤如下：</p><ol><li><p><strong>环境准备</strong></p><ul><li>至少 3 台主机（推荐奇数，便于选举），确保网络互通，已安装 Docker</li><li>所有节点间开放 2377（集群管理）、7946（节点通信）、4789（overlay 网络）端口</li></ul></li><li><p><strong>初始化管理节点</strong>：在主管理节点执行初始化命令，创建集群：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> swarm init --advertise-addr <span class="token operator">&lt;</span>主节点 IP<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令会生成 <strong>工作节点加入令牌</strong> 和 <strong>管理节点加入令牌</strong></p></li><li><p><strong>添加管理节点（实现高可用）</strong>：在其他管理节点执行（使用初始化时的管理节点令牌）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> swarm join-token manager  <span class="token comment"># 查看加入命令</span>
<span class="token comment"># 执行返回的命令，如：</span>
<span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> <span class="token operator">&lt;</span>管理节点令牌<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点 IP<span class="token operator">&gt;</span>:2377
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>建议部署 3-5 个管理节点（奇数），确保集群决策容错</p></li><li><p><strong>添加工作节点</strong>：在工作节点执行（使用初始化时的工作节点令牌）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> <span class="token operator">&lt;</span>工作节点令牌<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主节点 IP<span class="token operator">&gt;</span>:2377
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>工作节点负责运行容器，可按需扩展数量</p></li><li><p><strong>验证集群状态</strong>：在任意管理节点执行，查看节点状态：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出中 <code>LEADER</code> 为当前主管理节点，<code>REACHABLE</code> 为备用管理节点</p></li><li><p><strong>部署服务（高可用验证）</strong>：部署服务时指定副本数，Swarm 会自动在不同节点分发容器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--name</span> ha-service <span class="token parameter variable">--replicas</span> <span class="token number">3</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当某个节点故障时，Swarm 会自动在健康节点重建容器</p></li></ol><p>通过以上步骤，即可实现 Docker Swarm 高可用集群，核心依赖多管理节点的故障转移能力和服务自动调度机制。</p><h3 id="【中等】docker-swarm-和-kubernetes-在集群管理上的主要区别是什么" tabindex="-1"><a class="header-anchor" href="#【中等】docker-swarm-和-kubernetes-在集群管理上的主要区别是什么" aria-hidden="true">#</a> 【中等】Docker Swarm 和 Kubernetes 在集群管理上的主要区别是什么？</h3><table><thead><tr><th>对比维度</th><th>Docker Swarm</th><th>Kubernetes (K8s)</th></tr></thead><tbody><tr><td><strong>复杂度</strong></td><td>简单，与 Docker 命令兼容，学习成本低</td><td>复杂，组件和概念多，学习曲线陡峭</td></tr><tr><td><strong>功能丰富度</strong></td><td>基础功能为主（部署、扩缩容等），高级特性少</td><td>功能全面（自愈、自动扩缩容、网络策略等），支持复杂场景</td></tr><tr><td><strong>扩展性与灵活性</strong></td><td>扩展性有限，插件生态弱</td><td>高度可扩展，支持自定义资源和插件，灵活性强</td></tr><tr><td><strong>高可用与性能</strong></td><td>支持基础高可用，大规模集群性能较弱</td><td>专为大规模设计，高可用机制成熟，调度更智能</td></tr><tr><td><strong>生态与社区支持</strong></td><td>生态封闭，社区活跃度低</td><td>社区活跃，CNCF 托管，云厂商广泛支持，工具丰富</td></tr><tr><td><strong>适用场景</strong></td><td>中小规模应用、简单场景、快速部署需求</td><td>大规模集群、复杂应用（微服务、有状态）、企业级环境</td></tr></tbody></table><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,67),F={href:"https://www.mianshiya.com/bank/1812067352871829505",target:"_blank",rel:"noopener noreferrer"};function j(H,Y){const s=a("ExternalLinkIcon");return l(),d("div",null,[c,e("p",null,[n("通过 "),e("a",p,[g,t(s)]),n(" 命令从容器中读取日志。")]),k,u,e("table",null,[h,e("tbody",null,[e("tr",null,[e("td",m,[e("a",v,[b,t(s)])]),f,y]),e("tr",null,[e("td",x,[e("a",D,[_,t(s)])]),w,C]),e("tr",null,[e("td",P,[e("a",S,[N,t(s)])]),I,R]),e("tr",null,[e("td",q,[e("a",E,[O,t(s)])]),A,M]),e("tr",null,[e("td",U,[e("a",V,[L,t(s)])]),K,T])])]),B,e("ul",null,[e("li",null,[e("a",F,[n("面试鸭 - Docker 面试题"),t(s)])])])])}const W=r(i,[["render",j],["__file","Docker_面试.html.vue"]]);export{W as default};
