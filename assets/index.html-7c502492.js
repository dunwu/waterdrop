const a=JSON.parse('{"key":"v-b3905db2","path":"/pages/1261f141/","title":"Java 容器之 Map","lang":"zh-CN","frontmatter":{"title":"Java 容器之 Map","date":"2019-12-29T21:49:58.000Z","order":3,"permalink":"/pages/1261f141/","category":["Java","JavaCore","容器"],"tag":["Java","JavaCore","容器"],"description":"Java 容器之 Map Map 简介 Map 架构 Map 家族主要成员功能如下： Map 是 Map 容器家族的祖先，Map 是一个用于保存键值对(key-value)的接口。Map 中不能包含重复的键；每个键最多只能映射到一个值。 AbstractMap 继承了 Map 的抽象类，它实现了 Map 中的核心 API。其它 Map 的实现类可以通过继承 AbstractMap 来减少重复编码。 SortedMap 继承了 Map 的接口。SortedMap 中的内容是排序的键值对，排序的方法是通过实现比较器(Comparator)完成的。 NavigableMap 继承了 SortedMap 的接口。相比于 SortedMap，NavigableMap 有一系列的“导航”方法；如\\"获取大于/等于某对象的键值对\\"、“获取小于/等于某对象的键值对”等等。 HashMap 继承了 AbstractMap，但没实现 NavigableMap 接口。HashMap 的主要作用是储存无序的键值对，而 Hash 也体现了它的查找效率很高。HashMap 是使用最广泛的 Map。 Hashtable 虽然没有继承 AbstractMap，但它继承了 Dictionary（Dictionary 也是键值对的接口），而且也实现 Map 接口。因此，Hashtable 的主要作用是储存无序的键值对。和 HashMap 相比，Hashtable 在它的主要方法中使用 synchronized 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 Java 程序几乎不会使用 Hashtable ，如果需要保证线程安全，一般会用 ConcurrentHashMap 来替代。 TreeMap 继承了 AbstractMap，且实现了 NavigableMap 接口。TreeMap 的主要作用是储存有序的键值对，排序依据根据元素类型的 Comparator 而定。 WeakHashMap 继承了 AbstractMap。WeakHashMap 的键是弱引用 （即 WeakReference），它的主要作用是当 GC 内存不足时，会自动将 WeakHashMap 中的 key 回收，这避免了 WeakHashMap 的内存空间无限膨胀。很明显，WeakHashMap 适用于作为缓存。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/1261f141/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 容器之 Map"}],["meta",{"property":"og:description","content":"Java 容器之 Map Map 简介 Map 架构 Map 家族主要成员功能如下： Map 是 Map 容器家族的祖先，Map 是一个用于保存键值对(key-value)的接口。Map 中不能包含重复的键；每个键最多只能映射到一个值。 AbstractMap 继承了 Map 的抽象类，它实现了 Map 中的核心 API。其它 Map 的实现类可以通过继承 AbstractMap 来减少重复编码。 SortedMap 继承了 Map 的接口。SortedMap 中的内容是排序的键值对，排序的方法是通过实现比较器(Comparator)完成的。 NavigableMap 继承了 SortedMap 的接口。相比于 SortedMap，NavigableMap 有一系列的“导航”方法；如\\"获取大于/等于某对象的键值对\\"、“获取小于/等于某对象的键值对”等等。 HashMap 继承了 AbstractMap，但没实现 NavigableMap 接口。HashMap 的主要作用是储存无序的键值对，而 Hash 也体现了它的查找效率很高。HashMap 是使用最广泛的 Map。 Hashtable 虽然没有继承 AbstractMap，但它继承了 Dictionary（Dictionary 也是键值对的接口），而且也实现 Map 接口。因此，Hashtable 的主要作用是储存无序的键值对。和 HashMap 相比，Hashtable 在它的主要方法中使用 synchronized 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 Java 程序几乎不会使用 Hashtable ，如果需要保证线程安全，一般会用 ConcurrentHashMap 来替代。 TreeMap 继承了 AbstractMap，且实现了 NavigableMap 接口。TreeMap 的主要作用是储存有序的键值对，排序依据根据元素类型的 Comparator 而定。 WeakHashMap 继承了 AbstractMap。WeakHashMap 的键是弱引用 （即 WeakReference），它的主要作用是当 GC 内存不足时，会自动将 WeakHashMap 中的 key 回收，这避免了 WeakHashMap 的内存空间无限膨胀。很明显，WeakHashMap 适用于作为缓存。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-15T23:50:15.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaCore"}],["meta",{"property":"article:tag","content":"容器"}],["meta",{"property":"article:published_time","content":"2019-12-29T21:49:58.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-15T23:50:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 容器之 Map\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-12-29T21:49:58.000Z\\",\\"dateModified\\":\\"2025-09-15T23:50:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"Map 简介","slug":"map-简介","link":"#map-简介","children":[{"level":3,"title":"Map 架构","slug":"map-架构","link":"#map-架构","children":[]},{"level":3,"title":"Map 接口","slug":"map-接口","link":"#map-接口","children":[]},{"level":3,"title":"Map.Entry 接口","slug":"map-entry-接口","link":"#map-entry-接口","children":[]},{"level":3,"title":"AbstractMap 抽象类","slug":"abstractmap-抽象类","link":"#abstractmap-抽象类","children":[]},{"level":3,"title":"SortedMap 接口","slug":"sortedmap-接口","link":"#sortedmap-接口","children":[]},{"level":3,"title":"NavigableMap 接口","slug":"navigablemap-接口","link":"#navigablemap-接口","children":[]},{"level":3,"title":"Dictionary 抽象类","slug":"dictionary-抽象类","link":"#dictionary-抽象类","children":[]}]},{"level":2,"title":"HashMap 类","slug":"hashmap-类","link":"#hashmap-类","children":[{"level":3,"title":"JDK8 之前 HashMap 数据结构","slug":"jdk8-之前-hashmap-数据结构","link":"#jdk8-之前-hashmap-数据结构","children":[]},{"level":3,"title":"JDK8 之后 HashMap 数据结构","slug":"jdk8-之后-hashmap-数据结构","link":"#jdk8-之后-hashmap-数据结构","children":[]},{"level":3,"title":"HashMap 构造方法","slug":"hashmap-构造方法","link":"#hashmap-构造方法","children":[]},{"level":3,"title":"put 方法的实现","slug":"put-方法的实现","link":"#put-方法的实现","children":[]},{"level":3,"title":"get 方法的实现","slug":"get-方法的实现","link":"#get-方法的实现","children":[]},{"level":3,"title":"resize 的实现","slug":"resize-的实现","link":"#resize-的实现","children":[]}]},{"level":2,"title":"LinkedHashMap 类","slug":"linkedhashmap-类","link":"#linkedhashmap-类","children":[{"level":3,"title":"LinkedHashMap 要点","slug":"linkedhashmap-要点","link":"#linkedhashmap-要点","children":[]},{"level":3,"title":"LinkedHashMap 数据结构","slug":"linkedhashmap-数据结构","link":"#linkedhashmap-数据结构","children":[]}]},{"level":2,"title":"TreeMap 类","slug":"treemap-类","link":"#treemap-类","children":[{"level":3,"title":"TreeMap 要点","slug":"treemap-要点","link":"#treemap-要点","children":[]},{"level":3,"title":"TreeMap 原理","slug":"treemap-原理","link":"#treemap-原理","children":[]},{"level":3,"title":"remove 方法","slug":"remove-方法","link":"#remove-方法","children":[]},{"level":3,"title":"TreeMap 示例","slug":"treemap-示例","link":"#treemap-示例","children":[]}]},{"level":2,"title":"WeakHashMap","slug":"weakhashmap","link":"#weakhashmap","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"Map 简介","slug":"map-简介-1","link":"#map-简介-1","children":[]},{"level":3,"title":"HashMap","slug":"hashmap","link":"#hashmap","children":[]},{"level":3,"title":"其他 Map","slug":"其他-map","link":"#其他-map","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1757980215000,"updatedTime":1757980215000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":22.04,"words":6613},"filePathRelative":"01.Java/JavaCore/容器/Java_容器_Map.md","localizedDate":"2019年12月29日","excerpt":"<h1> Java 容器之 Map</h1>\\n<h2> Map 简介</h2>\\n<h3> Map 架构</h3>\\n<div align=\\"center\\">\\n<img src=\\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/Map-diagrams.png\\">\\n</div>\\n<p>Map 家族主要成员功能如下：</p>\\n<ul>\\n<li><code>Map</code> 是 Map 容器家族的祖先，Map 是一个用于保存键值对(key-value)的接口。<strong>Map 中不能包含重复的键；每个键最多只能映射到一个值。</strong></li>\\n<li><code>AbstractMap</code> 继承了 <code>Map</code> 的抽象类，它实现了 <code>Map</code> 中的核心 API。其它 <code>Map</code> 的实现类可以通过继承 <code>AbstractMap</code> 来减少重复编码。</li>\\n<li><code>SortedMap</code> 继承了 <code>Map</code> 的接口。<code>SortedMap</code> 中的内容是排序的键值对，排序的方法是通过实现比较器(<code>Comparator</code>)完成的。</li>\\n<li><code>NavigableMap</code> 继承了 <code>SortedMap</code> 的接口。相比于 <code>SortedMap</code>，<code>NavigableMap</code> 有一系列的“导航”方法；如\\"获取大于/等于某对象的键值对\\"、“获取小于/等于某对象的键值对”等等。</li>\\n<li><code>HashMap</code> 继承了 <code>AbstractMap</code>，但没实现 <code>NavigableMap</code> 接口。<code>HashMap</code> 的主要作用是储存无序的键值对，而 <code>Hash</code> 也体现了它的查找效率很高。<code>HashMap</code> 是使用最广泛的 <code>Map</code>。</li>\\n<li><code>Hashtable</code> 虽然没有继承 <code>AbstractMap</code>，但它继承了 <code>Dictionary</code>（<code>Dictionary</code> 也是键值对的接口），而且也实现 <code>Map</code> 接口。因此，<code>Hashtable</code> 的主要作用是储存无序的键值对。和 HashMap 相比，<code>Hashtable</code> 在它的主要方法中使用 <code>synchronized</code> 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 Java 程序几乎不会使用 <code>Hashtable</code> ，如果需要保证线程安全，一般会用 <code>ConcurrentHashMap</code> 来替代。</li>\\n<li><code>TreeMap</code> 继承了 <code>AbstractMap</code>，且实现了 <code>NavigableMap</code> 接口。<code>TreeMap</code> 的主要作用是储存有序的键值对，排序依据根据元素类型的 <code>Comparator</code> 而定。</li>\\n<li><code>WeakHashMap</code> 继承了 <code>AbstractMap</code>。<code>WeakHashMap</code> 的键是<strong>弱引用</strong> （即 <code>WeakReference</code>），它的主要作用是当 GC 内存不足时，会自动将 <code>WeakHashMap</code> 中的 key 回收，这避免了 <code>WeakHashMap</code> 的内存空间无限膨胀。很明显，<code>WeakHashMap</code> 适用于作为缓存。</li>\\n</ul>","autoDesc":true}');export{a as data};
