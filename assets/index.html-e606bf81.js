import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as n,c as a,a as r,b as s,d as i,e as d}from"./app-de4383da.js";const l={},c=d('<h1 id="rabbitmq-面试" tabindex="-1"><a class="header-anchor" href="#rabbitmq-面试" aria-hidden="true">#</a> RabbitMQ 面试</h1><h3 id="【中等】rabbitmq-怎么实现延迟队列-🌟" tabindex="-1"><a class="header-anchor" href="#【中等】rabbitmq-怎么实现延迟队列-🌟" aria-hidden="true">#</a> 【中等】RabbitMQ 怎么实现延迟队列？🌟</h3><p>RabbitMQ 实现延迟队列主要有两种方式：</p><p><strong>死信交换机（DLX）方案</strong></p><ul><li><strong>原理</strong>：让消息先进入一个<strong>有过期时间（TTL）</strong> 的队列，消息过期后自动被转发到<strong>死信交换机</strong>，再路由到最终消费队列。</li><li><strong>优点</strong>：稳定可靠，无需额外插件。</li><li><strong>缺点</strong>：<strong>不灵活</strong>，需为不同延迟时间创建多个队列；<strong>定时不精确</strong>。</li></ul><p><strong>官方延迟插件方案（推荐）</strong></p><ul><li><strong>原理</strong>：安装 <code>rabbitmq_delayed_message_exchange</code> 插件，使用一种特殊的交换机。发送消息时通过 <code>x-delay</code> 参数<strong>为每条消息单独设置延迟时间</strong>。</li><li><strong>优点</strong>：<strong>极其灵活</strong>，使用简单，延迟精度更高。</li><li><strong>缺点</strong>：需安装插件；海量延迟消息可能对性能有压力。</li></ul><p><strong>选择建议</strong></p><ul><li>只需少数固定延迟时间 → <strong>死信交换机方案</strong>。</li><li>需要灵活指定每条消息的延迟 → <strong>官方延迟插件方案</strong>（首选）。</li></ul><h3 id="【中等】rabbitmq-中无法路由的消息会去到哪里-🌟" tabindex="-1"><a class="header-anchor" href="#【中等】rabbitmq-中无法路由的消息会去到哪里-🌟" aria-hidden="true">#</a> 【中等】RabbitMQ 中无法路由的消息会去到哪里？🌟</h3><p>在 RabbitMQ 中，无法路由的消息去向由生产者发送时的 <code>mandatory</code> 参数决定：</p><ul><li><strong><code>mandatory = false</code> （默认值）</strong>：消息被 Broker <strong>直接丢弃</strong>。</li><li><strong><code>mandatory = true</code></strong>：消息通过 <strong><code>ReturnCallback</code></strong> 机制<strong>返回给生产者</strong>进行处理。</li></ul><p><strong>重要提示</strong>：无法路由的消息不会自动进入死信队列（DLQ），因为死信队列用于处理已成功入队但后被拒绝或过期的消息。</p><h3 id="【中等】rabbitmq-中消息什么时候会进入死信交换机-🌟" tabindex="-1"><a class="header-anchor" href="#【中等】rabbitmq-中消息什么时候会进入死信交换机-🌟" aria-hidden="true">#</a> 【中等】RabbitMQ 中消息什么时候会进入死信交换机？🌟</h3><p>RabbitMQ 中，消息会在以下三种情况下进入死信交换机（DLX）：</p><ol><li><strong>被拒绝 (Rejected)</strong>：消费者拒绝消息（<code>basic.reject</code> 或 <code>basic.nack</code>）且不重新入队（<code>requeue=false</code>）。</li><li><strong>已过期 (Expired)</strong>：消息的存活时间（TTL）到期。</li><li><strong>队列满 (Overflowed)</strong>：队列达到最大长度限制，最老的消息会被挤出。</li></ol><p><strong>核心前提</strong>：必须在声明原始队列时通过 <code>x-dead-letter-exchange</code> 参数预先配置好死信交换机。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',18),g={href:"https://www.mianshiya.com/bank/1850081848441466881",target:"_blank",rel:"noopener noreferrer"};function b(h,p){const e=o("ExternalLinkIcon");return n(),a("div",null,[c,r("ul",null,[r("li",null,[r("a",g,[s("面试鸭 - RabbitMQ 面试"),i(e)])])])])}const _=t(l,[["render",b],["__file","index.html.vue"]]);export{_ as default};
