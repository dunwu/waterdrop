const e=JSON.parse('{"key":"v-758ad11e","path":"/pages/0ba5bf14/","title":"《极客时间教程 - Java 并发编程实战》笔记二","lang":"zh-CN","frontmatter":{"title":"《极客时间教程 - Java 并发编程实战》笔记二","date":"2024-08-26T14:36:05.000Z","permalink":"/pages/0ba5bf14/","category":["笔记","Java"],"tag":["Java","并发"],"description":"《极客时间教程 - Java 并发编程实战》笔记二 Lock 和 Condition（上）：隐藏在并发包中的管程 再造管程的理由 已有 synchronized，还支持 Lock 的原因是，需要一把锁支持： 能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/waterdrop/waterdrop/pages/0ba5bf14/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"《极客时间教程 - Java 并发编程实战》笔记二"}],["meta",{"property":"og:description","content":"《极客时间教程 - Java 并发编程实战》笔记二 Lock 和 Condition（上）：隐藏在并发包中的管程 再造管程的理由 已有 synchronized，还支持 Lock 的原因是，需要一把锁支持： 能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-27T13:28:08.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2024-08-26T14:36:05.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-27T13:28:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《极客时间教程 - Java 并发编程实战》笔记二\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-26T14:36:05.000Z\\",\\"dateModified\\":\\"2025-09-27T13:28:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io/waterdrop\\"}]}"]]},"headers":[{"level":2,"title":"Lock 和 Condition（上）：隐藏在并发包中的管程","slug":"lock-和-condition-上-隐藏在并发包中的管程","link":"#lock-和-condition-上-隐藏在并发包中的管程","children":[{"level":3,"title":"再造管程的理由","slug":"再造管程的理由","link":"#再造管程的理由","children":[]},{"level":3,"title":"如何保证可见性","slug":"如何保证可见性","link":"#如何保证可见性","children":[]},{"level":3,"title":"什么是可重入锁","slug":"什么是可重入锁","link":"#什么是可重入锁","children":[]},{"level":3,"title":"公平锁与非公平锁","slug":"公平锁与非公平锁","link":"#公平锁与非公平锁","children":[]},{"level":3,"title":"用锁的最佳实践","slug":"用锁的最佳实践","link":"#用锁的最佳实践","children":[]}]},{"level":2,"title":"Lock 和 Condition（下）：Dubbo 如何用管程实现异步转同步？","slug":"lock-和-condition-下-dubbo-如何用管程实现异步转同步","link":"#lock-和-condition-下-dubbo-如何用管程实现异步转同步","children":[{"level":3,"title":"同步与异步","slug":"同步与异步","link":"#同步与异步","children":[]},{"level":3,"title":"Dubbo 源码分析","slug":"dubbo-源码分析","link":"#dubbo-源码分析","children":[]}]},{"level":2,"title":"Semaphore：如何快速实现一个限流器？","slug":"semaphore-如何快速实现一个限流器","link":"#semaphore-如何快速实现一个限流器","children":[{"level":3,"title":"信号量模型","slug":"信号量模型","link":"#信号量模型","children":[]},{"level":3,"title":"如何使用信号量","slug":"如何使用信号量","link":"#如何使用信号量","children":[]},{"level":3,"title":"快速实现一个限流器","slug":"快速实现一个限流器","link":"#快速实现一个限流器","children":[]},{"level":3,"title":"快速实现一个缓存","slug":"快速实现一个缓存","link":"#快速实现一个缓存","children":[]},{"level":3,"title":"实现缓存的按需加载","slug":"实现缓存的按需加载","link":"#实现缓存的按需加载","children":[]}]},{"level":2,"title":"ReadWriteLock：如何快速实现一个完备的缓存？","slug":"readwritelock-如何快速实现一个完备的缓存","link":"#readwritelock-如何快速实现一个完备的缓存","children":[{"level":3,"title":"读写锁的升级与降级","slug":"读写锁的升级与降级","link":"#读写锁的升级与降级","children":[]}]},{"level":2,"title":"StampedLock：有没有比读写锁更快的锁？","slug":"stampedlock-有没有比读写锁更快的锁","link":"#stampedlock-有没有比读写锁更快的锁","children":[{"level":3,"title":"StampedLock 支持的三种锁模式","slug":"stampedlock-支持的三种锁模式","link":"#stampedlock-支持的三种锁模式","children":[]},{"level":3,"title":"进一步理解乐观读","slug":"进一步理解乐观读","link":"#进一步理解乐观读","children":[]},{"level":3,"title":"StampedLock 使用注意事项","slug":"stampedlock-使用注意事项","link":"#stampedlock-使用注意事项","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"CountDownLatch 和 CyclicBarrier：如何让多线程步调一致？","slug":"countdownlatch-和-cyclicbarrier-如何让多线程步调一致","link":"#countdownlatch-和-cyclicbarrier-如何让多线程步调一致","children":[{"level":3,"title":"利用并行优化对账系统","slug":"利用并行优化对账系统","link":"#利用并行优化对账系统","children":[]},{"level":3,"title":"用 CountDownLatch 实现线程等待","slug":"用-countdownlatch-实现线程等待","link":"#用-countdownlatch-实现线程等待","children":[]},{"level":3,"title":"进一步优化性能","slug":"进一步优化性能","link":"#进一步优化性能","children":[]},{"level":3,"title":"用 CyclicBarrier 实现线程同步","slug":"用-cyclicbarrier-实现线程同步","link":"#用-cyclicbarrier-实现线程同步","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"并发容器：都有哪些“坑”需要我们填？","slug":"并发容器-都有哪些-坑-需要我们填","link":"#并发容器-都有哪些-坑-需要我们填","children":[{"level":3,"title":"同步容器及其注意事项","slug":"同步容器及其注意事项","link":"#同步容器及其注意事项","children":[]},{"level":3,"title":"并发容器及其注意事项","slug":"并发容器及其注意事项","link":"#并发容器及其注意事项","children":[]}]},{"level":2,"title":"原子类：无锁工具类的典范","slug":"原子类-无锁工具类的典范","link":"#原子类-无锁工具类的典范","children":[{"level":3,"title":"无锁方案的实现原理","slug":"无锁方案的实现原理","link":"#无锁方案的实现原理","children":[]},{"level":3,"title":"看 Java 如何实现原子化的 count += 1","slug":"看-java-如何实现原子化的-count-1","link":"#看-java-如何实现原子化的-count-1","children":[]},{"level":3,"title":"原子类概览","slug":"原子类概览","link":"#原子类概览","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"Executor 与线程池：如何创建正确的线程池？","slug":"executor-与线程池-如何创建正确的线程池","link":"#executor-与线程池-如何创建正确的线程池","children":[{"level":3,"title":"线程池是一种生产者-消费者模式","slug":"线程池是一种生产者-消费者模式","link":"#线程池是一种生产者-消费者模式","children":[]},{"level":3,"title":"如何使用 Java 中的线程池","slug":"如何使用-java-中的线程池","link":"#如何使用-java-中的线程池","children":[]},{"level":3,"title":"使用线程池要注意些什么","slug":"使用线程池要注意些什么","link":"#使用线程池要注意些什么","children":[]}]},{"level":2,"title":"Future：如何用多线程实现最优的“烧水泡茶”程序？","slug":"future-如何用多线程实现最优的-烧水泡茶-程序","link":"#future-如何用多线程实现最优的-烧水泡茶-程序","children":[{"level":3,"title":"如何获取任务执行结果","slug":"如何获取任务执行结果","link":"#如何获取任务执行结果","children":[]},{"level":3,"title":"实现最优的“烧水泡茶”程序","slug":"实现最优的-烧水泡茶-程序","link":"#实现最优的-烧水泡茶-程序","children":[]}]},{"level":2,"title":"CompletableFuture：异步编程没那么难","slug":"completablefuture-异步编程没那么难","link":"#completablefuture-异步编程没那么难","children":[{"level":3,"title":"CompletableFuture 的核心优势","slug":"completablefuture-的核心优势","link":"#completablefuture-的核心优势","children":[]},{"level":3,"title":"创建 CompletableFuture 对象","slug":"创建-completablefuture-对象","link":"#创建-completablefuture-对象","children":[]},{"level":3,"title":"如何理解 CompletionStage 接口","slug":"如何理解-completionstage-接口","link":"#如何理解-completionstage-接口","children":[]}]},{"level":2,"title":"CompletionService：如何批量执行异步任务？","slug":"completionservice-如何批量执行异步任务","link":"#completionservice-如何批量执行异步任务","children":[{"level":3,"title":"利用 CompletionService 实现询价系统","slug":"利用-completionservice-实现询价系统","link":"#利用-completionservice-实现询价系统","children":[]},{"level":3,"title":"CompletionService 接口说明","slug":"completionservice-接口说明","link":"#completionservice-接口说明","children":[]},{"level":3,"title":"利用 CompletionService 实现 Dubbo 中的 Forking Cluster","slug":"利用-completionservice-实现-dubbo-中的-forking-cluster","link":"#利用-completionservice-实现-dubbo-中的-forking-cluster","children":[]},{"level":3,"title":"总结","slug":"总结-3","link":"#总结-3","children":[]}]},{"level":2,"title":"Fork_Join：单机版的 MapReduce","slug":"fork-join-单机版的-mapreduce","link":"#fork-join-单机版的-mapreduce","children":[{"level":3,"title":"分治任务模型","slug":"分治任务模型","link":"#分治任务模型","children":[]},{"level":3,"title":"Fork/Join 的使用","slug":"fork-join-的使用","link":"#fork-join-的使用","children":[]}]},{"level":2,"title":"ForkJoinPool 工作原理","slug":"forkjoinpool-工作原理","link":"#forkjoinpool-工作原理","children":[{"level":3,"title":"模拟 MapReduce 统计单词数量","slug":"模拟-mapreduce-统计单词数量","link":"#模拟-mapreduce-统计单词数量","children":[]},{"level":3,"title":"总结","slug":"总结-4","link":"#总结-4","children":[]}]},{"level":2,"title":"并发工具类模块热点问题答疑","slug":"并发工具类模块热点问题答疑","link":"#并发工具类模块热点问题答疑","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1758979688000,"updatedTime":1758979688000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":43.41,"words":13024},"filePathRelative":"00.笔记/Java/极客时间教程-Java并发编程实战笔记二.md","localizedDate":"2024年8月26日","excerpt":"<h1> 《极客时间教程 - Java 并发编程实战》笔记二</h1>\\n<h2> Lock 和 Condition（上）：隐藏在并发包中的管程</h2>\\n<h3> 再造管程的理由</h3>\\n<p>已有 synchronized，还支持 Lock 的原因是，需要一把锁支持：</p>\\n<ol>\\n<li><strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</li>\\n<li><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>\\n<li><strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>\\n</ol>","autoDesc":true}');export{e as data};
