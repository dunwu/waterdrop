import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as s,c as i,a as t,b as e,d as a,e as o}from"./app-c3a3f62b.js";const g={},c=o('<h1 id="rocketmq-面试" tabindex="-1"><a class="header-anchor" href="#rocketmq-面试" aria-hidden="true">#</a> RocketMQ 面试</h1><h3 id="【困难】事务消息是如何工作的" tabindex="-1"><a class="header-anchor" href="#【困难】事务消息是如何工作的" aria-hidden="true">#</a> 【困难】事务消息是如何工作的？</h3><p>MQ 事务方案本质是利用 MQ 功能实现的本地消息表。事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。</p><ul><li><strong>Kafka</strong> 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。</li><li><strong>RocketMQ</strong> 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</li></ul><div class="hint-container info"><p class="hint-container-title">RocketMQ 事务消息实现</p></div><p>事务消息是 Apache RocketMQ 提供的一种困难消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140759853.png" alt="RocketMQ 事务消息" tabindex="0" loading="lazy"><figcaption>RocketMQ 事务消息</figcaption></figure><p><strong>事务消息处理流程</strong></p>',8),d=t("li",null,"生产者将消息发送至 Apache RocketMQ 服务端。",-1),h=t("li",null,'Apache RocketMQ 服务端将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息被标记为"暂不能投递"，这种状态下的消息即为半事务消息。',-1),p=t("li",null,"生产者开始执行本地事务逻辑。",-1),k=t("li",null,[e("生产者根据本地事务执行结果向服务端提交二次确认结果（Commit 或是 Rollback），服务端收到确认结果后处理逻辑如下： "),t("ul",null,[t("li",null,"二次确认结果为 Commit：服务端将半事务消息标记为可投递，并投递给消费者。"),t("li",null,"二次确认结果为 Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。")])],-1),f=t("strong",null,"说明",-1),u={href:"https://rocketmq.apache.org/zh/docs/introduction/03limits",target:"_blank",rel:"noopener noreferrer"},m=t("li",null,"生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。",-1),_=t("li",null,"生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半事务消息进行处理。",-1),x=o('<div class="hint-container info"><p class="hint-container-title">本地消息表 vs. 事务消息</p></div><ul><li><strong>本地消息表</strong>：<strong>业务与消息耦合</strong>，通过<strong>数据库+自研任务</strong>保证可靠性。</li><li><strong>RocketMQ 事务消息</strong>：<strong>业务与消息解耦</strong>，通过** MQ 框架机制**保证可靠性。</li></ul><p><strong>本地消息表 vs. 事务消息</strong></p><table><thead><tr><th style="text-align:left;">维度</th><th style="text-align:left;">本地消息表</th><th style="text-align:left;">RocketMQ 事务消息</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>核心机制</strong></td><td style="text-align:left;">数据库事务 + 定时任务扫表</td><td style="text-align:left;">半消息 + 事务回查</td></tr><tr><td style="text-align:left;"><strong>性能</strong></td><td style="text-align:left;">中（受数据库限制）</td><td style="text-align:left;"><strong>高</strong>（由 MQ 保障）</td></tr><tr><td style="text-align:left;"><strong>侵入性</strong></td><td style="text-align:left;"><strong>低</strong>（只需写库）</td><td style="text-align:left;">中（需实现回查接口）</td></tr><tr><td style="text-align:left;"><strong>复杂度</strong></td><td style="text-align:left;">中（在应用侧，需自研任务）</td><td style="text-align:left;">中（在框架侧，开箱即用）</td></tr><tr><td style="text-align:left;"><strong>耦合度</strong></td><td style="text-align:left;"><strong>与数据库耦合</strong></td><td style="text-align:left;"><strong>与 RocketMQ 耦合</strong></td></tr><tr><td style="text-align:left;"><strong>通用性</strong></td><td style="text-align:left;"><strong>高</strong>（适配任何 MQ）</td><td style="text-align:left;">低（仅限 RocketMQ）</td></tr></tbody></table><p><strong>技术选型</strong></p><ul><li><strong>选本地消息表</strong>：追求<strong>通用解</strong>、技术栈多样、消息量适中。</li><li><strong>选 RocketMQ 事务消息</strong>：技术栈已定、追求<strong>高性能</strong>、希望减少自研成本。</li></ul><h3 id="【中等】rocketmq-的事务消息有什么缺点" tabindex="-1"><a class="header-anchor" href="#【中等】rocketmq-的事务消息有什么缺点" aria-hidden="true">#</a> 【中等】RocketMQ 的事务消息有什么缺点？</h3><p>RocketMQ 事务消息主要缺点：</p><ul><li><strong>最终一致性</strong>：非强一致，消息有<strong>延迟可见</strong>窗口，不适用金融核心交易等场景。</li><li><strong>回查复杂性</strong>：需实现回查接口，逻辑必须<strong>幂等</strong>，状态判断困难，增加了业务代码复杂度和侵入性。</li><li><strong>性能开销</strong>：相比普通消息，多了 RPC 交互和回查，存在性能和延迟损耗。</li><li><strong>依赖生产者</strong>：若生产者宕机，未决消息会阻塞，引入单点风险。</li></ul><h3 id="【中等】为什么-rocketmq-不用-zookeeper-而是自己开发-nameserver" tabindex="-1"><a class="header-anchor" href="#【中等】为什么-rocketmq-不用-zookeeper-而是自己开发-nameserver" aria-hidden="true">#</a> 【中等】为什么 RocketMQ 不用 ZooKeeper，而是自己开发 NameServer？</h3><p>RocketMQ 自研 NameServer 的根本原因在于：<strong>ZooKeeper 的强一致性保障带来了不必要的性能和复杂度开销，而消息队列的路由发现场景本身是一个更注重高可用和高性能的 AP 场景</strong>。</p><ul><li><strong>ZooKeeper (CP)</strong>：<strong>太重</strong>。为强一致性牺牲性能，功能冗余，运维复杂。</li><li><strong>NameServer (AP)</strong>：<strong>专为消息队列设计</strong>。轻量、无状态、节点间无同步，实现最终一致性，延迟极低。</li></ul><p>概括来说，核心是为了<strong>简单、高效、专注</strong>。</p><p>RocketMQ 自研轻量级 NameServer 而非使用 ZooKeeper，主要基于以下考量：</p><ol><li><strong>简洁专用</strong>：NameServer 设计简单，专为 RocketMQ 定制，更轻量、易部署。</li><li><strong>高可用性</strong>：NameServer 无状态、对等部署，通过 DNS/VIP 实现负载均衡，避免 ZooKeeper 在强一致性下可能出现的可用性问题。</li><li><strong>性能优化</strong>：无需复杂同步协议，处理更高效； ZooKeeper 写操作依赖主节点，难以扩展，而 NameServer 更适应消息队列的高频需求。</li><li><strong>降低依赖</strong>：减少对外部组件的依赖，简化架构，自主掌控实现与优化。</li><li><strong>定制化支持</strong>：更好满足消息队列特有的动态路由等需求，不受外部框架限制。</li></ol>',15);function M(Q,R){const r=l("ExternalLinkIcon");return s(),i("div",null,[c,t("ol",null,[d,h,p,k,t("li",null,[e("在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为 Unknown 未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 "),f,e(" 服务端回查的间隔时间和最大回查次数，请参见 "),t("a",u,[e("参数限制"),a(r)]),e("。")]),m,_]),x])}const b=n(g,[["render",M],["__file","index.html.vue"]]);export{b as default};
